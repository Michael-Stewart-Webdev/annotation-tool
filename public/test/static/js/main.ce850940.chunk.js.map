{"version":3,"sources":["favicon.png","redcoat-1-threshold.png","pages/FeaturesPage.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","FeaturesPage","props","className","href","title","Component","dateFormat","require","clearWindowSelection","window","getSelection","empty","removeAllRanges","document","selection","Navbar","id","to","src","logo","this","pageTitle","username","Category","item","index","children","childItems","open","map","key","openedItems","has","full_name","onClick","hotkeyMap","hotkeyChain","isTopLevelCategory","applyTag","hasHotkey","hasOwnProperty","hotkeyStr","join","content","data-hotkey-id","name","toString","draggableId","provided","snapshot","ref","innerRef","draggableProps","isDragging","colorId","dragHandleProps","CategoryHierarchy","state","itemOrder","orderedItems","Set","onDragEnd","bind","prevProps","prevState","t","Array","items","length","i","setupItemOrder","_","isEqual","setState","delete","add","result","destination","list","startIndex","endIndex","from","splice","removed","reorder","source","order","getOrderedItems","initHotkeyMap","droppableId","droppableProps","isDraggingOver","toggleCategory","placeholder","getColourIdx","entityClass","entityColourMap","split","slice","Label","truncatedLabel","colourIdx","e","deleteTag","Word","selected","wordInnerRef","React","createRef","hasLabel","entityClasses","tagClass","bioTag","isLastInSpan","labels","wordColourClass","onMouseUp","updateSelections","onMouseDown","text","ConfidenceButton","docIdx","value","checked","updateConfidence","ConfidenceButtons","confidence","DocumentContainerHeader","DocumentContainer","displayIndex","words","annotations","selections","Sentence","wordIndex","action","node","$","domtoimage","toBlob","filter","classList","contains","bgcolor","then","blob","saveAs","isWordSelected","wordEndIndex","wordStartIndex","word","saveToPng","nextNode","hasChildNodes","firstChild","nextSibling","parentNode","HotkeyInfo","ec","undefined","chain","Annotation","token","tokenIndex","spanText","spanStartIdx","spanEndIdx","alreadyHasLabel","indexOf","push","otherAnnotation","console","log","WikipediaSummary","_isMounted","visible","querying","wikipediaSummary","wikipediaReadMoreUrl","tokens","next","snippet","wurl","wikipediaTitle","toLowerCase","ajax","url","data","srsearch","format","dataType","success","query","search","replace","err","getResult","queryWikipedia","summary","style","target","toggleVisibility","TaggingInterface","project_id","documentGroup","categoryHierarchy","pageNumber","annotatedDocGroups","documentGroupAnnotationId","confidences","getEmptySelectionsArray","currentSelection","getEmptyCurrentSelection","mostRecentSelectionText","reverseHotkeyMap","terminalHotkeys","hotkeyBindingFn","hotkeyTimeoutFn","holdingCtrl","holdingShift","docGroupLastModified","totalPagesAvailable","changesMade","recentlySaved","selectionChangeFn","windowMouseUpFn","loading","saving","firstLoad","showingProgressBar","taggingCompletePage","sel","rangeCount","r","range","startContainer","endNode","endContainer","rangeNodes","commonAncestorContainer","unshift","getRangeSelectedNodes","getRangeAt","removeClass","find","addClass","sentenceIndex","removeEventListener","selectionChange","windowMouseUp","addEventListener","preventDefault","moveSelectionHorizontally","moveSelectionVertically","hotkeyChainStr","clearTimeout","keyCode","is","prototype","concat","hotkeyTimeout","setTimeout","bindHotkeys","d","traverseChild","child","hotkeys","firstPass","Math","min","buildReverseHotkeyMap","setupHotkeyKeybinds","documents","automaticAnnotations","doc_idx","token_idx","parseInt","mention_idx","mention","start","end","label_idx","label","k","addLabel","ec_idx","each","ele","width","offsetWidth","newWidth","ceil","css","nextPageNumber","queryAPI","fetchConfig","method","headers","route","fetch","response","JSON","parse","alert","tagging_complete","projectName","initEntityColourMap","initConfidencesArray","initAnnotationsArray","lastModified","initKeybinds","initMouseEvents","clearWordJustification","justifyWords","selectFirstWord","scrollTo","annotationsJSON","docLabels","ann","csrfToken","cookieValue","cookie","cookies","trim","substring","decodeURIComponent","getCookie","annotationsToJSON","body","stringify","documentGroupId","newTotalPagesAvailable","Date","now","direction","j","max","numDocs","clearSelections","s","sel_idx","annotationSpanStart","annotationSpanEnd","notAllEqual","annotation","removeAllLabels","x","setSpanEndIdx","setSpanStartIdx","changeBioTag","ann_idx","labelWasModified","captureEvent","spanStart","spanEnd","removeLabel","eventAction","totalPages","docGroupsPerUser","submitAnnotations","loadPreviousPage","loadNextPage","goToPage","doc","SaveButton","buttonClass","iconClass","ProgressBar","show","ControlBar","pageNumberError","pageInputRef","current","val","blur","clearPageNumberInput","groupName","onSubmit","onChange","changePageNumber","latestGroup","TaggingCompletePage","class","Page404","Homepage","ProjectsListPage","MainTemplate","pageComponent","TaggingInterfaceTemplate","App","SERVER_DATA","path","render","p","match","params","exact","Boolean","location","hostname","ReactDOM","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.ce850940.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4goMAxI5sonxsgAACLtJREFUWMPtmHtwVNUdxz/n7t3dJLuJAUkkCiRgI6IG5ZFigtUi1VKiTIDOGKoyQwkyZIrWGUU67VBt2tEqoS2jDEWiSMVGmFGwyjCTgqJCHBJRNBCWh+S9m2ySzWafd/fuPf0jj0ayCQ/FznT8/XNnzvmd8/ue3+t8z4Xv5Xv5P5bVq1f/bwwbhkF1dTUAUkq7lHKKlHKWlPJOKeVdDofjxsH6NTU1l21LXO7CaDSqBIPBTTt37lx55swZAGbOnElubi6VlZXouh7RNG1bQUHBU9nZ2d0A+/fvZ+7cuVcWYCgUIiEhIenAgQMf7NixI9fr9WIymZBSkpycTE5ODhaLhZ6eHiZNmsSbb75JZmbmpg0bNjwjhGh3Op1kZGRcWQ86HI67y8vL9zc2Ng6Zk1KSlpaGz+cjFAqxaNEiSktLmTJlSteSJUvmLF68+Iuqqiry8vIuypZyqeCklNampqY3Ghoa4p9YCNxuN5qmIYTg1KlTTJ48mRMnTox+9dVXj61fv351Xl4eu3fv/nYBSikBcLvdO7ds2XLNiGERYuDrcDgoKSlB0zTq6+vZs2fPxhdeeOH5wsJCdu3adUG7posFJ4Sgs7Pzl2VlZU9kZWUJq9WK1+u9qIo/d+4cy5Yto6qqilAohMvlmr1q1SpjxYoVH34rHhRCIKWcXlFRUe52u5U77rgDVVW52LUej4cjR45QXFyM3+/H5XJRWVn59LPPPjv/GwM0DAMpZeKhQ4f27Nu3D8MwaGhowOl0nuflkUG2trbS3NxMaWkpmZmZ6LquuN3uuYsXL778Ku4PbV1d3fNlZWVP+v3+3rwwmdB1HSEEhiHRDYO0q5JweQIkmE0DORhvP7PZjN1u16SUrwWDwT8FAoHGt956a1gM6oXCEwqFpm7cuPFJn883YDgWi/WFHX44OYNfL8rFlGjB2xXgr29Xc6bVgxaJIoRAURSklB4hRIcQ4gNd17dv3rz5434bRUVF38iDSWVlZWerqqrGms3mrzdsLcqye6dyf172wCZCgDQMjnUn0xw009HeRnp6OtFo1FFYWHjjt37VPfbYY/e5XK7dQoj+apeA35qQGF56z9S0u2/NQOrGkHW6ruPJuIuwDhMmTEDXdcxmcyrgvVSAIxaJy+W6uQ9cE/AisFAIcdvjv1o5J3/q9XHBAZhVE5ZwO0IodHR04HA4ALz5+fmX7MFhc7AvN7YB/6ioqGgdPPe7tU+sUk0KxIYPjCpg/PhxdHR0xBobG1cBHD58+MqwmaKiIioqKgYqsfLTI6n5nD2SpJI9LNvBQk96Ls1tXVumTZu2cuvWrRQXF383dKtr4c+z7U+VnFCtLSoi/mUUiUZRLDfjSL56bs6kiQe+Uz7YAunmW6Z+mlZZMU62fTZ0GxlDj6bi+f2m49fs3ZuDEPJyASqXtchmC8VOO7yeR9Yg0iaeB85AjMnC/4ctGAcPJiOEbE5P5zsDqJfPIxYIG5hUQ/vgIOH9dYhRgwiobQze0u2E3/0XCDGhVU24cVx7+8DaKyr9BgIl069rHz+602mzSafNJn3rfivl2b1SHvunDG5/RTrtdtk/585OP9Sx9af3y7cLTZdjU71YYOryfQCJevm8B6U0toQPOUWsS0NGIhjtbgLuZoLdPuyOuv8yBwnGKEu+WYu9E+3WiL02v07GjHeQ/BtwqMv3NfXbGJVqx9Ptv/Qi6Qenl89bAGwiGrqOcTP45O+13LD/Y2LRKKGHl1BU8xFOl4cVaaMorm8f2PiwNHjYbHB6dDIpM9JJ/NkEMAmDmPQoQpxt6vS1eEJi7W3rPjp1njOGB9ivdPov88ekqtFrRyWZfoOgSEkaDbNKEFmzOd3YROSGbNKl5OT8Au7c/TYAP1FVtlmtmAArsCKsoQOvJVgJ6gbCpJD8wA8wz7oGoQoQAn9EkGyR7wl4XF2+7/SIRTL4BClmY29KgukzoYgi2vwc1ecgsmYDkD1hPA2PPooRiXDL5BvImTkTgFl9ZFZIaLaprCvNY01WKhogVAUE+N44RVd5Hb6wBW9njKRwJCID0YlCVRZdsIr7wjlGf2VelaqInHBMKj3eKB0balGf/jPdnZ0DunPWrqXZbkc4ndy3YAEADy5dCkKgAMc1nbpGH6PDMb7WCFUFajvhlU+5KqpBZ9iCFrspXN129UW1GWFW7o11hMfbNU1R3RGUU15kMMqYpiY+X79+QM+SmkqsoAC9poaCBQvIyspiSm4uAH6rwu2rckjxaNg6wwzp1IogctxD1BVESTET/qSNnm2OJc7EpKucNtvIAIMHWxtkUL+OgG4x6RHk2W6QoKoqKc89R31LSy+zVhQsq1cTaWlhdnY2Cxcu7CWFQtCtxdhR60Y92Y1FGWpGAiFVwfvyCTqfqSawtwGkHIcifpQRCAwP0Gm3Kb7XHct9rzvQjnWgt4bQvuwA0btpZmIi5x55BL1P/7bZs/nknnvg6FHWrFlDzOilYOYZadw+LR3bye5he4UOCJMY8GifLB85xBJVqMoM3Rkk8F49vtdPEvJG6Gd+UUVhQk0N7tragSXzyss5/vnnjB07FqmqKELwYWMPx6rbmNjnrXiixR8uuFAOCiB1gMMrgiBfp36JXi+nN2/ufch/tpfQR39DU+uJxgyE1Yo0IGfh9WRqBhYxfKsNA51De53ZabNlXQhg4vknHQzQpKqMeuklqt5/l5TqDaS2HWa65Qu+3PY4SnIqqklh08Em0uu6iZnEsDQqICXe+M34F3EB9lWPAqSdfx92DFKWwLUJScT+WII10do7JlTSPUc5cvwktbEw65behN068vUbAsYBcR4ODzhtNssQgH3VUxCv4szn5ZKuCEbXh4j23btC6gTTpjPrx/nYd+1m7cvHSewKY4z0j7Fv3ziSBYyP+2/mCYvlfcA2eMzf58WkITHSedHlowdBcMytXP9QGWbVRMakScx/aCXNfj/Br77CHgrFfcy7gbFCxAuxFdheFo06/wPG8+u7z0xHVgAAAABJRU5ErkJggg==\"","module.exports = __webpack_public_path__ + \"static/media/redcoat-1-threshold.78b878cf.png\";","import React from 'react';\r\nimport {Component} from 'react';\r\n\r\n\r\nclass FeaturesPage extends Component {\r\n\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n\r\n  render() {\r\n\r\n    return (\r\n\t    <article className=\"features-list\">\r\n\r\n\t\t\t<h2>List of current features (v1.0, 5 April 2019)</h2>\r\n\r\n\t\t\t<p>Below is a list of features that are currently present in Redcoat.</p>\r\n\r\n\t\t\t<ul>\r\n\t\t\t\t<li> Project Setup page\r\n\t\t\t\t\t<ul>\r\n\t\t\t\t\t\t<li>Create annotation projects for Entity Recognition on the Setup Project page</li>\r\n\t\t\t\t\t\t<li>Automatic tokenisation of data, with summary of number of tokens/documents</li>\r\n\t\t\t\t\t\t<li>Create a concept hierarchy via an interactive tree, or alternatively via text input</li>\r\n\t\t\t\t\t\t<li>Multiple built-in hierarchies: NER, FIGER, Mining</li>\r\n\t\t\t\t\t\t<li>New project and associated data is persistent across refreshes</li>\r\n\t\t\t\t\t</ul>\r\n\t\t\t\t</li>\r\n\t\t\t\t<li>Projects page\r\n\t\t\t\t\t<ul>\r\n\t\t\t\t\t\t<li>Sort, search, and filter projects</li>\r\n\t\t\t\t\t\t<li>Detailed project summary</li>\r\n\t\t\t\t\t</ul>\r\n\t\t\t\t</li>\r\n\t\t\t\t\r\n\t\t\t\t<li>Annotation interface\r\n\t\t\t\t\t<ul>\r\n\t\t\t\t\t\t<li>Annotate projects via an intuitive user interface</li>\r\n\t\t\t\t\t\t<li>Keyboard support on the annotation interface (hotkeys, selection with arrow keys)</li>\r\n\t\t\t\t\t\t<li>Wikipedia summary of words in the annotation interface</li>\r\n\t\t\t\t\t\t<li>Search/filter category hierarchy to quickly find the relevant entity category\t</li>\r\n\t\t\t\t\t</ul>\r\n\t\t\t\t</li>\r\n\t\t\t</ul>\t\t\r\n\r\n\t\t\t<h3>Attributions</h3>\r\n\t\t\t<p>The pencil icon on the tagging interface was made by <a href=\"https://www.flaticon.com/authors/icongeek26\" title=\"Icongeek26\">Icongeek26</a> from <a href=\"https://www.flaticon.com/\" title=\"Flaticon\">www.flaticon.com</a>.</p>\r\n\t\t</article>\r\n    )\r\n  }\r\n}\r\n\r\n\r\n\r\nexport default FeaturesPage;","import React from 'react';\nimport logo from './favicon.png'\nimport redcoatMan from './redcoat-1-threshold.png';\nimport './stylesheets/stylesheet.scss';\nimport {Component} from 'react';\nimport $ from 'jquery';\nimport { findDOMNode } from 'react-dom';\n\n//const ReactDragListView = require('react-drag-listview');\nimport { DragDropContext, Droppable, Draggable } from \"react-beautiful-dnd\";\nimport styled from 'styled-components';\nimport _ from 'underscore';\n\nimport html2canvas from 'html2canvas';\nimport { saveAs } from 'file-saver';\nimport domtoimage from 'dom-to-image';\n\nimport { Redirect, Link, BrowserRouter, Route, Switch } from 'react-router-dom'\n\nimport FeaturesPage from './pages/FeaturesPage';\n\n\nconst dateFormat = require('dateformat');\n\n\n\n\n\nconst BASE_URL = \"/\"\n\n\n\n// https://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\nfunction clearWindowSelection() {\n  if (window.getSelection) {\n    if (window.getSelection().empty) {  // Chrome\n      window.getSelection().empty();\n    } else if (window.getSelection().removeAllRanges) {  // Firefox\n      window.getSelection().removeAllRanges();\n    }\n  } else if (document.selection) {  // IE?\n    document.selection.empty();\n  }\n}\n\n// Function for getting value from a cookie\nfunction getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\n\n// The navbar, which appears at the top of the page.\nclass Navbar extends Component {\n  render() {\n    return (\n      <nav id=\"navbar\">\n        <div className=\"navbar-left\">\n          <div id=\"logo\">\n            <Link to=\"/\">\n              <span className=\"inner\">\n                <span className=\"img\">\n                  <img src={logo}/>\n                </span>\n                <span>Redcoat</span>\n              </span>\n            </Link>\n          </div>         \n        </div>\n        <div className=\"navbar-centre\">{this.props.pageTitle}</div>\n        <div className=\"navbar-right\">\n\n\n          { this.props.username && \n            <div className=\"dropdown-menu\">\n              <button>Projects</button>\n              <ul className=\"dropdown-menu-items\">\n                <li><Link to={\"\" + BASE_URL + \"projects\"}>Projects list</Link></li>\n                <li><Link to={\"\" + BASE_URL + \"setup-project\"}>Setup project</Link></li>\n              </ul>\n            </div>\n          }\n\n          { this.props.username &&\n\n            <div className=\"dropdown-menu\">\n              <button>Logged in as {this.props.username}</button>\n              <ul className=\"dropdown-menu-items\">\n                <li><Link to={\"\" + BASE_URL + \"profile\"}>Profile</Link></li>\n                <li><Link to={\"\" + BASE_URL + \"logout\"}>Logout</Link></li>\n              </ul>\n            </div>\n          }\n\n          { !this.props.username && \n\n            <div className=\"dropdown-menu\">\n              <button>Not logged in</button>\n              <ul className=\"dropdown-menu-items\">\n                <li><Link to={\"\" + BASE_URL + \"login\"}>Login</Link></li>\n                <li><Link to={\"\" + BASE_URL + \"register\"}>Register</Link></li>\n              </ul>\n            </div>\n          }\n\n          <div className=\"dropdown-menu short\">\n            <Link to={\"\" + BASE_URL + \"features\"}>v1.0</Link>\n          </div>\n        </div>\n      </nav>\n    )\n  }\n}\n\n// A single category in the category hierarchy tree.\nclass Category extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    var item = this.props.item;\n    var index = this.props.index;\n    var children = this.props.item.children;\n\n    // If this component has any children, render each of them.\n    if(children) {\n      var childItems = (\n        <ul className={this.props.open ? \"\" : \"hidden\"}>\n          { children.map((item, index) => (\n            <Category key={index}\n                      item={item}\n                      open={this.props.openedItems.has(item.full_name)}\n                      openedItems={this.props.openedItems}\n                      onClick={this.props.onClick}\n                      hotkeyMap={this.props.hotkeyMap}\n                      hotkeyChain={this.props.hotkeyChain}\n                      isTopLevelCategory={false}\n                      applyTag={this.props.applyTag}\n            />)) }\n        </ul>\n      );\n    } else {\n      var childItems = '';\n    }\n\n    // Determine whether this category has a hotkey (by checking hotkeyMap).\n    // Also determine hotkeyStr (for example '12' for 'item/pump').\n    var hasHotkey = this.props.hotkeyMap.hasOwnProperty(this.props.item.full_name)\n    var hotkeyStr = hasHotkey ? this.props.hotkeyMap[this.props.item.full_name].join('') : '';\n\n    var content = (\n      <span className=\"inner-container\">\n        \n         {children && <span className=\"open-button\" onClick={() => this.props.onClick(item.full_name)}><i className={\"fa fa-chevron-\" + (this.props.open ? \"up\" : \"down\")}></i></span>}\n       \n        <span className={\"category-name\" + (hasHotkey ? \" has-hotkey\" :\"\") + (this.props.hotkeyChain === hotkeyStr ? \" hotkey-active\" : \"\")}\n              data-hotkey-id={hotkeyStr} onClick={() => this.props.applyTag(this.props.item.full_name)}>             \n\n          {item.name}\n        </span>\n      </span>      \n    )\n\n\n    // This component will render differently depending on whether it is a top-level category or not.\n    // Top level categories have the drag handle, which requires a different configuration on the wrapper and li.\n    if(this.props.isTopLevelCategory) {\n      return (\n        <Draggable key={item.id.toString()} draggableId={item.id.toString()} index={index}>\n          {(provided, snapshot) => (\n            <li ref={provided.innerRef} {...provided.draggableProps} className={\"draggable \" + (snapshot.isDragging ? \"dragging\": \"not-dragging\") + \" color-\" + (item.colorId + 1)}>\n              <div {...provided.dragHandleProps} className=\"drag-handle-container\"><span className=\"drag-handle\"></span></div>\n              \n              { content }\n              { childItems }\n              \n            </li>\n          )}\n        </Draggable>\n      )\n    } else {\n      return (\n        <li>\n          { content }\n          { childItems }\n        </li>\n      )\n    }\n  }\n}\n\n\n\n// https://codesandbox.io/s/k260nyxq9v?file=/index.js:154-2795\n// a little function to help us with reordering the result\nconst reorder = (list, startIndex, endIndex) => {\n  const result = Array.from(list);\n  const [removed] = result.splice(startIndex, 1);\n  result.splice(endIndex, 0, removed);\n\n  return result;\n};\n\n// Retrieve a list of ordered items based on an order array.\nfunction getOrderedItems(items, order) {\n  var orderedItems = new Array(items.length);\n  for(var i = 0; i < order.length; i++) {\n    orderedItems[i] = items[order[i]];\n  }\n  return orderedItems;\n}\n\n// The category hierarchy (on the left).\nclass CategoryHierarchy extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      itemOrder: [],      // An array that maintains the ordering of the top-level categories.\n                          // e.g. [0, 1, 3, 2]\n      orderedItems: [],\n      openedItems: new Set(),    // An set keep track of the items that have been open (indexed by name).\n    }\n    this.onDragEnd = this.onDragEnd.bind(this);\n  }\n\n  // When this component's items changes (should be when a new docGroup has been requested), setup a new itemOrder state.\n  // (which defaults to ascending order e.g. 0, 1, 2, 3, 4 ...)\n  componentDidUpdate(prevProps, prevState) {\n    var t = this;\n    function setupItemOrder() {\n      var itemOrder = new Array(t.props.items.length);\n      for(var i = 0; i < itemOrder.length; i++) {\n        itemOrder[i] = i;\n      }\n      return itemOrder;\n    }\n    \n    var itemOrder = setupItemOrder();\n    if(!_.isEqual(prevProps.items, this.props.items)) {\n      this.setState({\n        openedItems: new Set(),\n        orderedItems: this.props.items,\n        itemOrder: itemOrder,\n      });\n    }\n  }\n\n  // Open or close a category.\n  // It's pretty awkward that this function is necessary. It would be ideal to store 'open' as a state variable inside the Category and Subcategory\n  // components, but that results in the wrong categories being open when the top-level categories are moved around.\n  // Storing them in the openedItems array in this component's state allows for the opened categories to be maintained when the user\n  // drags a category from one place to another.\n  // full_name should be the full name of the category, e.g. item/pump/centrifugal_pump, which are unique.\n  toggleCategory(full_name) {\n    var openedItems = this.state.openedItems;    \n\n    if(openedItems.has(full_name)) {\n      openedItems.delete(full_name);\n    } else {\n      openedItems.add(full_name);\n    }\n\n    this.setState({\n      openedItems: openedItems\n    })\n  }\n\n  // When the user has finished dragging a category, determine the new item order and save this order to the state.\n  onDragEnd(result) {\n    // dropped outside the list\n    if (!result.destination) {\n      return;\n    }\n\n    const itemOrder = reorder(\n      this.state.itemOrder,\n      result.source.index,\n      result.destination.index\n    );\n\n    var orderedItems = getOrderedItems(this.props.items, itemOrder)\n\n    this.props.initHotkeyMap(orderedItems, () =>\n      this.setState({\n        itemOrder: itemOrder,\n        orderedItems: orderedItems,\n      })\n    );\n  }\n\n  \n  render() {\n\n    var items       = this.state.orderedItems;\n    var openedItems = this.state.openedItems;\n\n    return (\n      <div id=\"category-hierarchy-tree\">\n        <DragDropContext onDragEnd={this.onDragEnd}>\n          <Droppable droppableId=\"droppable\">\n            {(provided, snapshot) => (\n              <ul\n                {...provided.droppableProps}\n                className={\"draggable-list\" + (snapshot.isDraggingOver ? \" dragging\" : \"\")}\n                ref={provided.innerRef}\n\n              >\n                {items.map((item, index) => (\n                  <Category \n                            key={index}\n                            item={item}\n                            index={index}\n                            onClick={this.toggleCategory.bind(this)}\n                            open={openedItems.has(item.name)} \n                            openedItems={this.state.openedItems} \n                            hotkeyMap={this.props.hotkeyMap}\n                            hotkeyChain={this.props.hotkeyChain}\n                            isTopLevelCategory={true}\n                            applyTag={this.props.applyTag}\n                  />\n                ))}\n                {provided.placeholder}\n              </ul>\n            )}\n          </Droppable>\n        </DragDropContext>\n      </div>\n    );\n  }\n}\n\n\n// Returns the colour id of the given entityClass according to the entityColourMap, e.g.\n// 'item/pump': 1 (because \"item\" is the top level category)\nfunction getColourIdx(entityClass, entityColourMap) {\n  var baseClass = entityClass.split(\"/\").slice(0, 1)[0];\n  return entityColourMap[baseClass];\n}\n\n// A label, drawn underneath a word.\nclass Label extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var split = this.props.entityClass.split('/');\n    var truncatedLabel = split.length > 1 ? \"/\" : \"\"\n    truncatedLabel = truncatedLabel + split[split.length - 1];\n\n    return (\n      <span className={\"label tag-\" + this.props.colourIdx} onClick={(e) => {this.props.deleteTag(this.props.entityClass);  }}><span className=\"label-name\">{truncatedLabel}</span></span>\n    )\n  }\n}\n\n// A single word (or token) in the tagging interface.\nclass Word extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: false,\n    }\n    this.wordInnerRef = React.createRef();\n  }\n\n  // Calls this.props.deleteTag with the index of this word as a parameter.\n  deleteTag(entityClass) {\n    this.props.deleteTag(this.props.index, entityClass);\n  }\n\n  // Clear the word justification of this word if it is does not have a label.\n  componentDidUpdate(prevProps, prevState) {\n\n    /* TODO: Fix the below to be much faster.\n       The code should update the width of this word back to auto if this word no longer has a label,\n       but it is too slow on long docs so I took it out.\n    */\n\n    // if(this.props.entityClasses.length === 0) {\n\n    //   var ele =  this.wordInnerRef.current;\n    //   $(ele).css(\"min-width\", \"auto\");\n\n    //   var width = ele.offsetWidth;\n    //   var newWidth = Math.ceil(width / 25) * 25;\n    //   $(ele).css('min-width', newWidth + 'px');        \n\n    // }\n  }\n\n  render() {\n\n    var hasLabel = this.props.entityClasses.length > 0;\n\n    var tagClass = hasLabel ? (\" tag \" + ((this.props.bioTag === \"B\") ? \"tag-begin\" : \"\") + (this.props.isLastInSpan ? \" tag-end\" : \"\")) : \"\";\n\n    if(hasLabel) {\n      var labels = this.props.entityClasses.map((entityClass, i) => \n                  <Label deleteTag={this.deleteTag.bind(this)} key={i} bioTag={this.props.bioTag} entityClass={entityClass} colourIdx={getColourIdx(entityClass, this.props.entityColourMap)} />\n                  )\n      \n    } else {\n      var labels = '';\n    }\n\n    var wordColourClass = (hasLabel ? (\" tag-\" + getColourIdx(this.props.entityClasses[0], this.props.entityColourMap)) : \"\")\n\n    return (\n      <span className={\"word\" + (this.props.selected ? \" selected\" : \"\") + tagClass}>\n\n        <span className={\"word-inner\" + wordColourClass} ref={this.wordInnerRef}\n              onMouseUp=  {() => this.props.updateSelections(this.props.index, 'up')}\n              onMouseDown={() => this.props.updateSelections(this.props.index, 'down')}>\n          {this.props.text}\n        </span>\n        {labels}\n        \n      </span>\n    );\n  }\n}\n\n\n// A single confidence button, which may have the value 'low' 'medium' or 'high'.\nclass ConfidenceButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    var docIdx = this.props.docIdx;\n    var value = this.props.value;\n    return (\n      <span className={\"confidence-button conf-\" + value + (this.props.checked ? \" checked\" : \"\")}\n            onClick={() => this.props.updateConfidence(docIdx, value)} title={\"Assign a \" + value + \" confidence to this document.\"} ></span>\n    )\n  }\n}\n\n\nclass ConfidenceButtons extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div className={\"confidence-buttons\"}>\n        <ConfidenceButton value=\"low\"    checked={this.props.confidence === \"low\"} { ...this.props }/>\n        <ConfidenceButton value=\"medium\" checked={this.props.confidence === \"medium\"} { ...this.props }/>\n        <ConfidenceButton value=\"high\"   checked={this.props.confidence === \"high\"} { ...this.props }/>        \n      </div>\n    )\n  }\n}\n\n\n// The document container header, which appears at the top of the sentence tagging page.\nclass DocumentContainerHeader extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div className=\"document-container header\">\n        <div className=\"document header\">\n          <div className=\"sentence-index\"></div>\n          <div className=\"sentence\">Document</div>\n          <div className=\"confidence-buttons\">Confidence</div>\n        </div>\n      </div>\n    )\n  }\n}\n\n// A document container, which contains the sentence index (on the left), the sentence, and the confidence buttons.\nclass DocumentContainer extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    return (\n      <div className={\"document-container\" + (this.props.confidence ? \" conf conf-\" + this.props.confidence : \"\")}>\n        <div className=\"document\">\n          <div className=\"sentence-index\"><span className=\"inner\">{this.props.displayIndex}</span></div>\n          <Sentence \n            index={this.props.index}\n            words={this.props.words}              \n            annotations={this.props.annotations}  \n            selections={this.props.selections}\n            updateSelections={this.props.updateSelections}\n            entityColourMap={this.props.entityColourMap}\n            deleteTag={this.props.deleteTag}\n          />\n          <ConfidenceButtons docIdx={this.props.index} confidence={this.props.confidence} updateConfidence={this.props.updateConfidence}/>\n        </div>\n      </div>\n    )\n  }\n\n}\n\n\n\n// A sentence in the tagging interface.\nclass Sentence extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  // Call the updateSelections function of the parent of this component (i.e. TaggingInterface), with this sentence's index included.\n  updateSelections(wordIndex, action) {\n    this.props.updateSelections(this.props.index, wordIndex, action)\n  }\n\n  deleteTag(wordIndex, entityClass) {\n    this.props.deleteTag(this.props.index, wordIndex, entityClass);\n  }\n\n  // Saves this sentence to a PNG file. wow!\n  saveToPng() {\n    var t = this;\n    var node = $(\"#sentence-tagging .sentence\")[this.props.index + 1];\n\n    function filter(node) {\n      if(node.classList) {\n        return !node.classList.contains('save-to-png');\n      }\n      return node;\n    }\n\n    domtoimage.toBlob(node, {filter: filter, bgcolor: '#fefefe'})\n    .then(function(blob) {\n      saveAs(blob, \"document-\" + t.props.index + \".png\"); \n    });\n\n  }\n\n  render() {\n\n    var selections = this.props.selections;\n\n    // Check props.selections to determine whether the word with a given index in this sentence is selected.\n    // This is passed to the word as a prop so that it can be highlighted accordingly.\n    function isWordSelected(wordIndex) {      \n      if(selections.length === 0) return false;     \n      for(var i = 0; i < selections.length; i++) {\n        var selection = selections[i];\n        if(selection.wordEndIndex < 0) continue;\n        if(selection.wordEndIndex >= wordIndex && wordIndex >= selection.wordStartIndex ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return (\n      <div className=\"sentence\">\n        { this.props.words.map((word, i) => \n          <Word key={i}\n                index={i}\n                text={word}\n                selected={isWordSelected(i)}\n                entityClasses={this.props.annotations[i].entityClasses || []}\n                isLastInSpan={this.props.annotations[i].isLastInSpan()}\n                bioTag={this.props.annotations[i].bioTag}\n                updateSelections={this.updateSelections.bind(this)}\n                entityColourMap={this.props.entityColourMap}\n                deleteTag={this.deleteTag.bind(this)}\n\n\n          />)\n        }   \n        <div className=\"save-to-png\" onClick={this.saveToPng.bind(this)} title=\"Click to download a .png file of this document\"><i className=\"fa fa-download\"></i></div>     \n      </div>\n    );\n  }\n\n}\n\n\n// A simple function for traversing a list of nodes. Goes with the function below.\n// Both functions found on StackOverflow: https://stackoverflow.com/questions/7781963/js-get-array-of-all-selected-nodes-in-contenteditable-div\nfunction nextNode(node) {\n    if (node.hasChildNodes()) {\n        return node.firstChild;\n    } else {\n      while (node && !node.nextSibling) {\n          node = node.parentNode;\n      }\n      if (!node) {\n          return null;\n      }\n      return node.nextSibling;\n    }\n}\n\n// A function for traversing the nodes present in the range object, which allows us to determine all html nodes\n// corresponding to selected items (items in which part of them are highlighted).\n// Note that you can't see the highlighted text on the screen because it has been hidden by css.\nfunction getRangeSelectedNodes(range) {\n    var node = range.startContainer;\n    var endNode = range.endContainer;\n\n    // Special case for a range that is contained within a single node\n    if (node == endNode) {\n        return [node.parentNode];\n    }\n\n    // Iterate nodes until we hit the end container\n    var rangeNodes = [];\n    while (node && node != endNode) {\n        rangeNodes.push( node = nextNode(node) );\n    }\n\n    // Add partially selected nodes at the start of the range\n    node = range.startContainer;\n    while (node && node != range.commonAncestorContainer) {\n        rangeNodes.unshift(node);\n        node = node.parentNode;\n    }\n\n    return rangeNodes;\n}\n\n\n// A simple class for displaying information related to the hotkeys the user is currently pressing.\nclass HotkeyInfo extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var ec = this.props.entityClass;\n    if(ec === undefined) {\n      ec = '(not a valid class)';\n    }\n\n    return (\n      <div className={\"hotkey-info\" + (this.props.chain.length === 0 ? \" hidden\": \"\")}>\n        <span className=\"chain\">{this.props.chain}</span>: <span>{ec}</span>\n      </div>\n    )\n\n  }\n}\n\n\n// A class to store an annotation for a single token.\n// Seemed more logical to put all the annotation logic in one class rather than sticking it in the TaggingInterface component.\n// Each sentence will have one Annotation object per token.\n// Properties:\n/* \n   token: the token e.g. 'centrifugal'\n   tokenIndex: the index of the token in the sentence\n   bioTag: the BIO tag ('B', 'I' or 'O')\n   entityClasses: the array of entity classes AKA labels (e.g. ['Item', 'Item/Pump'])   \n   spanText: the text of the span that this annotation is within (e.g. 'centrifugal pump')\n   spanStartIdx: the start index of the span this annotation is in, e.g. 0 if it starts at the first word of the sentence\n   spanEndIdx: the end index as above, e.g. 1,\n*/\nclass Annotation {\n  constructor(token, tokenIndex) {\n    this.token = token;\n    this.tokenIndex = tokenIndex;\n    this.bioTag = \"O\";    \n  }\n\n  // Adds the specified entityClass to this annotation.\n  // bioTag: The bioTag, e.g. \"B\" or \"I\",\n  // entityClass: The entity class, e.g. \"Item/Pump\"\n  // text: The text of the span that this annotation is inside, e.g. \"centrifugal pump\".\n  // spanStartIdx, spanEndIdx: self explanatory (as above)\n  // nextAnnotation: The Annotation object for the next token in the sentence.\n  //                 When called during the dictionary annotation tagging, nextAnnotation is not necessary.\n  // Returns whether the label of this annotation was modified at all.\n  addLabel(bioTag, entityClass, spanText, spanStartIdx, spanEndIdx) {\n    \n    if(this.entityClasses === undefined) this.entityClasses = new Array();\n\n    var alreadyHasLabel = this.entityClasses.indexOf(entityClass) !== -1;\n    if(this.bioTag === bioTag && this.spanText === spanText && this.spanStartIdx === spanStartIdx && this.spanEndIdx === spanEndIdx && alreadyHasLabel) {\n      return false;\n    }\n\n    // Adjust the span.\n    this.bioTag = bioTag;\n    this.spanText = spanText;\n    this.spanStartIdx = spanStartIdx;\n    this.spanEndIdx = spanEndIdx;\n\n    // Add the entityClass to the entityClasses array for this Annotation.\n    // If it is already there, don't add it again.\n    if(!alreadyHasLabel) {\n      this.entityClasses.push(entityClass);\n    }\n    return true;\n  \n    // If the nextAnnotation is from the same mention (AKA span) as this one, and does not have exactly the same labels after\n    // the new class has been appended to this annotation's entityClasses, change its BIO tag to B.\n    // This is the part that ensures mentions are split up when the user changes the label of token(s) inside that mention.\n    // if(nextAnnotation) {\n    //   if(this.sameMention(nextAnnotation) && !this.sameEntityClasses(nextAnnotation) && nextAnnotation.hasLabel()) {\n    //     console.log(\"Changing bio tag to B\")\n    //     nextAnnotation.changeBioTag(\"B\");\n    //     nextAnnotation.setSpanStartIdx(spanEndIdx + 1)          \n    //   }\n    // }\n\n    // If the previous annotation is from the same mention as this one, and now no longer has the same labels,\n    // adjust the spanEndIdx to be the start of this new span -1.\n    // This ensures the tags are rendered correctly in the browser.\n    // Note that this seems to get called multiple times when applying tags because they are applied in reverse order,\n    // but the spanEndIdx will be set as below for the next annotation anyway so that shouldn't be an issue.\n    // if(prevAnnotation) {\n    //   if(this.sameMention(prevAnnotation) && !this.sameEntityClasses(prevAnnotation) && prevAnnotation.hasLabel()) {  \n    //     prevAnnotation.setSpanEndIdx(spanStartIdx - 1);\n    //   }\n    // }\n  }\n\n  // Removes all the labels from this annotation and resets the bioTag to \"O\".\n  removeAllLabels() {\n    delete this.entityClasses;\n    delete this.spanText;\n    delete this.spanStartIdx;\n    delete this.spanEndIdx;\n    this.bioTag = \"O\";\n  }\n\n  // Simple function to determine whether this annotation is in the same mention as another annotation.\n  sameMention(otherAnnotation) {\n    return otherAnnotation.spanStartIdx === this.spanStartIdx && otherAnnotation.spanEndIdx === this.spanEndIdx;\n  }\n\n  // Determine whether this annotation has the same labels as another annotation.\n  sameEntityClasses(otherAnnotation) {\n    return _.isEqual(this.entityClasses, otherAnnotation.entityClasses);\n  }\n\n  // Removes a specific label from this annotation.\n  // If it was the last label, reset this annotation's bioTag to \"O\" and delete the entityClasses and other properties.\n  removeLabel(entityClass) {\n    var index = this.entityClasses.indexOf(entityClass);\n    if(index === -1) {\n      console.log(\"Warning: tried to remove an entity class from an annotation that did not exist.\")\n      return;\n    }\n    this.entityClasses.splice(index, 1);\n    if(this.entityClasses.length === 0) {\n      this.bioTag = \"O\";\n      delete this.entityClasses;\n      delete this.spanText;\n      delete this.spanStartIdx;\n      delete this.spanEndIdx;\n    }\n  }\n\n  // Change the bio tag of this annotation to another bio tag.\n  changeBioTag(bioTag) {\n    this.bioTag = bioTag;\n  }\n\n  // Returns whether this annotations has a label.\n  hasLabel() {\n    return this.bioTag !== \"O\";\n  }\n\n  // Determines whether this annotation is the last of its type in the given span.\n  isLastInSpan() {\n    return this.spanEndIdx === this.tokenIndex;\n  }\n\n  setSpanStartIdx(spanStartIdx) {\n    this.spanStartIdx = spanStartIdx;\n  }\n\n  setSpanEndIdx(spanEndIdx) {\n    this.spanEndIdx = spanEndIdx;\n  }\n\n  // Prints this annotation nicely to the console (for debugging).\n  prettyPrint() {\n    console.log(\"Token:    \", this.token);\n    console.log(\"BIO Tag:  \", this.bioTag)\n    console.log(\"Span:     \", this.spanText)\n    console.log(\"StartIdx: \", this.spanStartIdx)\n    console.log(\"EndIdx: \", this.spanEndIdx)\n    console.log(\"Classes:  \\n\", this.entityClasses);\n    console.log('\\n');\n  }\n}\n\n// A debug printing function for printing out a list of annotations for a document.\nfunction prettyPrintAnnotations(documentAnnotations) {\n  console.log(\"Annotations:\\n\")\n  console.log(\"=====================\")  \n  for(var token_idx in documentAnnotations) {\n    documentAnnotations[token_idx].prettyPrint();\n  }\n}\n\n// The Wikipedia summary container, at the top-left.\nclass WikipediaSummary extends Component {\n\n  _isMounted = false;\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      visible: true,\n      querying: false, // Currently in the middle of a query\n      wikipediaSummary: null,\n      wikipediaReadMoreUrl: null,\n    }\n\n  }\n\n\n  queryWikipedia() {\n    if(this.state.querying) return; // Don't query multiple things at once\n\n    var tokens = this.props.tokens;\n\n    // Query Wikipedia for the currently selected tokens.\n    function runQuery(next) {\n\n      // Processes the result of a Wikipedia query.\n      function getResult(data, next) {\n        function stripTags(str) {\n          return str.replace(/<\\/?[^>]+(>|$)/g, \"\");\n        }\n        try {\n          var title = data.query.search[0].title;\n          var snippet = stripTags(data.query.search[0].snippet);\n          var wurl = \"https://en.wikipedia.org/wiki/\" + data.query.search[0].title.replace(/ /g, '_');\n          return next(title, snippet, wurl);\n        } catch(err) {\n          next();\n        }\n      }\n      $.ajax({\n        url: 'https://en.wikipedia.org/w/api.php',\n        data: { action: 'query', list: 'search', srsearch: tokens, format: 'json' },\n        dataType: 'jsonp',\n        success: function(data) {\n          getResult(data, next);\n        }\n      });\n    } \n\n    this.setState({\n      querying: true\n    }, () => {\n      var wikipediaSummary, wikipediaReadMoreUrl;\n      var t = this;\n\n      runQuery(function(title, snippet, wurl) {\n        if(!t._isMounted) return;\n\n\n        var wikipediaTitle = tokens;\n        if(snippet) {        \n          if(title.toLowerCase() !== tokens.toLowerCase()) {\n            wikipediaTitle = title;\n          }\n          wikipediaSummary = snippet + \"...\";\n          wikipediaReadMoreUrl = wurl;\n        } else {\n          wikipediaReadMoreUrl = null;\n          wikipediaSummary = null;  \n        }      \n\n        t.setState({\n          wikipediaTitle: wikipediaTitle,\n          wikipediaSummary: wikipediaSummary,\n          wikipediaReadMoreUrl: wikipediaReadMoreUrl,\n          querying: false,\n        })  \n      });\n\n    });\n  }\n\n\n  // Ensure API calls to Wikipedia aren't being made while this component is not mounted.\n  componentDidMount() {\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  toggleVisibility() {\n    this.setState({\n      visible: !this.state.visible\n    })\n  }\n\n\n  componentDidUpdate(prevProps, prevState) {\n    if(prevProps.tokens !== this.props.tokens) {\n      this.queryWikipedia();\n    }\n  }\n\n  render() {    \n\n    if(!this.state.querying && this.state.wikipediaTitle && this.state.wikipediaTitle !== this.props.tokens) {\n      var title = <span className=\"different\">[{this.state.wikipediaTitle}] </span>\n    } else {\n      title = '';\n    }\n\n    var summary = this.state.wikipediaSummary ? this.state.wikipediaSummary : \"(no Wikipedia entry)\";\n    if(!this.props.tokens) {\n      summary = \"Select one or more words to automatically look them up on Wikipedia.\";\n    }\n    if(this.state.querying) {\n      summary = <span><i className=\"fa fa-spin fa-cog\"></i>&nbsp;&nbsp;Loading...</span>\n    }\n\n    // Rendering is a bit awkward, this could be tidied up\n    return (\n      <div className=\"tokens-info\">\n        <div id=\"wikipedia-summary-container\" className={this.state.visible ? \"show\" : \"hidden\"}>\n          <p className=\"tokens\">{this.props.tokens || 'Wikipedia lookup'}</p>\n          <p className=\"summary\">{ title }{ summary }</p>\n          <span className=\"more show\">\n            {(this.state.querying || !this.props.tokens) && <span className=\"left\" style={{\"color\": \"rgba(0, 0, 0, 0)\"}}>.</span>}\n            {!this.state.querying && this.props.tokens && <span className=\"left\">Results from Wikipedia</span>}\n            <span className=\"right\">\n              { !this.state.querying && this.props.tokens && <a id=\"ec-read-more\" href={this.state.wikipediaReadMoreUrl} target=\"_blank\">Read more <i className=\"fa fa-sm fa-external-link\"></i></a> } \n            </span>\n          </span>\n        </div>\n        <button id=\"wikipedia-hide-show\" className={this.state.visible ? \"up\" : \"down\"} onClick={this.toggleVisibility.bind(this)}>Show</button>\n      </div>\n    )\n  }\n}\n\n// The TaggingInterface class. Contains the vast majority of the logic for the interface.\nclass TaggingInterface extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      project_id: 'RtJp98vxk', // debug\n\n      // Data (from the server)\n      // The data in this object is only changed by calling the queryAPI method.\n      data: {\n        documentGroup: [],\n        categoryHierarchy: {'children': []},\n        pageNumber: -1,\n        annotatedDocGroups: -1,\n        username: \"\",\n      },\n\n      documentGroupAnnotationId: null, // The ID of the document group annotation object related to the document group the user is currently\n                                       // looking at. Will be null if the doc group has not been annotated by the user yet.\n                                       // Will be set when querying the API (for a previously annotated document group) or when\n                                       // submitting the annotations of a document group via submitAnnotations().\n\n      // Annotations array\n      annotations: [],  // Stores the user's annotations.\n      confidences: [],  // Stores the user's confidences.\n\n      // Selections\n      selections: this.getEmptySelectionsArray(10),       // The selections is an array containing a sub-array for each document,\n                                                          // which in turn hold all of the current selections made by the user for that\n                                                          // document.\n      currentSelection: this.getEmptyCurrentSelection(),  // The current selection is for when the user clicks a word and is in the process\n                                                          // of selecting an end word. \n      mostRecentSelectionText: null, // Keeps track of the tokens that the user most recently selected (for Wikipedia querying)\n      // Hotkeys\n      hotkeyMap: {},  // Stores a mapping of hotkey to number, e.g. 'item/pump': '11'.\n      reverseHotkeyMap: {}, // Stores the reverse of the above (number to hotkey), e.g. '11': 'item/pump'.\n      terminalHotkeys: new Set(),  // Stores the hotkeys of classes that are terminal, e.g. '1', '2' because Item and Activity do not have subclasses\n\n      hotkeyChain: [], // Stores the current hotkey chain, e.g. [1, 2, 3] = the user has pressed 1, then 2, then 3 in quick succession\n      hotkeyBindingFn: null,  // Stores the function that gets called via an eventlistener when a hotkey is pressed. Must be stored as a state\n                              // variable so that it can be detached when the hotkeys change.\n      hotkeyTimeoutFn: null,   // Stores the current hotkey timeout function.\n\n      // Key events\n      holdingCtrl: false, // Whether the user is currently holding the ctrl key.\n      holdingShift: false, // Whether the user is currently holding the shift key.\n\n      entityColourMap: {}, // A mapping of the top-level entity classes to a colour\n\n      docGroupLastModified: null, // Stores when the current document group was last saved.\n\n      pageNumber: -1, // The current page number the user is looking at.\n      totalPagesAvailable: -1, // The total number of pages available to the user, e.g. if they have annotated 1 group so far, then it's 2.\n\n      changesMade: false, // Stores whether the user has made any changes to the current document group.\n      recentlySaved: false, // Whether the doc group has been recently saved\n\n      selectionChangeFn: null,\n      windowMouseUpFn: null,\n\n      loading: {  // Stores whether this interface is currently requesting a docgroup from the server, or saving one\n        querying: true,\n        saving: false,\n        firstLoad: true,\n      },\n      showingProgressBar: false, // Whether the progress bar is currently visible\n\n      taggingCompletePage: false, // Set to true when the user is on the 'tagging complete' page.\n\n    }    \n  }\n\n\n\n  // When the user highlights text anywhere on the page, this function captures the event.\n  // If the user never selected a word to begin with, nothing happens.\n  // All it does is apply the 'highlighted' class onto any words that were caught in the highlighting.\n  // This function is purely stylistic, i.e. it doesn't affect any other components etc.\n  selectionChange(e, words) {\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      return;\n    }\n    var sel = window.getSelection && window.getSelection();\n\n    if (sel && sel.rangeCount > 0) {\n      var r =  getRangeSelectedNodes(sel.getRangeAt(0));  \n      words.removeClass('highlighted');\n      $(r).find('.word-inner').addClass('highlighted');  \n    }\n  }\n\n  // When the user releases the mouse, remove all highlighting from words (i.e. the words in the selection).\n  // If the user never selected a word to begin with (i.e. wordStartIndex < 0), clear all selections.\n  windowMouseUp(e, words) {\n    if(e.target.classList.contains('page-input')) return;\n\n    words.removeClass('highlighted');\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      clearWindowSelection();\n      return;\n    }\n    if(!e.target.classList.contains('word-inner')) { // Ensure that the user is not hovering over a word            \n      var sentenceIndex = this.state.currentSelection.sentenceIndex;\n      this.updateSelections(sentenceIndex, this.state.data.documentGroup[sentenceIndex].length - 1, 'up');\n    } \n  }\n\n  /* Mouse and keyboard events */\n\n  // Set up some mouse events - one for when text is selected (highlighted) in the browser.\n  // Note that in order to see the default browser highlighting the CSS file needs to be modified (it makes it invisible).\n  // Another for when the user releases the mouse anywhere on the page.\n  // Note that the majority of the mouse events are not in this function but are passed down to the Word elements via updateSelections.\n  // The event listeners need to be removed and reapplied to prevent duplication.\n  initMouseEvents() {\n\n    var words = $('.word-inner');\n\n    var selectionChangeFn = (e) => this.selectionChange(e, words);\n    var windowMouseUpFn = (e) => this.windowMouseUp(e, words);\n    \n    // Remove the old event listeners.\n    document.removeEventListener(\"selectionchange\", this.state.selectionChangeFn);   \n    window.removeEventListener('mouseup', this.state.windowMouseUpFn);\n\n    this.setState({\n      selectionChangeFn: selectionChangeFn,\n      windowMouseUpFn: windowMouseUpFn\n    }, () => {\n      // Add the new event listeners.\n      document.addEventListener(\"selectionchange\", this.state.selectionChangeFn);\n      window.addEventListener('mouseup', this.state.windowMouseUpFn);\n    });    \n  }\n\n  // Set up the key binds (ctrl, shift, left right up down etc).\n  // This function does not set up the hotkeys (that is done via setupHotkeyKeybinds)\n  initKeybinds() {\n\n    document.addEventListener('keydown', (e) => {\n      switch(e.key) {\n        case 'Shift':       if(!this.state.holdingShift) this.setState({ holdingShift: true }); break;\n        case 'Control':     if(!this.state.holdingCtrl) this.setState({ holdingCtrl: true }); break;\n\n        // For the arrows, call e.preventDefault() to prevent the window from scrolling\n        case 'ArrowLeft':   e.preventDefault(); this.moveSelectionHorizontally('left'); break; \n        case 'ArrowUp':     e.preventDefault(); this.moveSelectionVertically('up'); break;\n        case 'ArrowRight':  e.preventDefault(); this.moveSelectionHorizontally('right'); break;\n        case 'ArrowDown':   e.preventDefault(); this.moveSelectionVertically('down'); break;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      switch(e.key) {\n        case 'Shift':   if(this.state.holdingShift) this.setState({ holdingShift: false }); break;\n        case 'Control': if(this.state.holdingCtrl) this.setState({ holdingCtrl: false }); break;\n      }      \n    });\n  }\n\n\n\n  /* Hotkey functions */\n\n  // When the user has pressed a hotkey that is not quickly followed up with another hotkey, this function is called.\n  // Apply the corresponding entity class and reset the hotkey chain.\n  hotkeyTimeout() {\n    var hotkeyChainStr = this.state.hotkeyChain.join('');\n\n    var entityClass = this.state.reverseHotkeyMap[hotkeyChainStr];\n    if(entityClass !== undefined) this.applyTag(entityClass);\n\n    // Clear the existing hotkey timeout fn.\n    window.clearTimeout(this.state.hotkeyTimeoutFn);\n    this.setState({\n      hotkeyTimeoutFn: null,      \n      hotkeyChain: [],\n    })\n  }\n\n  // This function is called when a hotkey is pressed.\n  // If a hotkey was pressed previously within 333ms, the chain will grow until the point the user no longer presses a hotkey\n  // for 333ms.\n  bindHotkeys(e, hotkeyMap) {\n    if(e.keyCode < 49 || e.keyCode > 57) return; // Hotkeys are in the range 1-9, which are keyCode 49-57.\n    var key = e.keyCode - 48;\n\n    // If user is currently focused on the page input, do nothing.\n    if($(\"#page-input\").is(\":focus\")) return;\n\n    // Update the hotkey chain to include the key that was pressed\n    var hotkeyChain = Array.prototype.concat(this.state.hotkeyChain, key);\n    this.setState({\n      hotkeyChain: hotkeyChain\n    }, () => {\n\n      // Remove the previous timeout and set up a new one\n      window.clearTimeout(this.state.hotkeyTimeoutFn);\n\n\n\n      // Check if hotkey was terminal, i.e. at the leaf of the tree\n      if(this.state.terminalHotkeys.has(hotkeyChain.join(''))) {\n        this.hotkeyTimeout();\n      } else {\n        var hotkeyTimeoutFn = window.setTimeout(() => this.hotkeyTimeout(), 333);\n        this.setState({\n          hotkeyTimeoutFn: hotkeyTimeoutFn\n        });\n      }\n\n            \n      \n    });\n  }\n\n  // Assign keybinds to each of the hotkeys in the hotkey map.\n  setupHotkeyKeybinds() {\n    \n    console.log(\"Setting up hotkey keybinds...\")\n\n    console.log(this.state.reverseHotkeyMap);\n\n    // Clear the current hotkey binding function and set up a new one.\n    document.removeEventListener('keydown', this.state.hotkeyBindingFn);\n    var hotkeyBindingFn = (e) => this.bindHotkeys(e, this.state.hotkeyMap);\n\n    document.addEventListener('keydown', hotkeyBindingFn);\n\n    // Store the binding function in this.state so that it can be removed in subsequent calls of this function.\n    this.setState({\n      hotkeyBindingFn: hotkeyBindingFn,\n    });\n  }\n\n  // Builds the hotkey map according to the ordered category hierarchy, and saves it to this component's state.\n  // The hotkey map will change whenever the user changes the order of them items via drag and drop.\n  initHotkeyMap(orderedItems, next) {\n\n    console.log(\"Setting up hotkey map...\")\n    // Annoying that the following is a recursive function but I think it's the only way to do it.\n    // The result is a hotkeyMap as follows:\n    /*  {\n          'item': [1],\n          'item/pump': [1, 1],\n          'item/pump/centrifugal_pump': [1, 1, 1],\n          'item/pump/big_pump': [1, 1, 2],\n          'item/compressor': [1, 2],\n          'activity': [2]\n        }\n    */\n    function traverseChild(child, index, hotkeyMap, hotkeys, terminalHotkeys, firstPass) {\n      if(!firstPass) {\n        hotkeyMap[child.full_name] = hotkeys;\n      }\n      if(child.children) {\n        for(var i = 0; i < Math.min(9, child.children.length); i++) { // Don't go past index 9 so that the hotkeys make sense\n          traverseChild(child.children[i], i + 1, hotkeyMap, Array.prototype.concat(hotkeys, i + 1), terminalHotkeys);\n        }\n      } else {\n        terminalHotkeys.add(hotkeys.join(''));\n      }\n      return {hotkeyMap: hotkeyMap, terminalHotkeys: terminalHotkeys};          \n    }    \n\n    // Build the reverse of the hotkeyMap, i.e. swap the keys with the values.\n    // This assists with the hotkey bindings function.\n    function buildReverseHotkeyMap(hotkeyMap) {\n      var reverseHotkeyMap = {};\n      for(var key in hotkeyMap){\n        var val = hotkeyMap[key].join('');\n        reverseHotkeyMap[val] = key;\n      }\n      return reverseHotkeyMap;    \n    }\n\n\n    var d = traverseChild({children: orderedItems}, 1, [], [], new Set(), true);\n    var hotkeyMap = d.hotkeyMap;\n    var terminalHotkeys = d.terminalHotkeys;\n    var reverseHotkeyMap = buildReverseHotkeyMap(hotkeyMap);\n\n    // Once the hotkeyMap (and reverseHotkeyMap) has been created, set up the hotkey keybinds and call the callback fn.\n    this.setState({\n      hotkeyMap: hotkeyMap,\n      reverseHotkeyMap: reverseHotkeyMap,\n      terminalHotkeys: terminalHotkeys,\n    }, () => { this.setupHotkeyKeybinds(); if(next) next(); });\n  }\n\n\n  // Sets up an array to store the annotations with the same length as docGroup.\n  // Prepopulate the annotations array with the automaticAnnotations if available (after converting them to BIO).\n  // This could be either the dictionary-based annotations or the annotations that the user has previously entered.\n  initAnnotationsArray(documents, automaticAnnotations) {\n\n    var annotations = new Array(documents.length);\n    for(var doc_idx in documents) {\n      annotations[doc_idx] = new Array(documents[doc_idx].length);\n      for(var token_idx in documents[doc_idx]) {\n        annotations[doc_idx][token_idx] = new Annotation(documents[doc_idx][token_idx], parseInt(token_idx));\n      }\n    }\n\n    if(!automaticAnnotations) return annotations;\n\n    // Load annotations from the automaticAnnotations array if present.\n    for(var doc_idx in automaticAnnotations) {\n      for(var mention_idx in automaticAnnotations[doc_idx]['mentions']) {\n\n        var mention = automaticAnnotations[doc_idx]['mentions'][mention_idx];\n        var start = mention['start'];\n        var end = mention['end'];\n\n        for(var label_idx in mention['labels']) {\n          var label = mention['labels'][label_idx];\n\n          for(var k = start; k < end; k++) {\n            var bioTag = k === start ? 'B' : \"I\";\n            annotations[doc_idx][k].addLabel(bioTag, label, documents[doc_idx].slice(start, end).join(' '), start, end - 1)\n          }\n        }\n      }        \n    }\n    return annotations;\n  }\n\n  // Initialise the confidences array.\n  initConfidencesArray(documents) {\n    var confidences = new Array(documents.length);\n    return confidences;\n  }\n\n  // Initialise the entity colour map, which maps entity_class: colour_index, e.g. \"Item\": 1. Passed to the Word components to colour\n  // their labels accordingly.\n  initEntityColourMap(categoryHierarchy) {\n    var entityColourMap = {}\n    for(var ec_idx in categoryHierarchy) {\n      var entityClass = categoryHierarchy[ec_idx];\n      entityColourMap[entityClass.name] = entityClass.colorId + 1;\n    }\n    return entityColourMap;\n  }\n\n\n  /* Miscellaneous */\n\n  // Justify the words to the nearest 25px (i.e. round their width up to the nearest 25px).\n  // Not really necessary but makes the diagonal stripey lines line up properly when multiple tokens are selected.\n  // I spent about 2 hours trying to figure out how to get the stripey lines to line up properly, this is the result :D\n  justifyWords() {\n    $('.word-inner').each((i, ele) => {\n      var width = ele.offsetWidth;\n      var newWidth = Math.ceil(width / 25) * 25;\n      $(ele).css('min-width', newWidth + 'px');\n    });\n  }\n\n  // Remove min-width from words that do not have a tag\n  // (necessary to call between pages)\n  clearWordJustification() {\n    $('.word:not(.tag) .word-inner').each((i, ele) => {\n       $(ele).css('min-width', 'auto');\n    })\n  }\n\n  // Load the next page by calling the API.\n  // Query without a page number (i.e. request the latest group)\n  // if the user is looking at the group before the latest group.\n  //\n  // TODO: Make it so that when the user has made a change to the group they're looking at,\n  // pop up a confirmation window to confirm their changes before loading the next page?\n  loadNextPage() {\n    var nextPageNumber = this.state.pageNumber + 1;\n    if(nextPageNumber === (this.state.totalPagesAvailable)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, nextPageNumber);\n    }\n  }\n\n  goToPage(pageNumber) {\n    if(pageNumber === (this.state.totalPagesAvailable)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, pageNumber);\n    }\n  }\n\n  // Load the previous page by calling the API.\n  loadPreviousPage() {\n    this.queryAPI(false, this.state.pageNumber - 1);\n  }\n\n  /* API calls */\n\n  queryAPI(firstLoad, pageNumber) {\n    const fetchConfig = {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }\n    };\n    var route = 'getDocumentGroup';\n\n    // If this function was called with a pageNumber, load a specific documentGroupAnnotation.\n    if(pageNumber) {\n      route = 'getPreviouslyAnnotatedDocumentGroup?pageNumber=' + pageNumber;\n    }\n\n    this.setState({\n      loading: {\n        querying: true,\n        saving: false,\n        firstLoad: firstLoad,\n      }\n    }, function() {\n      fetch('http://localhost:3000/projects/' + this.props.project_id + '/tagging/' + route, fetchConfig) // TODO: move localhost out\n        .then(response => response.text())\n        .then((data) => {\n          try { \n            var d = JSON.parse(data);\n          } catch(err) {\n            alert(err);\n            return;\n          }\n\n\n          if(d.tagging_complete) {\n            console.log(d);\n            this.setState({\n              taggingCompletePage: true,\n              totalPagesAvailable: d.annotatedDocGroups + 1,\n              pageNumber: d.annotatedDocGroups + 1,\n              changesMade: false,\n              recentlySaved: false,\n\n              loading: {\n                querying: false,\n                saving: false,\n              },\n              data: {\n                username: d.username,\n                projectName: d.projectName,\n                documentGroup: [],\n                categoryHierarchy: {'children': []},\n                pageNumber: -1,\n                annotatedDocGroups: -1,\n              },\n            })\n            return;\n          } \n\n          \n          this.setState(\n            {\n              data: d,\n              entityColourMap: this.initEntityColourMap(d.categoryHierarchy.children),\n              confidences: this.initConfidencesArray(d.documentGroup),\n              annotations: this.initAnnotationsArray(d.documentGroup, d.automaticAnnotations),\n              selections: this.getEmptySelectionsArray(d.documentGroup.length),\n              mostRecentSelectionText: null,\n              pageNumber: d.pageNumber,\n              totalPagesAvailable: d.annotatedDocGroups + 1,\n              docGroupLastModified: d.lastModified,\n              documentGroupAnnotationId: d.documentGroupAnnotationId, // Will be null if this doc group has not yet been annotated\n              changesMade: false,\n              recentlySaved: false,\n              loading: {\n                querying: false,\n                saving: false\n              },     \n              taggingCompletePage: false,         \n            }, () => { \n              console.log(\"Data:\", this.state.data);\n\n              // Initialise keybinds and mouse events only on the first API call.\n              if(firstLoad) {\n                this.initKeybinds();              \n                this.initHotkeyMap(this.state.data.categoryHierarchy.children);   \n              }\n\n              this.initMouseEvents();\n              this.clearWordJustification();    \n              this.justifyWords();    \n              this.selectFirstWord();\n\n\n              window.scrollTo(0, 0);\n            })\n        });\n        \n\n    }.bind(this));\n  }\n\n  // Convert the annotations array into JSON.\n  annotationsToJSON() {\n    var annotations = this.state.annotations;\n    var annotationsJSON = [];\n    for(var doc_idx in annotations) {\n        \n      var docLabels = [];\n      for(var token_idx in annotations[doc_idx]) {\n        var ann = annotations[doc_idx][token_idx];\n        if(ann.entityClasses) {\n          docLabels.push([ann.bioTag + \"-\", ann.entityClasses]);\n        } else {\n          docLabels.push([\"\"])\n        }\n      }\n      annotationsJSON.push(docLabels);\n    }\n    return annotationsJSON;\n  }\n\n\n  // Submit the annotations of the document group that the user is currently looking at.\n  // TODO: Maybe make it so that you can't save the annoations until the user has put all their confidences in?\n  // Or perhaps do a check and pop a confirmation window up if they click save without doing anything to >= 1 document\n  submitAnnotations() {\n    if(this.state.recentlySaved) { return; } // If the user clicks on the green save button, provide them with the illusion that it is doing\n                                             // something when in fact nothing actually happens. Prevents people from spam clicking the save and\n                                             // calling the API 5000 times...\n                                             // It's kind of like how google sheets allows you to press Ctrl + S despite it saving every action\n                                             // automatically.\n\n    const csrfToken = getCookie('csrf-token');\n\n    var annotationsJSON = this.annotationsToJSON();\n\n    const fetchConfig = {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'csrf-token': csrfToken,\n      },\n      dataType: \"json\",\n      body: JSON.stringify({\n        documentGroupId: this.state.data.documentGroupId,\n        documentGroupAnnotationId: this.state.documentGroupAnnotationId,\n        labels: annotationsJSON\n      }),  \n    };\n\n    this.setState({\n      loading: {\n        querying: false,\n        saving: true,\n      }\n    }, () => {\n\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/submitAnnotations', fetchConfig) // TODO: move localhost out\n      .then(response => response.text())\n      .then((data) => {\n        try { \n          var d = JSON.parse(data);\n\n          console.log(d);\n\n          var documentGroupAnnotationId = d.documentGroupAnnotationId;\n          console.log(\"Submitted annotations OK\");\n\n          // If the user is on the last page (i.e. the 'current group'), add one to the totalPages array so that the user can\n          // click 'Next' to go to the latest doc group.\n          if(this.state.pageNumber === this.state.totalPagesAvailable) {\n            var newTotalPagesAvailable = this.state.totalPagesAvailable + 1;\n            this.setState({\n              showingProgressBar: true,\n            }, () => {\n              window.setTimeout(() => this.setState({\n                showingProgressBar: false,\n              }), 3000);\n            })\n\n          } else {\n            var newTotalPagesAvailable = this.state.totalPagesAvailable;\n          }\n\n          this.setState({\n             docGroupLastModified: Date.now(),\n             totalPagesAvailable: newTotalPagesAvailable,\n             changesMade: false,\n             recentlySaved: true,\n             documentGroupAnnotationId: documentGroupAnnotationId,\n             loading: {\n              querying: false,\n              saving: false\n             }\n          });\n        } catch(err) {\n          console.log(\"ERROR:\", err);\n          alert(data);\n        }\n        \n        //this.queryAPI(this.state.data.pageNumber + 1);\n      });\n    });\n  }\n\n  /* Mounting function */\n\n  // When this component is mounted, call the API.\n  // Set up the keybinds and mouseup event when done.\n  componentWillMount() {\n\n    // var pathname = window.location.pathname;\n    // var project_id = pathname.split('/')[2];\n    // if(pathname === \"/\") {\n    //   //var project_id = 'RtJp98vxk'; // React development (completed project)\n    //   //var project_id = 'KPJqR4HB8'; // React development (long docs)\n    //   var project_id = '-krXeW3R2'; // React development (big work order one)\n    // }\n    // if(!project_id || project_id.length < 8) {\n    //   alert(\"invalid project\");\n    //   return;\n    // }\n\n\n\n    // this.setState({\n    //   project_id: project_id\n    // }, () => { \n    this.queryAPI(true);\n  }  \n\n  /* Selection functions */\n\n  // Get an empty current selection.\n  // Called when we need to clear the current selection.\n  getEmptyCurrentSelection() {\n    return {\n      wordStartIndex: -1,\n      wordEndIndex: -1,\n      sentenceIndex: -1\n    }\n  }\n\n  // Move the selection up or down.\n  // This function should be called when one of those keys is pressed.\n  moveSelectionVertically(direction) {\n    console.log(\"Moving\", direction) // TODO: Make this move up and down\n  }\n\n  // Move the selection in the specified direction ('left', 'right').\n  // This function should be called when one of those keys is pressed.\n  moveSelectionHorizontally(direction) {\n    console.log(\"Moving\", direction)\n\n    var selections = this.state.selections;\n    var mostRecentSelectionText;\n\n    // Move all selections left or right\n    for(var i = 0; i < selections.length; i++) {\n      for(var j = 0; j < selections[i].length; j++) {\n        var selection = selections[i][j];\n\n        // Behaviour depends on whether shift is currently being held down.\n        if(direction === \"left\") {\n          if(!this.state.holdingShift) {\n            selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            selection.wordEndIndex = selection.wordStartIndex;\n          } else { // If shift is being held down, move the wordEndIndex backwards or move the wordStartIndex backwards depending on the current selection.\n            if(selection.wordEndIndex > selection.wordStartIndex) {\n              selection.wordEndIndex--;\n            } else {\n              selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            }\n          }\n        } else if (direction === \"right\") {\n          if(!this.state.holdingShift) { // If shift *is* being held down, this won't happen (the wordStartIndex won't change).\n            selection.wordStartIndex = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n          }\n          selection.wordEndIndex   = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n        }\n\n        mostRecentSelectionText = this.state.data.documentGroup[i].slice(selection.wordStartIndex, selection.wordEndIndex + 1).join(' ');\n      }\n    }\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText\n    });\n  }\n\n  // Get an empty selections array whose length is the number of docs in the current documentGroup.\n  getEmptySelectionsArray(numDocs) {\n    if(!numDocs) {\n      var numDocs = this.state.data.documentGroup.length;\n    }\n    var selections = new Array(numDocs);\n    for(var i = 0; i < selections.length; i++) {\n      selections[i] = new Array();\n    }    \n    return selections;\n  }  \n\n  // Select the first word in the first sentence.\n  // (called when a new group is loaded).\n  selectFirstWord() {\n    var selections = this.state.selections;\n    selections[0].push({\n      wordStartIndex: 0,\n      wordEndIndex: 0\n    });\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: this.state.data.documentGroup[0][0],\n    });\n  }\n\n  // Clear all active selections by resetting the selections array.\n  clearSelections() {\n    this.setState( {\n      currentSelection: this.getEmptyCurrentSelection(),\n      selections: this.getEmptySelectionsArray()\n    });\n  }\n\n  // Update this component's selections state.\n  // This function is called via the mouse, and has no relation to the keyboard (keyboard selections are handled above).\n  // sentenceIndex: The index of the sentence in which the selection was made.\n  // wordIndex: the index of the word that was clicked on, or hovered over and the mouse released.\n  // action: Whether the mouse was pressed down ('down') or released ('up').\n  updateSelections(sentenceIndex, wordIndex, action) {\n    var wordStartIndex, wordEndIndex;\n\n    var selections = this.state.selections;\n    var currentSelection = this.state.currentSelection;\n\n    if (action === \"down\") { // Mouse down, i.e. a word was clicked.\n\n      if(!this.state.holdingCtrl) {\n        selections = this.getEmptySelectionsArray(); // Reset all selections upon clicking a word, unless Ctrl is being held.\n      }\n      wordStartIndex = wordIndex;\n      wordEndIndex = -1;\n\n      // A new selection is made, capturing the index of the sentence that the user clicked on and the index of the word that they clicked.\n      currentSelection = {\n        sentenceIndex: sentenceIndex,\n        wordStartIndex: wordStartIndex\n      }      \n\n    } else if(action === \"up\") { // Mouse up, i.e. mouse was released when hovering over a word.\n\n      // Only allow selections where the user has clicked on a starting word.\n      if(currentSelection.wordStartIndex === -1) {\n        this.clearSelections();\n        return;\n      }\n\n      wordStartIndex = currentSelection.wordStartIndex;\n\n      // If the first word selected was in a different sentence, the wordStartIndex becomes the start of the sentence where the mouse was released.\n      if(currentSelection.sentenceIndex !== sentenceIndex) {  // TODO: Make this consider mouseX relative to the X of the initial token?\n        wordStartIndex = 0;\n      };\n\n      wordEndIndex = wordIndex;\n\n      // If the second word selected was before the first, swapperino them around (so that backwards selections work as expected).\n      if(wordIndex < wordStartIndex) {\n        var s = wordStartIndex;\n        wordStartIndex = wordIndex;\n        wordEndIndex = s;\n      }     \n\n      // Create a new selections json object and push it to the selections array for this sentence.\n      currentSelection = this.getEmptyCurrentSelection();\n      selections[sentenceIndex].push({\n        wordStartIndex: wordStartIndex,\n        wordEndIndex: wordEndIndex\n      });\n      var mostRecentSelectionText = this.state.data.documentGroup[sentenceIndex].slice(wordStartIndex, wordEndIndex + 1).join(' ');\n\n      clearWindowSelection(); // Remove the default browser selection highlighty thing.\n    }    \n\n    this.setState({\n      currentSelection: currentSelection,\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText ? mostRecentSelectionText : this.state.mostRecentSelectionText,\n    });\n  }\n\n\n\n\n  /* Tag application function */\n\n  // Apply a specific tag to all current selections.\n  // entityClass: The full name of the entity class, e.g. 'item/pump/centrifugal_pump'.\n  // This function will either be called via clicking on an entity class in the tree, or by using hotkeys.\n  applyTag(entityClass) {    \n    //console.log(\"Applying tag:\", entityClass);\n    var selections = this.state.selections;\n    var documents = this.state.data.documentGroup;\n    var annotations = this.state.annotations;\n\n    for(var doc_idx in selections) {\n      for(var sel_idx in selections[doc_idx]) {\n        var sel = selections[doc_idx][sel_idx];\n        var start = sel.wordStartIndex;\n        var end = sel.wordEndIndex;\n\n\n        /* 1. Disjoint spans */\n        // Check all labels across this selected span of tokens are the same before proceeding.\n        // If they are not, they must be cleared before adding a label.\n        var annotationSpanStart = annotations[doc_idx][start].spanStartIdx;\n        var annotationSpanEnd   = annotations[doc_idx][start].spanEndIdx;\n        var notAllEqual = false;          \n        for(var k = start + 1; k <= end; k++) {\n          var otherAnnotation = annotations[doc_idx][k]; \n          if(annotationSpanStart !== otherAnnotation.spanStartIdx || annotationSpanEnd !== otherAnnotation.spanEndIdx) {\n            notAllEqual = true;\n            break;\n          }          \n        }        \n\n        // If the labels across all tokens in the selected span are not the same, remove all labels for the entire span.\n        // Then modify the spanEndIdx of any annotations in this document whose spanEndIdx was overlapping the\n        // span that the user selected, setting them to be start index - 1 (before the span).\n        // This ensures the ends of the spans are drawn properly.\n        if(notAllEqual) {\n          for(var k = start; k <= end; k++) {\n            var annotation = annotations[doc_idx][k];\n            annotation.removeAllLabels();\n          }          \n          // Adjust the span end index of all prev labels to be start index - 1\n          // A shame that we have to iterate across all annotations in this document - this could probably be optimised\n          // but it probably barely impacts performance even on large docs (I think)\n          for(var x in annotations[doc_idx]) {\n            var annotation = annotations[doc_idx][x];\n\n\n            // If this new span overlaps the *end* of an existing span, change that span's end index to the start of this new\n            // span, -1\n\n            if(annotation.spanEndIdx >= start && annotation.spanStartIdx <= start) {              \n              annotation.setSpanEndIdx(start - 1);\n\n            }\n\n            // If this new span overlaps the *start* of an existing span, change that span's start index to be the end of this new span -1\n            // and change the BIO tag to \"B\".\n            if(annotation.spanStartIdx <= end) {\n              annotation.setSpanStartIdx(end + 1);              \n              if(annotation.tokenIndex === (end + 1)) {\n                annotation.changeBioTag(\"B\") // I am realising now that this BIO tag is unnecessary - it could be inferred\n              }\n            }\n          }\n        }\n\n        /* 2. Overlapping spans */\n        // Check for any spans that this new span will cut into.\n        // First, check to the left and adjust the spanEndIdx of all Annotation objects\n        // to the left of this span if they overlap.\n        for(var ann_idx in annotations[doc_idx].slice(0, start)) {\n          var annotation = annotations[doc_idx][ann_idx];          \n          if(annotation.spanStartIdx < start && annotation.spanEndIdx >= end) {            \n            annotation.setSpanEndIdx(start - 1);\n          }\n        }\n\n        // Do the same for any Annotation objects on the right hand side of this span, which are part of the same\n        // mention.\n        for(var ann_idx in annotations[doc_idx].slice(end + 1, annotations[doc_idx].length)) {\n          var annotation = annotations[doc_idx][parseInt(ann_idx) + end + 1];\n          if(annotation.spanStartIdx <= start && annotation.spanEndIdx >= end) {\n            annotation.setSpanStartIdx(end + 1);\n            if(ann_idx === '0') {\n              annotation.changeBioTag(\"B\");\n            }\n          }\n        }\n\n        /* 3. Applying the labels */\n        // Now, apply the tags to every token in the selected span.\n        var labelWasModified = false;\n        for(var k = start; k <= end; k++) {\n          var bioTag = k === start ? \"B\" : \"I\";\n          var spanText = documents[doc_idx].slice(start, end + 1).join(' ');\n\n          //var prevAnnotation = k > 0 ? annotations[doc_idx][k - 1] : null;\n          //var nextAnnotation = k < (documents[doc_idx].length - 1) ? annotations[doc_idx][k + 1] : null;          \n\n          labelWasModified = annotations[doc_idx][k].addLabel(bioTag, entityClass, spanText, start, end);\n\n        }\n\n        if(labelWasModified) this.captureEvent('Applied label', parseInt(doc_idx), start, end, entityClass);\n      }\n    }\n    this.setState({\n      annotations: annotations,\n    }, () => {\n      this.justifyWords(); // Justify the words again to ensure the stripey lines line up correctly\n\n      // Debug:\n      //prettyPrintAnnotations(this.state.annotations[0]);\n      //console.log(\"Updated annotations[0]:\", this.state.annotations[0]);\n    })\n\n  }\n\n  // Deletes the specified tag.\n  // Unlike applyTag, this is applied to a specified sentenceIndex and wordIndex rather than to all current selections.\n  deleteTag(sentenceIndex, wordIndex, entityClass) {\n    \n    var annotations = this.state.annotations;\n    var annotation = annotations[sentenceIndex][wordIndex];\n\n    // Retrieve the span start idx and span end idx of the annotation corresponding to (sentence_index, word_index)\n    var spanStart = annotation.spanStartIdx;\n    var spanEnd = annotation.spanEndIdx;\n\n    this.captureEvent('Deleted label', sentenceIndex, spanStart, spanEnd, entityClass);\n\n    // Find all annotations in this document in the same mention span and remove the label from all of them.\n    // (this will also remove the label from the annotation object at (sentence_index, word_index)).\n    for(var ann_idx in annotations[sentenceIndex]) {\n      var otherAnnotation = annotations[sentenceIndex][ann_idx];       \n      if(otherAnnotation.spanStartIdx === spanStart && otherAnnotation.spanEndIdx === spanEnd) {\n        otherAnnotation.removeLabel(entityClass);\n      }\n    }\n\n    this.setState({\n      annotations: annotations\n    });\n\n  }\n\n  /* Confidence */\n\n  // Updates the confidences array for the given doc.\n  // If the user clicks on the button they already clicked, then the confidence is reset to undefined.\n  updateConfidence(sentenceIndex, confidence) {\n    var confidences = this.state.confidences;\n    if(confidences[sentenceIndex] === confidence) {\n      confidences[sentenceIndex] = undefined;\n    } else {\n      confidences[sentenceIndex] = confidence;\n    }\n    this.setState({\n      confidences: confidences\n    });\n  }\n\n  /* Events */\n\n  // Capture an event\n  // TODO: Make it do something\n  captureEvent(eventAction, sentenceIndex, spanStart, spanEnd, entityClass) {\n\n    var tokenString = this.state.data.documentGroup[sentenceIndex].slice(spanStart, spanEnd + 1).join(' ')\n\n    var event = {\n      \"action\": eventAction,\n      \"sentenceIndex\": sentenceIndex,\n      \"wordIndex\": {\n        \"start\": spanStart,\n        \"end\": spanEnd,\n      },\n      \"entityClass\": entityClass,\n      \"tokenString\": tokenString\n    }\n\n    if(eventAction === \"Applied label\" || eventAction === \"Deleted label\") {\n      this.setState({\n        changesMade: true,\n        recentlySaved: false,\n      })\n    }\n\n  }\n\n  /* Rendering function */\n\n\n  render() {\n    var taggingCompletePage = this.state.taggingCompletePage;\n\n    return (\n        <div>            \n          <div id=\"tagging-interface\" className={(this.state.loading.querying ? \"loading\" : \"\") + (taggingCompletePage ? \" tagging-complete-page\" : \"\")}>\n\n            <div id=\"tagging-container\">\n              { taggingCompletePage && <TaggingCompletePage/>}\n              <div id=\"sentence-tagging\">\n\n                { this.state.loading.firstLoad && \n                  <div className=\"loading-message\">\n                    <i className=\"fa fa-cog fa-spin\"></i>Loading...\n                  </div>\n                }\n\n                <ControlBar\n                  showingProgressBar = {this.state.showingProgressBar}\n                  pageNumber = {this.state.pageNumber}\n                  totalPages = {this.state.data.docGroupsPerUser}\n                  totalPagesAvailable = {this.state.totalPagesAvailable}\n                  lastModified={this.state.docGroupLastModified}\n                  recentlySaved={this.state.recentlySaved}\n                  changesMade={this.state.changesMade}\n                  querying={this.state.loading.querying}\n                  saving={this.state.loading.saving}\n\n                  submitAnnotations={this.submitAnnotations.bind(this)}\n                  loadPreviousPage={this.loadPreviousPage.bind(this)}\n                  loadNextPage={this.loadNextPage.bind(this)}\n                  goToPage={this.goToPage.bind(this)}\n                />\n\n                <DocumentContainerHeader/>\n                    \n                { this.state.data.documentGroup.map((doc, i) => \n                  <DocumentContainer\n                    key={i}\n                    index={ i }\n                    displayIndex={( (this.state.pageNumber - 1) * 10 ) + i + 1  }\n                    words={doc}              \n                    annotations={this.state.annotations[i]}  \n                    confidence={this.state.confidences[i]}\n                    selections={this.state.selections[i]}\n                    updateSelections={this.updateSelections.bind(this)}\n                    updateConfidence={this.updateConfidence.bind(this)}\n                    entityColourMap={this.state.entityColourMap}\n                    deleteTag={this.deleteTag.bind(this)}\n                  />\n                  )}\n\n              </div>\n            </div>\n            <div id=\"tagging-menu\">\n              <WikipediaSummary tokens={this.state.mostRecentSelectionText}/>\n              <HotkeyInfo \n                chain={this.state.hotkeyChain}\n                entityClass={this.state.reverseHotkeyMap[this.state.hotkeyChain.join('')]}\n              />            \n              \n              <CategoryHierarchy\n                items={this.state.data.categoryHierarchy.children}\n                hotkeyMap={this.state.hotkeyMap}\n                hotkeyChain={this.state.hotkeyChain.join('')}\n                initHotkeyMap={this.initHotkeyMap.bind(this)}\n                applyTag={this.applyTag.bind(this)}              \n              />\n            </div>      \n          </div>\n        </div>\n       \n    )\n  }\n}\n\n// The humble save button that appears at the top of the page.\nclass SaveButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n\n    var buttonClass = \" disabled\";\n    if(this.props.changesMade) buttonClass = \"\";\n    if(this.props.recentlySaved) buttonClass = \" recently-saved\";\n    if(this.props.saving) buttonClass = \" saving\";\n\n    var iconClass = \"fa-save\";\n    if(this.props.recentlySaved) iconClass = \"fa-check\";\n    if(this.props.saving) iconClass = \"fa-cog fa-spin\"\n\n    var text = \"Save\";\n    if(this.props.recentlySaved) text = \"Saved\";\n    if(this.props.saving) text = \"Saving\";\n\n    return (\n      <button className={\"save-button\" + buttonClass} onClick={this.props.submitAnnotations}>\n        <i className={\"fa \" + iconClass}></i>\n        { text }\n      </button>\n    )\n  }\n}\n\n\n// The progress bar that appears when the user saves a new doc group.\nclass ProgressBar extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-progress-bar\" className={(this.props.show ? \"show\" : \"hide\")}>\n        <span className=\"progress-bar\">\n          <span className=\"inner\" style={{\"width\": (this.props.totalPagesAvailable - 1) / this.props.totalPages * 100 + \"%\"}}></span>\n        </span>\n      </div>\n    )\n  }\n}\n\n// The 'control bar', which appears at the top of the interface (with page numbers, group number etc).\nclass ControlBar extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state =  {\n      pageNumber: null, // The desired page number of the user (not necessarily the one they are currently on).\n      pageNumberError: false,\n    }\n    this.pageInputRef = React.createRef();\n  }\n\n  // clearPageNumberError() {\n  //   this.setState({\n  //     pageNumber: this.props.pageNumber,\n  //     pageNumberError: false,\n  //   })\n  // }\n\n  clearPageNumberInput() {\n    var ele = $(this.pageInputRef.current);\n    ele.val('');\n    ele.blur();\n  }\n\n  goToPage(e) {\n\n    this.clearPageNumberInput();\n    if(this.state.pageNumber === '') {\n      this.setState({ pageNumber: this.props.pageNumber })\n      e.preventDefault();\n      return null;\n    }\n\n    if(this.state.pageNumber < 1) {\n      this.setState({\n        pageNumber: 1,\n      }, () => { this.props.goToPage(this.state.pageNumber)});\n    } else if (this.state.pageNumber > this.props.totalPagesAvailable) {\n      this.setState({\n        pageNumber: this.props.totalPagesAvailable,\n      }, () => { this.props.goToPage(this.state.pageNumber)});\n    } else {\n      this.props.goToPage(this.state.pageNumber);\n    }\n \n\n    e.preventDefault();\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if(this.props.pageNumber !== prevProps.pageNumber) {\n      this.setState({\n        pageNumber: this.props.pageNumber\n      })\n    }\n  }\n\n\n  changePageNumber(e) {\n    this.setState({\n      pageNumber: e.target.value,\n    });\n  }\n\n  render() {\n\n    var groupName = (\n      <span className={\"group-name\" + (this.props.showingProgressBar ? \" progress-bar-underneath\" : \"\")}>\n        <span>Group <b>\n          <form onSubmit={this.goToPage.bind(this)}>\n          <input \n                 id=\"page-input\"\n                 className={\"page-input\" + (this.state.pageNumberError ? \" error\" : \"\")}\n                 placeholder={this.state.pageNumber}\n                 name=\"page-input\"\n                 onChange={(e) => this.changePageNumber(e)}\n                 ref={this.pageInputRef}\n                 />\n          </form>\n          \n        </b> of <b>{this.props.totalPages}</b></span>\n      </span>\n    );\n\n    var latestGroup = (this.props.totalPagesAvailable) === this.props.pageNumber // Whether the user is looking at the latest group, that they have not yet annotated\n\n    var lastModified = this.props.changesMade ? (this.props.saving ? \"\" : \"Changes not saved\") : (this.props.lastModified ? \"Saved on \" + dateFormat(this.props.lastModified, 'dd mmm') + ' at ' + dateFormat(this.props.lastModified, 'h:MM tt') : \"\");\n\n    return (\n      <div id=\"pagination\">\n        <div className=\"page-button-container previous-page\">\n          <button className={(this.props.pageNumber === 1 ? \" disabled\" : \"\")} onClick={this.props.loadPreviousPage}><i className=\"fa fa-chevron-left\"></i>Prev\n          </button>\n        </div>\n        <div className=\"filler-left\"></div>\n        <div className=\"current-page-container\">\n          { groupName }\n          <ProgressBar \n            show={this.props.showingProgressBar}\n            totalPagesAvailable={this.props.totalPagesAvailable}\n            totalPages={this.props.totalPages}\n          />\n        </div>\n        <div className=\"group-last-modified\">{lastModified }</div>\n        <div className=\"page-button-container \"><SaveButton changesMade={this.props.changesMade} recentlySaved={this.props.recentlySaved} saving={this.props.saving} submitAnnotations={this.props.submitAnnotations}  /></div>\n        <div className=\"page-button-container next-page\">\n          <button className={(latestGroup ? \" disabled\" : \"\")}  onClick={this.props.loadNextPage}>Next<i className=\"fa fa-chevron-right\"></i></button>\n        </div>              \n      </div>\n    )\n  }\n}\n\nclass TaggingCompletePage extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-complete-message\">\n        <span class=\"tagging-complete-text\">\n          <h2>Annotation complete!</h2>\n          <p>Thank you for your participation in this project.</p>\n\n        </span>\n\n\n      </div>\n    )\n\n  }\n}\n\nclass Page404 extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <main class=\"error-page\">\n\n        <h1>404: Page not found.</h1>\n        <p>The page you were looking for does not appear to exist.</p>\n\n\n      </main>\n    )\n  }\n}\n\nclass Homepage extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <p>Hello I am a homepage</p>\n        <p><Link to=\"/projects\">open project</Link></p>\n\n\n      </div>\n\n    )\n  }\n}\n\n\nclass ProjectsListPage extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <p>Hello I am the projects list page</p>\n        <p><Link to=\"/projects/-krXeW3R2/tagging\">open project</Link></p>\n\n\n      </div>\n\n    )\n  }\n}\n\n\n// A template component that renders the majority of the pages.\nclass MainTemplate extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    return (\n      <div>\n        <Navbar pageTitle={this.props.pageTitle} username={this.props.username} />\n        <main>\n          { this.props.pageComponent }\n        </main>\n      </div>\n    )\n  }\n}\n\n// A template component for the tagging interface, which is almost the same as MainTemplate but without the <main> container.\nclass TaggingInterfaceTemplate extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    return (\n      <div>\n        <Navbar pageTitle={this.props.pageTitle} username={this.props.username} />\n          { this.props.pageComponent }\n      </div>\n    )\n  }\n}\n\n\n\n\n\n// The app, which routes everything and renders the pages.\nclass App extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      pageTitle: \"Redcoat\",\n      username: \"???\"\n    }\n  }\n\n  // When mounted, query the server for the logged in user.\n  componentWillMount() {\n\n    console.log(window.SERVER_DATA);\n\n    const fetchConfig = {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }\n    };\n\n    this.setState({\n      loading: true,\n\n    }, () => {\n\n\n      fetch('http://localhost:3000/pageData', fetchConfig) // TODO: move localhost out\n      .then(response => response.text())\n      .then((data) => {\n        console.log(data);\n        var d = JSON.parse(data);\n        this.setState({\n          username: d.username,\n          loading: false\n        })\n      }); \n    });\n  }\n\n\n\n  render() {\n    return (    \n\n      <div id=\"app\" class={this.state.loading ? \"loading\" : \"\"}>\n        <BrowserRouter>\n          <Switch>\n            <Route        path=\"/projects/:id/tagging\"  render={(p) => <TaggingInterfaceTemplate {...this.state} pageComponent={<TaggingInterface project_id={p.match.params.id} />}/>} /> \n            <Route        path=\"/projects\"              render={( ) => <MainTemplate {...this.state} pageTitle=\"Projects\" pageComponent={ <ProjectsListPage/> } />} />     \n\n            <Route        path=\"/features\"              render={( ) => <MainTemplate {...this.state} pageTitle=\"Features\" pageComponent={ <FeaturesPage/> } />} />     \n            <Route  exact path=\"/\"                      render={( ) => <MainTemplate {...this.state} pageTitle=\"\" pageComponent={ <Homepage/> } />} />\n            <Route                                      render={( ) => <MainTemplate {...this.state} pageTitle=\"\" pageComponent={ <Page404/> } />} /> />\n          </Switch>\n        </BrowserRouter>\n      </div>      \n    );\n  }\n}\n\n\n\nexport default App;\n\n// Old code\n/* \n<div className=\"submit-annotations-container\">\n  <button className=\"submit-annotations-button\" onClick={this.submitAnnotations.bind(this)}>Submit annotations <i className=\"fa fa-chevron-right\"></i></button>\n</div>\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}