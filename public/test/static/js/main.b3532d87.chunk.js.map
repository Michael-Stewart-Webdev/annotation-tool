{"version":3,"sources":["favicon.png","redcoat-1-threshold.png","App.js","serviceWorker.js","index.js"],"names":["module","exports","dateFormat","require","clearWindowSelection","window","getSelection","empty","removeAllRanges","document","selection","Navbar","id","className","to","src","logo","this","props","pageTitle","href","username","Component","Category","item","index","children","childItems","open","map","key","openedItems","has","full_name","onClick","hotkeyMap","hotkeyChain","isTopLevelCategory","applyTag","hasHotkey","hasOwnProperty","hotkeyStr","join","content","data-hotkey-id","name","toString","draggableId","provided","snapshot","ref","innerRef","draggableProps","isDragging","colorId","dragHandleProps","CategoryHierarchy","state","itemOrder","orderedItems","Set","onDragEnd","bind","prevProps","prevState","t","Array","items","length","i","setupItemOrder","_","isEqual","setState","delete","add","result","destination","list","startIndex","endIndex","from","splice","removed","reorder","source","order","getOrderedItems","initHotkeyMap","droppableId","droppableProps","isDraggingOver","toggleCategory","placeholder","getColourIdx","entityClass","entityColourMap","split","slice","Label","truncatedLabel","colourIdx","e","deleteTag","Word","selected","wordInnerRef","React","createRef","hasLabel","entityClasses","tagClass","bioTag","isLastInSpan","labels","wordColourClass","onMouseUp","updateSelections","onMouseDown","text","ConfidenceButton","docIdx","value","checked","updateConfidence","title","ConfidenceButtons","confidence","DocumentContainerHeader","DocumentContainer","displayIndex","words","annotations","selections","Sentence","wordIndex","action","node","$","domtoimage","toBlob","filter","classList","contains","bgcolor","then","blob","saveAs","isWordSelected","wordEndIndex","wordStartIndex","word","saveToPng","nextNode","hasChildNodes","firstChild","nextSibling","parentNode","HotkeyInfo","ec","undefined","chain","Annotation","token","tokenIndex","spanText","spanStartIdx","spanEndIdx","alreadyHasLabel","indexOf","push","otherAnnotation","console","log","WikipediaSummary","visible","querying","wikipediaSummary","wikipediaReadMoreUrl","tokens","next","snippet","wurl","wikipediaTitle","toLowerCase","ajax","url","data","srsearch","format","dataType","success","query","search","replace","err","getResult","queryWikipedia","summary","style","target","toggleVisibility","TaggingInterface","project_id","documentGroup","categoryHierarchy","pageNumber","annotatedDocGroups","documentGroupAnnotationId","confidences","getEmptySelectionsArray","currentSelection","getEmptyCurrentSelection","mostRecentSelectionText","reverseHotkeyMap","terminalHotkeys","hotkeyBindingFn","hotkeyTimeoutFn","holdingCtrl","holdingShift","docGroupLastModified","totalPagesAvailable","changesMade","recentlySaved","selectionChangeFn","windowMouseUpFn","loading","saving","firstLoad","showingProgressBar","taggingCompletePage","sel","rangeCount","r","range","startContainer","endNode","endContainer","rangeNodes","commonAncestorContainer","unshift","getRangeSelectedNodes","getRangeAt","removeClass","find","addClass","sentenceIndex","removeEventListener","selectionChange","windowMouseUp","addEventListener","preventDefault","moveSelectionHorizontally","moveSelectionVertically","hotkeyChainStr","clearTimeout","keyCode","is","prototype","concat","hotkeyTimeout","setTimeout","bindHotkeys","d","traverseChild","child","hotkeys","firstPass","Math","min","buildReverseHotkeyMap","setupHotkeyKeybinds","documents","automaticAnnotations","doc_idx","token_idx","parseInt","mention_idx","mention","start","end","label_idx","label","k","addLabel","ec_idx","each","ele","width","offsetWidth","newWidth","ceil","css","nextPageNumber","queryAPI","fetchConfig","method","headers","route","fetch","response","JSON","parse","alert","tagging_complete","projectName","initEntityColourMap","initConfidencesArray","initAnnotationsArray","lastModified","initKeybinds","initMouseEvents","clearWordJustification","justifyWords","selectFirstWord","scrollTo","annotationsJSON","docLabels","ann","csrfToken","cookieValue","cookie","cookies","trim","substring","decodeURIComponent","getCookie","annotationsToJSON","body","stringify","documentGroupId","newTotalPagesAvailable","Date","now","pathname","location","direction","j","max","numDocs","clearSelections","s","sel_idx","annotationSpanStart","annotationSpanEnd","notAllEqual","annotation","removeAllLabels","x","setSpanEndIdx","setSpanStartIdx","changeBioTag","ann_idx","labelWasModified","captureEvent","spanStart","spanEnd","removeLabel","eventAction","totalPages","docGroupsPerUser","submitAnnotations","loadPreviousPage","loadNextPage","goToPage","doc","SaveButton","buttonClass","iconClass","ProgressBar","show","ControlBar","pageNumberError","pageInputRef","current","val","blur","clearPageNumberInput","groupName","onSubmit","onChange","changePageNumber","latestGroup","TaggingCompletePage","class","TestComponent","Homepage","App","path","component","exact","render","Boolean","hostname","match","ReactDOM","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b3532d87.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/redcoat-1-threshold.78b878cf.png\";","import React from 'react';\nimport logo from './favicon.png'\nimport redcoatMan from './redcoat-1-threshold.png';\nimport './stylesheets/stylesheet.scss';\nimport {Component} from 'react';\nimport $ from 'jquery';\nimport { findDOMNode } from 'react-dom';\n\n//const ReactDragListView = require('react-drag-listview');\nimport { DragDropContext, Droppable, Draggable } from \"react-beautiful-dnd\";\nimport styled from 'styled-components';\nimport _ from 'underscore';\n\nimport html2canvas from 'html2canvas';\nimport { saveAs } from 'file-saver';\nimport domtoimage from 'dom-to-image';\n\nimport { Redirect, Link, BrowserRouter, Route, Switch } from 'react-router-dom'\n\n\nconst dateFormat = require('dateformat');\n\n\n\n\n\nconst BASE_URL = \"/\"\n\n\n\n// https://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\nfunction clearWindowSelection() {\n  if (window.getSelection) {\n    if (window.getSelection().empty) {  // Chrome\n      window.getSelection().empty();\n    } else if (window.getSelection().removeAllRanges) {  // Firefox\n      window.getSelection().removeAllRanges();\n    }\n  } else if (document.selection) {  // IE?\n    document.selection.empty();\n  }\n}\n\n// Function for getting value from a cookie\nfunction getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\n\n// The navbar, which appears at the top of the page.\nclass Navbar extends Component {\n  render() {\n    return (\n      <nav id=\"navbar\">\n        <div className=\"navbar-left\">\n          <div id=\"logo\">\n            <Link to=\"/\">\n              <span className=\"inner\">\n                <span className=\"img\">\n                  <img src={logo}/>\n                </span>\n                <span>Redcoat</span>\n              </span>\n            </Link>\n          </div>         \n        </div>\n        <div className=\"navbar-centre\">{this.props.pageTitle}</div>\n        <div className=\"navbar-right\">\n          <div className=\"dropdown-menu\">\n            <button>Projects</button>\n            <ul className=\"dropdown-menu-items\">\n              <li><a href={\"\" + BASE_URL + \"projects\"}>Projects list</a></li>\n              <li><a href={\"\" + BASE_URL + \"setup-project\"}>Setup project</a></li>\n            </ul>\n          </div>\n\n          <div className=\"dropdown-menu\">\n            <button>Logged in as {this.props.username}</button>\n            <ul className=\"dropdown-menu-items\">\n              <li><a href={\"\" + BASE_URL + \"profile\"}>Profile</a></li>\n              <li><a href={\"\" + BASE_URL + \"logout\"}>Logout</a></li>\n            </ul>\n          </div>\n          <div className=\"dropdown-menu short\">\n            <a href={\"\" + BASE_URL + \"features\"}>v1.0</a>\n          </div>\n        </div>\n      </nav>\n    )\n  }\n}\n\n// A single category in the category hierarchy tree.\nclass Category extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    var item = this.props.item;\n    var index = this.props.index;\n    var children = this.props.item.children;\n\n    // If this component has any children, render each of them.\n    if(children) {\n      var childItems = (\n        <ul className={this.props.open ? \"\" : \"hidden\"}>\n          { children.map((item, index) => (\n            <Category key={index}\n                      item={item}\n                      open={this.props.openedItems.has(item.full_name)}\n                      openedItems={this.props.openedItems}\n                      onClick={this.props.onClick}\n                      hotkeyMap={this.props.hotkeyMap}\n                      hotkeyChain={this.props.hotkeyChain}\n                      isTopLevelCategory={false}\n                      applyTag={this.props.applyTag}\n            />)) }\n        </ul>\n      );\n    } else {\n      var childItems = '';\n    }\n\n    // Determine whether this category has a hotkey (by checking hotkeyMap).\n    // Also determine hotkeyStr (for example '12' for 'item/pump').\n    var hasHotkey = this.props.hotkeyMap.hasOwnProperty(this.props.item.full_name)\n    var hotkeyStr = hasHotkey ? this.props.hotkeyMap[this.props.item.full_name].join('') : '';\n\n    var content = (\n      <span className=\"inner-container\">\n        \n         {children && <span className=\"open-button\" onClick={() => this.props.onClick(item.full_name)}><i className={\"fa fa-chevron-\" + (this.props.open ? \"up\" : \"down\")}></i></span>}\n       \n        <span className={\"category-name\" + (hasHotkey ? \" has-hotkey\" :\"\") + (this.props.hotkeyChain === hotkeyStr ? \" hotkey-active\" : \"\")}\n              data-hotkey-id={hotkeyStr} onClick={() => this.props.applyTag(this.props.item.full_name)}>             \n\n          {item.name}\n        </span>\n      </span>      \n    )\n\n\n    // This component will render differently depending on whether it is a top-level category or not.\n    // Top level categories have the drag handle, which requires a different configuration on the wrapper and li.\n    if(this.props.isTopLevelCategory) {\n      return (\n        <Draggable key={item.id.toString()} draggableId={item.id.toString()} index={index}>\n          {(provided, snapshot) => (\n            <li ref={provided.innerRef} {...provided.draggableProps} className={\"draggable \" + (snapshot.isDragging ? \"dragging\": \"not-dragging\") + \" color-\" + (item.colorId + 1)}>\n              <div {...provided.dragHandleProps} className=\"drag-handle-container\"><span className=\"drag-handle\"></span></div>\n              \n              { content }\n              { childItems }\n              \n            </li>\n          )}\n        </Draggable>\n      )\n    } else {\n      return (\n        <li>\n          { content }\n          { childItems }\n        </li>\n      )\n    }\n  }\n}\n\n\n\n// https://codesandbox.io/s/k260nyxq9v?file=/index.js:154-2795\n// a little function to help us with reordering the result\nconst reorder = (list, startIndex, endIndex) => {\n  const result = Array.from(list);\n  const [removed] = result.splice(startIndex, 1);\n  result.splice(endIndex, 0, removed);\n\n  return result;\n};\n\n// Retrieve a list of ordered items based on an order array.\nfunction getOrderedItems(items, order) {\n  var orderedItems = new Array(items.length);\n  for(var i = 0; i < order.length; i++) {\n    orderedItems[i] = items[order[i]];\n  }\n  return orderedItems;\n}\n\n// The category hierarchy (on the left).\nclass CategoryHierarchy extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      itemOrder: [],      // An array that maintains the ordering of the top-level categories.\n                          // e.g. [0, 1, 3, 2]\n      orderedItems: [],\n      openedItems: new Set(),    // An set keep track of the items that have been open (indexed by name).\n    }\n    this.onDragEnd = this.onDragEnd.bind(this);\n  }\n\n  // When this component's items changes (should be when a new docGroup has been requested), setup a new itemOrder state.\n  // (which defaults to ascending order e.g. 0, 1, 2, 3, 4 ...)\n  componentDidUpdate(prevProps, prevState) {\n    var t = this;\n    function setupItemOrder() {\n      var itemOrder = new Array(t.props.items.length);\n      for(var i = 0; i < itemOrder.length; i++) {\n        itemOrder[i] = i;\n      }\n      return itemOrder;\n    }\n    \n    var itemOrder = setupItemOrder();\n    if(!_.isEqual(prevProps.items, this.props.items)) {\n      this.setState({\n        openedItems: new Set(),\n        orderedItems: this.props.items,\n        itemOrder: itemOrder,\n      });\n    }\n  }\n\n  // Open or close a category.\n  // It's pretty awkward that this function is necessary. It would be ideal to store 'open' as a state variable inside the Category and Subcategory\n  // components, but that results in the wrong categories being open when the top-level categories are moved around.\n  // Storing them in the openedItems array in this component's state allows for the opened categories to be maintained when the user\n  // drags a category from one place to another.\n  // full_name should be the full name of the category, e.g. item/pump/centrifugal_pump, which are unique.\n  toggleCategory(full_name) {\n    var openedItems = this.state.openedItems;    \n\n    if(openedItems.has(full_name)) {\n      openedItems.delete(full_name);\n    } else {\n      openedItems.add(full_name);\n    }\n\n    this.setState({\n      openedItems: openedItems\n    })\n  }\n\n  // When the user has finished dragging a category, determine the new item order and save this order to the state.\n  onDragEnd(result) {\n    // dropped outside the list\n    if (!result.destination) {\n      return;\n    }\n\n    const itemOrder = reorder(\n      this.state.itemOrder,\n      result.source.index,\n      result.destination.index\n    );\n\n    var orderedItems = getOrderedItems(this.props.items, itemOrder)\n\n    this.props.initHotkeyMap(orderedItems, () =>\n      this.setState({\n        itemOrder: itemOrder,\n        orderedItems: orderedItems,\n      })\n    );\n  }\n\n  \n  render() {\n\n    var items       = this.state.orderedItems;\n    var openedItems = this.state.openedItems;\n\n    return (\n      <div id=\"category-hierarchy-tree\">\n        <DragDropContext onDragEnd={this.onDragEnd}>\n          <Droppable droppableId=\"droppable\">\n            {(provided, snapshot) => (\n              <ul\n                {...provided.droppableProps}\n                className={\"draggable-list\" + (snapshot.isDraggingOver ? \" dragging\" : \"\")}\n                ref={provided.innerRef}\n\n              >\n                {items.map((item, index) => (\n                  <Category \n                            key={index}\n                            item={item}\n                            index={index}\n                            onClick={this.toggleCategory.bind(this)}\n                            open={openedItems.has(item.name)} \n                            openedItems={this.state.openedItems} \n                            hotkeyMap={this.props.hotkeyMap}\n                            hotkeyChain={this.props.hotkeyChain}\n                            isTopLevelCategory={true}\n                            applyTag={this.props.applyTag}\n                  />\n                ))}\n                {provided.placeholder}\n              </ul>\n            )}\n          </Droppable>\n        </DragDropContext>\n      </div>\n    );\n  }\n}\n\n\n// Returns the colour id of the given entityClass according to the entityColourMap, e.g.\n// 'item/pump': 1 (because \"item\" is the top level category)\nfunction getColourIdx(entityClass, entityColourMap) {\n  var baseClass = entityClass.split(\"/\").slice(0, 1)[0];\n  return entityColourMap[baseClass];\n}\n\n// A label, drawn underneath a word.\nclass Label extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var split = this.props.entityClass.split('/');\n    var truncatedLabel = split.length > 1 ? \"/\" : \"\"\n    truncatedLabel = truncatedLabel + split[split.length - 1];\n\n    return (\n      <span className={\"label tag-\" + this.props.colourIdx} onClick={(e) => {this.props.deleteTag(this.props.entityClass);  }}><span className=\"label-name\">{truncatedLabel}</span></span>\n    )\n  }\n}\n\n// A single word (or token) in the tagging interface.\nclass Word extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: false,\n    }\n    this.wordInnerRef = React.createRef();\n  }\n\n  // Calls this.props.deleteTag with the index of this word as a parameter.\n  deleteTag(entityClass) {\n    this.props.deleteTag(this.props.index, entityClass);\n  }\n\n  // Clear the word justification of this word if it is does not have a label.\n  componentDidUpdate(prevProps, prevState) {\n\n    /* TODO: Fix the below to be much faster.\n       The code should update the width of this word back to auto if this word no longer has a label,\n       but it is too slow on long docs so I took it out.\n    */\n\n    // if(this.props.entityClasses.length === 0) {\n\n    //   var ele =  this.wordInnerRef.current;\n    //   $(ele).css(\"min-width\", \"auto\");\n\n    //   var width = ele.offsetWidth;\n    //   var newWidth = Math.ceil(width / 25) * 25;\n    //   $(ele).css('min-width', newWidth + 'px');        \n\n    // }\n  }\n\n  render() {\n\n    var hasLabel = this.props.entityClasses.length > 0;\n\n    var tagClass = hasLabel ? (\" tag \" + ((this.props.bioTag === \"B\") ? \"tag-begin\" : \"\") + (this.props.isLastInSpan ? \" tag-end\" : \"\")) : \"\";\n\n    if(hasLabel) {\n      var labels = this.props.entityClasses.map((entityClass, i) => \n                  <Label deleteTag={this.deleteTag.bind(this)} key={i} bioTag={this.props.bioTag} entityClass={entityClass} colourIdx={getColourIdx(entityClass, this.props.entityColourMap)} />\n                  )\n      \n    } else {\n      var labels = '';\n    }\n\n    var wordColourClass = (hasLabel ? (\" tag-\" + getColourIdx(this.props.entityClasses[0], this.props.entityColourMap)) : \"\")\n\n    return (\n      <span className={\"word\" + (this.props.selected ? \" selected\" : \"\") + tagClass}>\n\n        <span className={\"word-inner\" + wordColourClass} ref={this.wordInnerRef}\n              onMouseUp=  {() => this.props.updateSelections(this.props.index, 'up')}\n              onMouseDown={() => this.props.updateSelections(this.props.index, 'down')}>\n          {this.props.text}\n        </span>\n        {labels}\n        \n      </span>\n    );\n  }\n}\n\n\n// A single confidence button, which may have the value 'low' 'medium' or 'high'.\nclass ConfidenceButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    var docIdx = this.props.docIdx;\n    var value = this.props.value;\n    return (\n      <span className={\"confidence-button conf-\" + value + (this.props.checked ? \" checked\" : \"\")}\n            onClick={() => this.props.updateConfidence(docIdx, value)} title={\"Assign a \" + value + \" confidence to this document.\"} ></span>\n    )\n  }\n}\n\n\nclass ConfidenceButtons extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div className={\"confidence-buttons\"}>\n        <ConfidenceButton value=\"low\"    checked={this.props.confidence === \"low\"} { ...this.props }/>\n        <ConfidenceButton value=\"medium\" checked={this.props.confidence === \"medium\"} { ...this.props }/>\n        <ConfidenceButton value=\"high\"   checked={this.props.confidence === \"high\"} { ...this.props }/>        \n      </div>\n    )\n  }\n}\n\n\n// The document container header, which appears at the top of the sentence tagging page.\nclass DocumentContainerHeader extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div className=\"document-container header\">\n        <div className=\"document header\">\n          <div className=\"sentence-index\"></div>\n          <div className=\"sentence\">Document</div>\n          <div className=\"confidence-buttons\">Confidence</div>\n        </div>\n      </div>\n    )\n  }\n}\n\n// A document container, which contains the sentence index (on the left), the sentence, and the confidence buttons.\nclass DocumentContainer extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    return (\n      <div className={\"document-container\" + (this.props.confidence ? \" conf conf-\" + this.props.confidence : \"\")}>\n        <div className=\"document\">\n          <div className=\"sentence-index\"><span className=\"inner\">{this.props.displayIndex}</span></div>\n          <Sentence \n            index={this.props.index}\n            words={this.props.words}              \n            annotations={this.props.annotations}  \n            selections={this.props.selections}\n            updateSelections={this.props.updateSelections}\n            entityColourMap={this.props.entityColourMap}\n            deleteTag={this.props.deleteTag}\n          />\n          <ConfidenceButtons docIdx={this.props.index} confidence={this.props.confidence} updateConfidence={this.props.updateConfidence}/>\n        </div>\n      </div>\n    )\n  }\n\n}\n\n\n\n// A sentence in the tagging interface.\nclass Sentence extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  // Call the updateSelections function of the parent of this component (i.e. TaggingInterface), with this sentence's index included.\n  updateSelections(wordIndex, action) {\n    this.props.updateSelections(this.props.index, wordIndex, action)\n  }\n\n  deleteTag(wordIndex, entityClass) {\n    this.props.deleteTag(this.props.index, wordIndex, entityClass);\n  }\n\n  // Saves this sentence to a PNG file. wow!\n  saveToPng() {\n    var t = this;\n    var node = $(\"#sentence-tagging .sentence\")[this.props.index + 1];\n\n    function filter(node) {\n      if(node.classList) {\n        return !node.classList.contains('save-to-png');\n      }\n      return node;\n    }\n\n    domtoimage.toBlob(node, {filter: filter, bgcolor: '#fefefe'})\n    .then(function(blob) {\n      saveAs(blob, \"document-\" + t.props.index + \".png\"); \n    });\n\n  }\n\n  render() {\n\n    var selections = this.props.selections;\n\n    // Check props.selections to determine whether the word with a given index in this sentence is selected.\n    // This is passed to the word as a prop so that it can be highlighted accordingly.\n    function isWordSelected(wordIndex) {      \n      if(selections.length === 0) return false;     \n      for(var i = 0; i < selections.length; i++) {\n        var selection = selections[i];\n        if(selection.wordEndIndex < 0) continue;\n        if(selection.wordEndIndex >= wordIndex && wordIndex >= selection.wordStartIndex ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return (\n      <div className=\"sentence\">\n        { this.props.words.map((word, i) => \n          <Word key={i}\n                index={i}\n                text={word}\n                selected={isWordSelected(i)}\n                entityClasses={this.props.annotations[i].entityClasses || []}\n                isLastInSpan={this.props.annotations[i].isLastInSpan()}\n                bioTag={this.props.annotations[i].bioTag}\n                updateSelections={this.updateSelections.bind(this)}\n                entityColourMap={this.props.entityColourMap}\n                deleteTag={this.deleteTag.bind(this)}\n\n\n          />)\n        }   \n        <div className=\"save-to-png\" onClick={this.saveToPng.bind(this)} title=\"Click to download a .png file of this document\"><i className=\"fa fa-download\"></i></div>     \n      </div>\n    );\n  }\n\n}\n\n\n// A simple function for traversing a list of nodes. Goes with the function below.\n// Both functions found on StackOverflow: https://stackoverflow.com/questions/7781963/js-get-array-of-all-selected-nodes-in-contenteditable-div\nfunction nextNode(node) {\n    if (node.hasChildNodes()) {\n        return node.firstChild;\n    } else {\n      while (node && !node.nextSibling) {\n          node = node.parentNode;\n      }\n      if (!node) {\n          return null;\n      }\n      return node.nextSibling;\n    }\n}\n\n// A function for traversing the nodes present in the range object, which allows us to determine all html nodes\n// corresponding to selected items (items in which part of them are highlighted).\n// Note that you can't see the highlighted text on the screen because it has been hidden by css.\nfunction getRangeSelectedNodes(range) {\n    var node = range.startContainer;\n    var endNode = range.endContainer;\n\n    // Special case for a range that is contained within a single node\n    if (node == endNode) {\n        return [node.parentNode];\n    }\n\n    // Iterate nodes until we hit the end container\n    var rangeNodes = [];\n    while (node && node != endNode) {\n        rangeNodes.push( node = nextNode(node) );\n    }\n\n    // Add partially selected nodes at the start of the range\n    node = range.startContainer;\n    while (node && node != range.commonAncestorContainer) {\n        rangeNodes.unshift(node);\n        node = node.parentNode;\n    }\n\n    return rangeNodes;\n}\n\n\n// A simple class for displaying information related to the hotkeys the user is currently pressing.\nclass HotkeyInfo extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var ec = this.props.entityClass;\n    if(ec === undefined) {\n      ec = '(not a valid class)';\n    }\n\n    return (\n      <div className={\"hotkey-info\" + (this.props.chain.length === 0 ? \" hidden\": \"\")}>\n        <span className=\"chain\">{this.props.chain}</span>: <span>{ec}</span>\n      </div>\n    )\n\n  }\n}\n\n\n// A class to store an annotation for a single token.\n// Seemed more logical to put all the annotation logic in one class rather than sticking it in the TaggingInterface component.\n// Each sentence will have one Annotation object per token.\n// Properties:\n/* \n   token: the token e.g. 'centrifugal'\n   tokenIndex: the index of the token in the sentence\n   bioTag: the BIO tag ('B', 'I' or 'O')\n   entityClasses: the array of entity classes AKA labels (e.g. ['Item', 'Item/Pump'])   \n   spanText: the text of the span that this annotation is within (e.g. 'centrifugal pump')\n   spanStartIdx: the start index of the span this annotation is in, e.g. 0 if it starts at the first word of the sentence\n   spanEndIdx: the end index as above, e.g. 1,\n*/\nclass Annotation {\n  constructor(token, tokenIndex) {\n    this.token = token;\n    this.tokenIndex = tokenIndex;\n    this.bioTag = \"O\";    \n  }\n\n  // Adds the specified entityClass to this annotation.\n  // bioTag: The bioTag, e.g. \"B\" or \"I\",\n  // entityClass: The entity class, e.g. \"Item/Pump\"\n  // text: The text of the span that this annotation is inside, e.g. \"centrifugal pump\".\n  // spanStartIdx, spanEndIdx: self explanatory (as above)\n  // nextAnnotation: The Annotation object for the next token in the sentence.\n  //                 When called during the dictionary annotation tagging, nextAnnotation is not necessary.\n  // Returns whether the label of this annotation was modified at all.\n  addLabel(bioTag, entityClass, spanText, spanStartIdx, spanEndIdx) {\n    \n    if(this.entityClasses === undefined) this.entityClasses = new Array();\n\n    var alreadyHasLabel = this.entityClasses.indexOf(entityClass) !== -1;\n    if(this.bioTag === bioTag && this.spanText === spanText && this.spanStartIdx === spanStartIdx && this.spanEndIdx === spanEndIdx && alreadyHasLabel) {\n      return false;\n    }\n\n    // Adjust the span.\n    this.bioTag = bioTag;\n    this.spanText = spanText;\n    this.spanStartIdx = spanStartIdx;\n    this.spanEndIdx = spanEndIdx;\n\n    // Add the entityClass to the entityClasses array for this Annotation.\n    // If it is already there, don't add it again.\n    if(!alreadyHasLabel) {\n      this.entityClasses.push(entityClass);\n    }\n    return true;\n  \n    // If the nextAnnotation is from the same mention (AKA span) as this one, and does not have exactly the same labels after\n    // the new class has been appended to this annotation's entityClasses, change its BIO tag to B.\n    // This is the part that ensures mentions are split up when the user changes the label of token(s) inside that mention.\n    // if(nextAnnotation) {\n    //   if(this.sameMention(nextAnnotation) && !this.sameEntityClasses(nextAnnotation) && nextAnnotation.hasLabel()) {\n    //     console.log(\"Changing bio tag to B\")\n    //     nextAnnotation.changeBioTag(\"B\");\n    //     nextAnnotation.setSpanStartIdx(spanEndIdx + 1)          \n    //   }\n    // }\n\n    // If the previous annotation is from the same mention as this one, and now no longer has the same labels,\n    // adjust the spanEndIdx to be the start of this new span -1.\n    // This ensures the tags are rendered correctly in the browser.\n    // Note that this seems to get called multiple times when applying tags because they are applied in reverse order,\n    // but the spanEndIdx will be set as below for the next annotation anyway so that shouldn't be an issue.\n    // if(prevAnnotation) {\n    //   if(this.sameMention(prevAnnotation) && !this.sameEntityClasses(prevAnnotation) && prevAnnotation.hasLabel()) {  \n    //     prevAnnotation.setSpanEndIdx(spanStartIdx - 1);\n    //   }\n    // }\n  }\n\n  // Removes all the labels from this annotation and resets the bioTag to \"O\".\n  removeAllLabels() {\n    delete this.entityClasses;\n    delete this.spanText;\n    delete this.spanStartIdx;\n    delete this.spanEndIdx;\n    this.bioTag = \"O\";\n  }\n\n  // Simple function to determine whether this annotation is in the same mention as another annotation.\n  sameMention(otherAnnotation) {\n    return otherAnnotation.spanStartIdx === this.spanStartIdx && otherAnnotation.spanEndIdx === this.spanEndIdx;\n  }\n\n  // Determine whether this annotation has the same labels as another annotation.\n  sameEntityClasses(otherAnnotation) {\n    return _.isEqual(this.entityClasses, otherAnnotation.entityClasses);\n  }\n\n  // Removes a specific label from this annotation.\n  // If it was the last label, reset this annotation's bioTag to \"O\" and delete the entityClasses and other properties.\n  removeLabel(entityClass) {\n    var index = this.entityClasses.indexOf(entityClass);\n    if(index === -1) {\n      console.log(\"Warning: tried to remove an entity class from an annotation that did not exist.\")\n      return;\n    }\n    this.entityClasses.splice(index, 1);\n    if(this.entityClasses.length === 0) {\n      this.bioTag = \"O\";\n      delete this.entityClasses;\n      delete this.spanText;\n      delete this.spanStartIdx;\n      delete this.spanEndIdx;\n    }\n  }\n\n  // Change the bio tag of this annotation to another bio tag.\n  changeBioTag(bioTag) {\n    this.bioTag = bioTag;\n  }\n\n  // Returns whether this annotations has a label.\n  hasLabel() {\n    return this.bioTag !== \"O\";\n  }\n\n  // Determines whether this annotation is the last of its type in the given span.\n  isLastInSpan() {\n    return this.spanEndIdx === this.tokenIndex;\n  }\n\n  setSpanStartIdx(spanStartIdx) {\n    this.spanStartIdx = spanStartIdx;\n  }\n\n  setSpanEndIdx(spanEndIdx) {\n    this.spanEndIdx = spanEndIdx;\n  }\n\n  // Prints this annotation nicely to the console (for debugging).\n  prettyPrint() {\n    console.log(\"Token:    \", this.token);\n    console.log(\"BIO Tag:  \", this.bioTag)\n    console.log(\"Span:     \", this.spanText)\n    console.log(\"StartIdx: \", this.spanStartIdx)\n    console.log(\"EndIdx: \", this.spanEndIdx)\n    console.log(\"Classes:  \\n\", this.entityClasses);\n    console.log('\\n');\n  }\n}\n\n// A debug printing function for printing out a list of annotations for a document.\nfunction prettyPrintAnnotations(documentAnnotations) {\n  console.log(\"Annotations:\\n\")\n  console.log(\"=====================\")  \n  for(var token_idx in documentAnnotations) {\n    documentAnnotations[token_idx].prettyPrint();\n  }\n}\n\n// The Wikipedia summary container, at the top-left.\nclass WikipediaSummary extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      visible: true,\n      querying: false, // Currently in the middle of a query\n      wikipediaSummary: null,\n      wikipediaReadMoreUrl: null,\n    }\n  }\n\n\n  queryWikipedia() {\n    if(this.state.querying) return; // Don't query multiple things at once\n\n    var tokens = this.props.tokens;\n\n    // Query Wikipedia for the currently selected tokens.\n    function runQuery(next) {\n\n      // Processes the result of a Wikipedia query.\n      function getResult(data, next) {\n        function stripTags(str) {\n          return str.replace(/<\\/?[^>]+(>|$)/g, \"\");\n        }\n        try {\n          var title = data.query.search[0].title;\n          var snippet = stripTags(data.query.search[0].snippet);\n          var wurl = \"https://en.wikipedia.org/wiki/\" + data.query.search[0].title.replace(/ /g, '_');\n          return next(title, snippet, wurl);\n        } catch(err) {\n          next();\n        }\n      }\n      $.ajax({\n        url: 'https://en.wikipedia.org/w/api.php',\n        data: { action: 'query', list: 'search', srsearch: tokens, format: 'json' },\n        dataType: 'jsonp',\n        success: function(data) {\n          getResult(data, next);\n        }\n      });\n    } \n\n    this.setState({\n      querying: true\n    }, () => {\n      var wikipediaSummary, wikipediaReadMoreUrl;\n      var t = this;\n\n      runQuery(function(title, snippet, wurl) {\n        var wikipediaTitle = tokens;\n        if(snippet) {        \n          if(title.toLowerCase() !== tokens.toLowerCase()) {\n            wikipediaTitle = title;\n          }\n          wikipediaSummary = snippet + \"...\";\n          wikipediaReadMoreUrl = wurl;\n        } else {\n          wikipediaReadMoreUrl = null;\n          wikipediaSummary = null;  \n        }      \n\n        t.setState({\n          wikipediaTitle: wikipediaTitle,\n          wikipediaSummary: wikipediaSummary,\n          wikipediaReadMoreUrl: wikipediaReadMoreUrl,\n          querying: false,\n        })  \n      });\n\n    });\n  }\n\n  toggleVisibility() {\n    this.setState({\n      visible: !this.state.visible\n    })\n  }\n\n\n  componentDidUpdate(prevProps, prevState) {\n    if(prevProps.tokens !== this.props.tokens) {\n      this.queryWikipedia();\n    }\n  }\n\n  render() {    \n\n    if(!this.state.querying && this.state.wikipediaTitle && this.state.wikipediaTitle !== this.props.tokens) {\n      var title = <span className=\"different\">[{this.state.wikipediaTitle}] </span>\n    } else {\n      title = '';\n    }\n\n    var summary = this.state.wikipediaSummary ? this.state.wikipediaSummary : \"(no Wikipedia entry)\";\n    if(!this.props.tokens) {\n      summary = \"Select one or more words to automatically look them up on Wikipedia.\";\n    }\n    if(this.state.querying) {\n      summary = <span><i className=\"fa fa-spin fa-cog\"></i>&nbsp;&nbsp;Loading...</span>\n    }\n\n    // Rendering is a bit awkward, this could be tidied up\n    return (\n      <div className=\"tokens-info\">\n        <div id=\"wikipedia-summary-container\" className={this.state.visible ? \"show\" : \"hidden\"}>\n          <p className=\"tokens\">{this.props.tokens || 'Wikipedia lookup'}</p>\n          <p className=\"summary\">{ title }{ summary }</p>\n          <span className=\"more show\">\n            {(this.state.querying || !this.props.tokens) && <span className=\"left\" style={{\"color\": \"rgba(0, 0, 0, 0)\"}}>.</span>}\n            {!this.state.querying && this.props.tokens && <span className=\"left\">Results from Wikipedia</span>}\n            <span className=\"right\">\n              { !this.state.querying && this.props.tokens && <a id=\"ec-read-more\" href={this.state.wikipediaReadMoreUrl} target=\"_blank\">Read more <i className=\"fa fa-sm fa-external-link\"></i></a> } \n            </span>\n          </span>\n        </div>\n        <button id=\"wikipedia-hide-show\" className={this.state.visible ? \"up\" : \"down\"} onClick={this.toggleVisibility.bind(this)}>Show</button>\n      </div>\n    )\n  }\n}\n\n// The TaggingInterface class. Contains the vast majority of the logic for the interface.\nclass TaggingInterface extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      project_id: 'RtJp98vxk', // debug\n\n      // Data (from the server)\n      // The data in this object is only changed by calling the queryAPI method.\n      data: {\n        documentGroup: [],\n        categoryHierarchy: {'children': []},\n        pageNumber: -1,\n        annotatedDocGroups: -1,\n        username: \"\",\n      },\n\n      documentGroupAnnotationId: null, // The ID of the document group annotation object related to the document group the user is currently\n                                       // looking at. Will be null if the doc group has not been annotated by the user yet.\n                                       // Will be set when querying the API (for a previously annotated document group) or when\n                                       // submitting the annotations of a document group via submitAnnotations().\n\n      // Annotations array\n      annotations: [],  // Stores the user's annotations.\n      confidences: [],  // Stores the user's confidences.\n\n      // Selections\n      selections: this.getEmptySelectionsArray(10),       // The selections is an array containing a sub-array for each document,\n                                                          // which in turn hold all of the current selections made by the user for that\n                                                          // document.\n      currentSelection: this.getEmptyCurrentSelection(),  // The current selection is for when the user clicks a word and is in the process\n                                                          // of selecting an end word. \n      mostRecentSelectionText: null, // Keeps track of the tokens that the user most recently selected (for Wikipedia querying)\n      // Hotkeys\n      hotkeyMap: {},  // Stores a mapping of hotkey to number, e.g. 'item/pump': '11'.\n      reverseHotkeyMap: {}, // Stores the reverse of the above (number to hotkey), e.g. '11': 'item/pump'.\n      terminalHotkeys: new Set(),  // Stores the hotkeys of classes that are terminal, e.g. '1', '2' because Item and Activity do not have subclasses\n\n      hotkeyChain: [], // Stores the current hotkey chain, e.g. [1, 2, 3] = the user has pressed 1, then 2, then 3 in quick succession\n      hotkeyBindingFn: null,  // Stores the function that gets called via an eventlistener when a hotkey is pressed. Must be stored as a state\n                              // variable so that it can be detached when the hotkeys change.\n      hotkeyTimeoutFn: null,   // Stores the current hotkey timeout function.\n\n      // Key events\n      holdingCtrl: false, // Whether the user is currently holding the ctrl key.\n      holdingShift: false, // Whether the user is currently holding the shift key.\n\n      entityColourMap: {}, // A mapping of the top-level entity classes to a colour\n\n      docGroupLastModified: null, // Stores when the current document group was last saved.\n\n      pageNumber: -1, // The current page number the user is looking at.\n      totalPagesAvailable: -1, // The total number of pages available to the user, e.g. if they have annotated 1 group so far, then it's 2.\n\n      changesMade: false, // Stores whether the user has made any changes to the current document group.\n      recentlySaved: false, // Whether the doc group has been recently saved\n\n      selectionChangeFn: null,\n      windowMouseUpFn: null,\n\n      loading: {  // Stores whether this interface is currently requesting a docgroup from the server, or saving one\n        querying: true,\n        saving: false,\n        firstLoad: true,\n      },\n      showingProgressBar: false, // Whether the progress bar is currently visible\n\n      taggingCompletePage: false, // Set to true when the user is on the 'tagging complete' page.\n\n    }    \n  }\n\n\n\n  // When the user highlights text anywhere on the page, this function captures the event.\n  // If the user never selected a word to begin with, nothing happens.\n  // All it does is apply the 'highlighted' class onto any words that were caught in the highlighting.\n  // This function is purely stylistic, i.e. it doesn't affect any other components etc.\n  selectionChange(e, words) {\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      return;\n    }\n    var sel = window.getSelection && window.getSelection();\n\n    if (sel && sel.rangeCount > 0) {\n      var r =  getRangeSelectedNodes(sel.getRangeAt(0));  \n      words.removeClass('highlighted');\n      $(r).find('.word-inner').addClass('highlighted');  \n    }\n  }\n\n  // When the user releases the mouse, remove all highlighting from words (i.e. the words in the selection).\n  // If the user never selected a word to begin with (i.e. wordStartIndex < 0), clear all selections.\n  windowMouseUp(e, words) {\n    if(e.target.classList.contains('page-input')) return;\n\n    words.removeClass('highlighted');\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      clearWindowSelection();\n      return;\n    }\n    if(!e.target.classList.contains('word-inner')) { // Ensure that the user is not hovering over a word            \n      var sentenceIndex = this.state.currentSelection.sentenceIndex;\n      this.updateSelections(sentenceIndex, this.state.data.documentGroup[sentenceIndex].length - 1, 'up');\n    } \n  }\n\n  /* Mouse and keyboard events */\n\n  // Set up some mouse events - one for when text is selected (highlighted) in the browser.\n  // Note that in order to see the default browser highlighting the CSS file needs to be modified (it makes it invisible).\n  // Another for when the user releases the mouse anywhere on the page.\n  // Note that the majority of the mouse events are not in this function but are passed down to the Word elements via updateSelections.\n  // The event listeners need to be removed and reapplied to prevent duplication.\n  initMouseEvents() {\n\n    var words = $('.word-inner');\n\n    var selectionChangeFn = (e) => this.selectionChange(e, words);\n    var windowMouseUpFn = (e) => this.windowMouseUp(e, words);\n    \n    // Remove the old event listeners.\n    document.removeEventListener(\"selectionchange\", this.state.selectionChangeFn);   \n    window.removeEventListener('mouseup', this.state.windowMouseUpFn);\n\n    this.setState({\n      selectionChangeFn: selectionChangeFn,\n      windowMouseUpFn: windowMouseUpFn\n    }, () => {\n      // Add the new event listeners.\n      document.addEventListener(\"selectionchange\", this.state.selectionChangeFn);\n      window.addEventListener('mouseup', this.state.windowMouseUpFn);\n    });    \n  }\n\n  // Set up the key binds (ctrl, shift, left right up down etc).\n  // This function does not set up the hotkeys (that is done via setupHotkeyKeybinds)\n  initKeybinds() {\n\n    document.addEventListener('keydown', (e) => {\n      switch(e.key) {\n        case 'Shift':       if(!this.state.holdingShift) this.setState({ holdingShift: true }); break;\n        case 'Control':     if(!this.state.holdingCtrl) this.setState({ holdingCtrl: true }); break;\n\n        // For the arrows, call e.preventDefault() to prevent the window from scrolling\n        case 'ArrowLeft':   e.preventDefault(); this.moveSelectionHorizontally('left'); break; \n        case 'ArrowUp':     e.preventDefault(); this.moveSelectionVertically('up'); break;\n        case 'ArrowRight':  e.preventDefault(); this.moveSelectionHorizontally('right'); break;\n        case 'ArrowDown':   e.preventDefault(); this.moveSelectionVertically('down'); break;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      switch(e.key) {\n        case 'Shift':   if(this.state.holdingShift) this.setState({ holdingShift: false }); break;\n        case 'Control': if(this.state.holdingCtrl) this.setState({ holdingCtrl: false }); break;\n      }      \n    });\n  }\n\n\n\n  /* Hotkey functions */\n\n  // When the user has pressed a hotkey that is not quickly followed up with another hotkey, this function is called.\n  // Apply the corresponding entity class and reset the hotkey chain.\n  hotkeyTimeout() {\n    var hotkeyChainStr = this.state.hotkeyChain.join('');\n\n    var entityClass = this.state.reverseHotkeyMap[hotkeyChainStr];\n    if(entityClass !== undefined) this.applyTag(entityClass);\n\n    // Clear the existing hotkey timeout fn.\n    window.clearTimeout(this.state.hotkeyTimeoutFn);\n    this.setState({\n      hotkeyTimeoutFn: null,      \n      hotkeyChain: [],\n    })\n  }\n\n  // This function is called when a hotkey is pressed.\n  // If a hotkey was pressed previously within 333ms, the chain will grow until the point the user no longer presses a hotkey\n  // for 333ms.\n  bindHotkeys(e, hotkeyMap) {\n    if(e.keyCode < 49 || e.keyCode > 57) return; // Hotkeys are in the range 1-9, which are keyCode 49-57.\n    var key = e.keyCode - 48;\n\n    // If user is currently focused on the page input, do nothing.\n    if($(\"#page-input\").is(\":focus\")) return;\n\n    // Update the hotkey chain to include the key that was pressed\n    var hotkeyChain = Array.prototype.concat(this.state.hotkeyChain, key);\n    this.setState({\n      hotkeyChain: hotkeyChain\n    }, () => {\n\n      // Remove the previous timeout and set up a new one\n      window.clearTimeout(this.state.hotkeyTimeoutFn);\n\n\n\n      // Check if hotkey was terminal, i.e. at the leaf of the tree\n      if(this.state.terminalHotkeys.has(hotkeyChain.join(''))) {\n        this.hotkeyTimeout();\n      } else {\n        var hotkeyTimeoutFn = window.setTimeout(() => this.hotkeyTimeout(), 333);\n        this.setState({\n          hotkeyTimeoutFn: hotkeyTimeoutFn\n        });\n      }\n\n            \n      \n    });\n  }\n\n  // Assign keybinds to each of the hotkeys in the hotkey map.\n  setupHotkeyKeybinds() {\n    \n    console.log(\"Setting up hotkey keybinds...\")\n\n    console.log(this.state.reverseHotkeyMap);\n\n    // Clear the current hotkey binding function and set up a new one.\n    document.removeEventListener('keydown', this.state.hotkeyBindingFn);\n    var hotkeyBindingFn = (e) => this.bindHotkeys(e, this.state.hotkeyMap);\n\n    document.addEventListener('keydown', hotkeyBindingFn);\n\n    // Store the binding function in this.state so that it can be removed in subsequent calls of this function.\n    this.setState({\n      hotkeyBindingFn: hotkeyBindingFn,\n    });\n  }\n\n  // Builds the hotkey map according to the ordered category hierarchy, and saves it to this component's state.\n  // The hotkey map will change whenever the user changes the order of them items via drag and drop.\n  initHotkeyMap(orderedItems, next) {\n\n    console.log(\"Setting up hotkey map...\")\n    // Annoying that the following is a recursive function but I think it's the only way to do it.\n    // The result is a hotkeyMap as follows:\n    /*  {\n          'item': [1],\n          'item/pump': [1, 1],\n          'item/pump/centrifugal_pump': [1, 1, 1],\n          'item/pump/big_pump': [1, 1, 2],\n          'item/compressor': [1, 2],\n          'activity': [2]\n        }\n    */\n    function traverseChild(child, index, hotkeyMap, hotkeys, terminalHotkeys, firstPass) {\n      if(!firstPass) {\n        hotkeyMap[child.full_name] = hotkeys;\n      }\n      if(child.children) {\n        for(var i = 0; i < Math.min(9, child.children.length); i++) { // Don't go past index 9 so that the hotkeys make sense\n          traverseChild(child.children[i], i + 1, hotkeyMap, Array.prototype.concat(hotkeys, i + 1), terminalHotkeys);\n        }\n      } else {\n        terminalHotkeys.add(hotkeys.join(''));\n      }\n      return {hotkeyMap: hotkeyMap, terminalHotkeys: terminalHotkeys};          \n    }    \n\n    // Build the reverse of the hotkeyMap, i.e. swap the keys with the values.\n    // This assists with the hotkey bindings function.\n    function buildReverseHotkeyMap(hotkeyMap) {\n      var reverseHotkeyMap = {};\n      for(var key in hotkeyMap){\n        var val = hotkeyMap[key].join('');\n        reverseHotkeyMap[val] = key;\n      }\n      return reverseHotkeyMap;    \n    }\n\n\n    var d = traverseChild({children: orderedItems}, 1, [], [], new Set(), true);\n    var hotkeyMap = d.hotkeyMap;\n    var terminalHotkeys = d.terminalHotkeys;\n    var reverseHotkeyMap = buildReverseHotkeyMap(hotkeyMap);\n\n    // Once the hotkeyMap (and reverseHotkeyMap) has been created, set up the hotkey keybinds and call the callback fn.\n    this.setState({\n      hotkeyMap: hotkeyMap,\n      reverseHotkeyMap: reverseHotkeyMap,\n      terminalHotkeys: terminalHotkeys,\n    }, () => { this.setupHotkeyKeybinds(); if(next) next(); });\n  }\n\n\n  // Sets up an array to store the annotations with the same length as docGroup.\n  // Prepopulate the annotations array with the automaticAnnotations if available (after converting them to BIO).\n  // This could be either the dictionary-based annotations or the annotations that the user has previously entered.\n  initAnnotationsArray(documents, automaticAnnotations) {\n\n    var annotations = new Array(documents.length);\n    for(var doc_idx in documents) {\n      annotations[doc_idx] = new Array(documents[doc_idx].length);\n      for(var token_idx in documents[doc_idx]) {\n        annotations[doc_idx][token_idx] = new Annotation(documents[doc_idx][token_idx], parseInt(token_idx));\n      }\n    }\n\n    if(!automaticAnnotations) return annotations;\n\n    // Load annotations from the automaticAnnotations array if present.\n    for(var doc_idx in automaticAnnotations) {\n      for(var mention_idx in automaticAnnotations[doc_idx]['mentions']) {\n\n        var mention = automaticAnnotations[doc_idx]['mentions'][mention_idx];\n        var start = mention['start'];\n        var end = mention['end'];\n\n        for(var label_idx in mention['labels']) {\n          var label = mention['labels'][label_idx];\n\n          for(var k = start; k < end; k++) {\n            var bioTag = k === start ? 'B' : \"I\";\n            annotations[doc_idx][k].addLabel(bioTag, label, documents[doc_idx].slice(start, end).join(' '), start, end - 1)\n          }\n        }\n      }        \n    }\n    return annotations;\n  }\n\n  // Initialise the confidences array.\n  initConfidencesArray(documents) {\n    var confidences = new Array(documents.length);\n    return confidences;\n  }\n\n  // Initialise the entity colour map, which maps entity_class: colour_index, e.g. \"Item\": 1. Passed to the Word components to colour\n  // their labels accordingly.\n  initEntityColourMap(categoryHierarchy) {\n    var entityColourMap = {}\n    for(var ec_idx in categoryHierarchy) {\n      var entityClass = categoryHierarchy[ec_idx];\n      entityColourMap[entityClass.name] = entityClass.colorId + 1;\n    }\n    return entityColourMap;\n  }\n\n\n  /* Miscellaneous */\n\n  // Justify the words to the nearest 25px (i.e. round their width up to the nearest 25px).\n  // Not really necessary but makes the diagonal stripey lines line up properly when multiple tokens are selected.\n  // I spent about 2 hours trying to figure out how to get the stripey lines to line up properly, this is the result :D\n  justifyWords() {\n    $('.word-inner').each((i, ele) => {\n      var width = ele.offsetWidth;\n      var newWidth = Math.ceil(width / 25) * 25;\n      $(ele).css('min-width', newWidth + 'px');\n    });\n  }\n\n  // Remove min-width from words that do not have a tag\n  // (necessary to call between pages)\n  clearWordJustification() {\n    $('.word:not(.tag) .word-inner').each((i, ele) => {\n       $(ele).css('min-width', 'auto');\n    })\n  }\n\n  // Load the next page by calling the API.\n  // Query without a page number (i.e. request the latest group)\n  // if the user is looking at the group before the latest group.\n  //\n  // TODO: Make it so that when the user has made a change to the group they're looking at,\n  // pop up a confirmation window to confirm their changes before loading the next page?\n  loadNextPage() {\n    var nextPageNumber = this.state.pageNumber + 1;\n    if(nextPageNumber === (this.state.totalPagesAvailable)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, nextPageNumber);\n    }\n  }\n\n  goToPage(pageNumber) {\n    if(pageNumber === (this.state.totalPagesAvailable)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, pageNumber);\n    }\n  }\n\n  // Load the previous page by calling the API.\n  loadPreviousPage() {\n    this.queryAPI(false, this.state.pageNumber - 1);\n  }\n\n  /* API calls */\n\n  queryAPI(firstLoad, pageNumber) {\n    const fetchConfig = {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }\n    };\n    var route = 'getDocumentGroup';\n\n    // If this function was called with a pageNumber, load a specific documentGroupAnnotation.\n    if(pageNumber) {\n      route = 'getPreviouslyAnnotatedDocumentGroup?pageNumber=' + pageNumber;\n    }\n\n    this.setState({\n      loading: {\n        querying: true,\n        saving: false,\n        firstLoad: firstLoad,\n      }\n    }, function() {\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/' + route, fetchConfig) // TODO: move localhost out\n        .then(response => response.text())\n        .then((data) => {\n          try { \n            var d = JSON.parse(data);\n          } catch(err) {\n            alert(err);\n            return;\n          }\n\n\n          if(d.tagging_complete) {\n            console.log(d);\n            this.setState({\n              taggingCompletePage: true,\n              totalPagesAvailable: d.annotatedDocGroups + 1,\n              pageNumber: d.annotatedDocGroups + 1,\n              changesMade: false,\n              recentlySaved: false,\n\n              loading: {\n                querying: false,\n                saving: false,\n              },\n              data: {\n                username: d.username,\n                projectName: d.projectName,\n                documentGroup: [],\n                categoryHierarchy: {'children': []},\n                pageNumber: -1,\n                annotatedDocGroups: -1,\n              },\n            })\n            return;\n          } \n\n          \n          this.setState(\n            {\n              data: d,\n              entityColourMap: this.initEntityColourMap(d.categoryHierarchy.children),\n              confidences: this.initConfidencesArray(d.documentGroup),\n              annotations: this.initAnnotationsArray(d.documentGroup, d.automaticAnnotations),\n              selections: this.getEmptySelectionsArray(d.documentGroup.length),\n              mostRecentSelectionText: null,\n              pageNumber: d.pageNumber,\n              totalPagesAvailable: d.annotatedDocGroups + 1,\n              docGroupLastModified: d.lastModified,\n              documentGroupAnnotationId: d.documentGroupAnnotationId, // Will be null if this doc group has not yet been annotated\n              changesMade: false,\n              recentlySaved: false,\n              loading: {\n                querying: false,\n                saving: false\n              },     \n              taggingCompletePage: false,         \n            }, () => { \n              console.log(\"Data:\", this.state.data);\n\n              // Initialise keybinds and mouse events only on the first API call.\n              if(firstLoad) {\n                this.initKeybinds();              \n                this.initHotkeyMap(this.state.data.categoryHierarchy.children);   \n              }\n\n              this.initMouseEvents();\n              this.clearWordJustification();    \n              this.justifyWords();    \n              this.selectFirstWord();\n\n              window.scrollTo(0, 0);\n            })\n        });\n        \n\n    }.bind(this));\n  }\n\n  // Convert the annotations array into JSON.\n  annotationsToJSON() {\n    var annotations = this.state.annotations;\n    var annotationsJSON = [];\n    for(var doc_idx in annotations) {\n        \n      var docLabels = [];\n      for(var token_idx in annotations[doc_idx]) {\n        var ann = annotations[doc_idx][token_idx];\n        if(ann.entityClasses) {\n          docLabels.push([ann.bioTag + \"-\", ann.entityClasses]);\n        } else {\n          docLabels.push([\"\"])\n        }\n      }\n      annotationsJSON.push(docLabels);\n    }\n    return annotationsJSON;\n  }\n\n\n  // Submit the annotations of the document group that the user is currently looking at.\n  // TODO: Maybe make it so that you can't save the annoations until the user has put all their confidences in?\n  // Or perhaps do a check and pop a confirmation window up if they click save without doing anything to >= 1 document\n  submitAnnotations() {\n    if(this.state.recentlySaved) { return; } // If the user clicks on the green save button, provide them with the illusion that it is doing\n                                             // something when in fact nothing actually happens. Prevents people from spam clicking the save and\n                                             // calling the API 5000 times...\n                                             // It's kind of like how google sheets allows you to press Ctrl + S despite it saving every action\n                                             // automatically.\n\n    const csrfToken = getCookie('csrf-token');\n\n    var annotationsJSON = this.annotationsToJSON();\n\n    const fetchConfig = {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'csrf-token': csrfToken,\n      },\n      dataType: \"json\",\n      body: JSON.stringify({\n        documentGroupId: this.state.data.documentGroupId,\n        documentGroupAnnotationId: this.state.documentGroupAnnotationId,\n        labels: annotationsJSON\n      }),  \n    };\n\n    this.setState({\n      loading: {\n        querying: false,\n        saving: true,\n      }\n    }, () => {\n\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/submitAnnotations', fetchConfig) // TODO: move localhost out\n      .then(response => response.text())\n      .then((data) => {\n        try { \n          var d = JSON.parse(data);\n\n          console.log(d);\n\n          var documentGroupAnnotationId = d.documentGroupAnnotationId;\n          console.log(\"Submitted annotations OK\");\n\n          // If the user is on the last page (i.e. the 'current group'), add one to the totalPages array so that the user can\n          // click 'Next' to go to the latest doc group.\n          if(this.state.pageNumber === this.state.totalPagesAvailable) {\n            var newTotalPagesAvailable = this.state.totalPagesAvailable + 1;\n            this.setState({\n              showingProgressBar: true,\n            }, () => {\n              window.setTimeout(() => this.setState({\n                showingProgressBar: false,\n              }), 3000);\n            })\n\n          } else {\n            var newTotalPagesAvailable = this.state.totalPagesAvailable;\n          }\n\n          this.setState({\n             docGroupLastModified: Date.now(),\n             totalPagesAvailable: newTotalPagesAvailable,\n             changesMade: false,\n             recentlySaved: true,\n             documentGroupAnnotationId: documentGroupAnnotationId,\n             loading: {\n              querying: false,\n              saving: false\n             }\n          });\n        } catch(err) {\n          console.log(\"ERROR:\", err);\n          alert(data);\n        }\n        \n        //this.queryAPI(this.state.data.pageNumber + 1);\n      });\n    });\n  }\n\n  /* Mounting function */\n\n  // When this component is mounted, call the API.\n  // Set up the keybinds and mouseup event when done.\n  componentWillMount() {\n\n    var pathname = window.location.pathname;\n    var project_id = pathname.split('/')[2];\n    if(pathname === \"/\") {\n      //var project_id = 'RtJp98vxk'; // React development (completed project)\n      //var project_id = 'KPJqR4HB8'; // React development (long docs)\n      var project_id = '-krXeW3R2'; // React development (big work order one)\n    }\n    if(!project_id || project_id.length < 8) {\n      alert(\"invalid project\");\n      return;\n    }\n\n\n\n    this.setState({\n      project_id: project_id\n    }, () => { this.queryAPI(true) });\n  }  \n\n  /* Selection functions */\n\n  // Get an empty current selection.\n  // Called when we need to clear the current selection.\n  getEmptyCurrentSelection() {\n    return {\n      wordStartIndex: -1,\n      wordEndIndex: -1,\n      sentenceIndex: -1\n    }\n  }\n\n  // Move the selection up or down.\n  // This function should be called when one of those keys is pressed.\n  moveSelectionVertically(direction) {\n    console.log(\"Moving\", direction) // TODO: Make this move up and down\n  }\n\n  // Move the selection in the specified direction ('left', 'right').\n  // This function should be called when one of those keys is pressed.\n  moveSelectionHorizontally(direction) {\n    console.log(\"Moving\", direction)\n\n    var selections = this.state.selections;\n    var mostRecentSelectionText;\n\n    // Move all selections left or right\n    for(var i = 0; i < selections.length; i++) {\n      for(var j = 0; j < selections[i].length; j++) {\n        var selection = selections[i][j];\n\n        // Behaviour depends on whether shift is currently being held down.\n        if(direction === \"left\") {\n          if(!this.state.holdingShift) {\n            selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            selection.wordEndIndex = selection.wordStartIndex;\n          } else { // If shift is being held down, move the wordEndIndex backwards or move the wordStartIndex backwards depending on the current selection.\n            if(selection.wordEndIndex > selection.wordStartIndex) {\n              selection.wordEndIndex--;\n            } else {\n              selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            }\n          }\n        } else if (direction === \"right\") {\n          if(!this.state.holdingShift) { // If shift *is* being held down, this won't happen (the wordStartIndex won't change).\n            selection.wordStartIndex = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n          }\n          selection.wordEndIndex   = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n        }\n\n        mostRecentSelectionText = this.state.data.documentGroup[i].slice(selection.wordStartIndex, selection.wordEndIndex + 1).join(' ');\n      }\n    }\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText\n    });\n  }\n\n  // Get an empty selections array whose length is the number of docs in the current documentGroup.\n  getEmptySelectionsArray(numDocs) {\n    if(!numDocs) {\n      var numDocs = this.state.data.documentGroup.length;\n    }\n    var selections = new Array(numDocs);\n    for(var i = 0; i < selections.length; i++) {\n      selections[i] = new Array();\n    }    \n    return selections;\n  }  \n\n  // Select the first word in the first sentence.\n  // (called when a new group is loaded).\n  selectFirstWord() {\n    var selections = this.state.selections;\n    selections[0].push({\n      wordStartIndex: 0,\n      wordEndIndex: 0\n    });\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: this.state.data.documentGroup[0][0],\n    });\n  }\n\n  // Clear all active selections by resetting the selections array.\n  clearSelections() {\n    this.setState( {\n      currentSelection: this.getEmptyCurrentSelection(),\n      selections: this.getEmptySelectionsArray()\n    });\n  }\n\n  // Update this component's selections state.\n  // This function is called via the mouse, and has no relation to the keyboard (keyboard selections are handled above).\n  // sentenceIndex: The index of the sentence in which the selection was made.\n  // wordIndex: the index of the word that was clicked on, or hovered over and the mouse released.\n  // action: Whether the mouse was pressed down ('down') or released ('up').\n  updateSelections(sentenceIndex, wordIndex, action) {\n    var wordStartIndex, wordEndIndex;\n\n    var selections = this.state.selections;\n    var currentSelection = this.state.currentSelection;\n\n    if (action === \"down\") { // Mouse down, i.e. a word was clicked.\n\n      if(!this.state.holdingCtrl) {\n        selections = this.getEmptySelectionsArray(); // Reset all selections upon clicking a word, unless Ctrl is being held.\n      }\n      wordStartIndex = wordIndex;\n      wordEndIndex = -1;\n\n      // A new selection is made, capturing the index of the sentence that the user clicked on and the index of the word that they clicked.\n      currentSelection = {\n        sentenceIndex: sentenceIndex,\n        wordStartIndex: wordStartIndex\n      }      \n\n    } else if(action === \"up\") { // Mouse up, i.e. mouse was released when hovering over a word.\n\n      // Only allow selections where the user has clicked on a starting word.\n      if(currentSelection.wordStartIndex === -1) {\n        this.clearSelections();\n        return;\n      }\n\n      wordStartIndex = currentSelection.wordStartIndex;\n\n      // If the first word selected was in a different sentence, the wordStartIndex becomes the start of the sentence where the mouse was released.\n      if(currentSelection.sentenceIndex !== sentenceIndex) {  // TODO: Make this consider mouseX relative to the X of the initial token?\n        wordStartIndex = 0;\n      };\n\n      wordEndIndex = wordIndex;\n\n      // If the second word selected was before the first, swapperino them around (so that backwards selections work as expected).\n      if(wordIndex < wordStartIndex) {\n        var s = wordStartIndex;\n        wordStartIndex = wordIndex;\n        wordEndIndex = s;\n      }     \n\n      // Create a new selections json object and push it to the selections array for this sentence.\n      currentSelection = this.getEmptyCurrentSelection();\n      selections[sentenceIndex].push({\n        wordStartIndex: wordStartIndex,\n        wordEndIndex: wordEndIndex\n      });\n      var mostRecentSelectionText = this.state.data.documentGroup[sentenceIndex].slice(wordStartIndex, wordEndIndex + 1).join(' ');\n\n      clearWindowSelection(); // Remove the default browser selection highlighty thing.\n    }    \n\n    this.setState({\n      currentSelection: currentSelection,\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText ? mostRecentSelectionText : this.state.mostRecentSelectionText,\n    });\n  }\n\n\n\n\n  /* Tag application function */\n\n  // Apply a specific tag to all current selections.\n  // entityClass: The full name of the entity class, e.g. 'item/pump/centrifugal_pump'.\n  // This function will either be called via clicking on an entity class in the tree, or by using hotkeys.\n  applyTag(entityClass) {    \n    //console.log(\"Applying tag:\", entityClass);\n    var selections = this.state.selections;\n    var documents = this.state.data.documentGroup;\n    var annotations = this.state.annotations;\n\n    for(var doc_idx in selections) {\n      for(var sel_idx in selections[doc_idx]) {\n        var sel = selections[doc_idx][sel_idx];\n        var start = sel.wordStartIndex;\n        var end = sel.wordEndIndex;\n\n\n        /* 1. Disjoint spans */\n        // Check all labels across this selected span of tokens are the same before proceeding.\n        // If they are not, they must be cleared before adding a label.\n        var annotationSpanStart = annotations[doc_idx][start].spanStartIdx;\n        var annotationSpanEnd   = annotations[doc_idx][start].spanEndIdx;\n        var notAllEqual = false;          \n        for(var k = start + 1; k <= end; k++) {\n          var otherAnnotation = annotations[doc_idx][k]; \n          if(annotationSpanStart !== otherAnnotation.spanStartIdx || annotationSpanEnd !== otherAnnotation.spanEndIdx) {\n            notAllEqual = true;\n            break;\n          }          \n        }        \n\n        // If the labels across all tokens in the selected span are not the same, remove all labels for the entire span.\n        // Then modify the spanEndIdx of any annotations in this document whose spanEndIdx was overlapping the\n        // span that the user selected, setting them to be start index - 1 (before the span).\n        // This ensures the ends of the spans are drawn properly.\n        if(notAllEqual) {\n          for(var k = start; k <= end; k++) {\n            var annotation = annotations[doc_idx][k];\n            annotation.removeAllLabels();\n          }          \n          // Adjust the span end index of all prev labels to be start index - 1\n          // A shame that we have to iterate across all annotations in this document - this could probably be optimised\n          // but it probably barely impacts performance even on large docs (I think)\n          for(var x in annotations[doc_idx]) {\n            var annotation = annotations[doc_idx][x];\n\n\n            // If this new span overlaps the *end* of an existing span, change that span's end index to the start of this new\n            // span, -1\n\n            if(annotation.spanEndIdx >= start && annotation.spanStartIdx <= start) {              \n              annotation.setSpanEndIdx(start - 1);\n\n            }\n\n            // If this new span overlaps the *start* of an existing span, change that span's start index to be the end of this new span -1\n            // and change the BIO tag to \"B\".\n            if(annotation.spanStartIdx <= end) {\n              annotation.setSpanStartIdx(end + 1);              \n              if(annotation.tokenIndex === (end + 1)) {\n                annotation.changeBioTag(\"B\") // I am realising now that this BIO tag is unnecessary - it could be inferred\n              }\n            }\n          }\n        }\n\n        /* 2. Overlapping spans */\n        // Check for any spans that this new span will cut into.\n        // First, check to the left and adjust the spanEndIdx of all Annotation objects\n        // to the left of this span if they overlap.\n        for(var ann_idx in annotations[doc_idx].slice(0, start)) {\n          var annotation = annotations[doc_idx][ann_idx];          \n          if(annotation.spanStartIdx < start && annotation.spanEndIdx >= end) {            \n            annotation.setSpanEndIdx(start - 1);\n          }\n        }\n\n        // Do the same for any Annotation objects on the right hand side of this span, which are part of the same\n        // mention.\n        for(var ann_idx in annotations[doc_idx].slice(end + 1, annotations[doc_idx].length)) {\n          var annotation = annotations[doc_idx][parseInt(ann_idx) + end + 1];\n          if(annotation.spanStartIdx <= start && annotation.spanEndIdx >= end) {\n            annotation.setSpanStartIdx(end + 1);\n            if(ann_idx === '0') {\n              annotation.changeBioTag(\"B\");\n            }\n          }\n        }\n\n        /* 3. Applying the labels */\n        // Now, apply the tags to every token in the selected span.\n        var labelWasModified = false;\n        for(var k = start; k <= end; k++) {\n          var bioTag = k === start ? \"B\" : \"I\";\n          var spanText = documents[doc_idx].slice(start, end + 1).join(' ');\n\n          //var prevAnnotation = k > 0 ? annotations[doc_idx][k - 1] : null;\n          //var nextAnnotation = k < (documents[doc_idx].length - 1) ? annotations[doc_idx][k + 1] : null;          \n\n          labelWasModified = annotations[doc_idx][k].addLabel(bioTag, entityClass, spanText, start, end);\n\n        }\n\n        if(labelWasModified) this.captureEvent('Applied label', parseInt(doc_idx), start, end, entityClass);\n      }\n    }\n    this.setState({\n      annotations: annotations,\n    }, () => {\n      this.justifyWords(); // Justify the words again to ensure the stripey lines line up correctly\n\n      // Debug:\n      //prettyPrintAnnotations(this.state.annotations[0]);\n      //console.log(\"Updated annotations[0]:\", this.state.annotations[0]);\n    })\n\n  }\n\n  // Deletes the specified tag.\n  // Unlike applyTag, this is applied to a specified sentenceIndex and wordIndex rather than to all current selections.\n  deleteTag(sentenceIndex, wordIndex, entityClass) {\n    \n    var annotations = this.state.annotations;\n    var annotation = annotations[sentenceIndex][wordIndex];\n\n    // Retrieve the span start idx and span end idx of the annotation corresponding to (sentence_index, word_index)\n    var spanStart = annotation.spanStartIdx;\n    var spanEnd = annotation.spanEndIdx;\n\n    this.captureEvent('Deleted label', sentenceIndex, spanStart, spanEnd, entityClass);\n\n    // Find all annotations in this document in the same mention span and remove the label from all of them.\n    // (this will also remove the label from the annotation object at (sentence_index, word_index)).\n    for(var ann_idx in annotations[sentenceIndex]) {\n      var otherAnnotation = annotations[sentenceIndex][ann_idx];       \n      if(otherAnnotation.spanStartIdx === spanStart && otherAnnotation.spanEndIdx === spanEnd) {\n        otherAnnotation.removeLabel(entityClass);\n      }\n    }\n\n    this.setState({\n      annotations: annotations\n    });\n\n  }\n\n  /* Confidence */\n\n  // Updates the confidences array for the given doc.\n  // If the user clicks on the button they already clicked, then the confidence is reset to undefined.\n  updateConfidence(sentenceIndex, confidence) {\n    var confidences = this.state.confidences;\n    if(confidences[sentenceIndex] === confidence) {\n      confidences[sentenceIndex] = undefined;\n    } else {\n      confidences[sentenceIndex] = confidence;\n    }\n    this.setState({\n      confidences: confidences\n    });\n  }\n\n  /* Events */\n\n  // Capture an event\n  // TODO: Make it do something\n  captureEvent(eventAction, sentenceIndex, spanStart, spanEnd, entityClass) {\n\n    var tokenString = this.state.data.documentGroup[sentenceIndex].slice(spanStart, spanEnd + 1).join(' ')\n\n    var event = {\n      \"action\": eventAction,\n      \"sentenceIndex\": sentenceIndex,\n      \"wordIndex\": {\n        \"start\": spanStart,\n        \"end\": spanEnd,\n      },\n      \"entityClass\": entityClass,\n      \"tokenString\": tokenString\n    }\n\n    if(eventAction === \"Applied label\" || eventAction === \"Deleted label\") {\n      this.setState({\n        changesMade: true,\n        recentlySaved: false,\n      })\n    }\n\n  }\n\n  /* Rendering function */\n\n\n  render() {\n\n\n    var taggingCompletePage = this.state.taggingCompletePage;\n\n    return (\n        <div>\n          <Navbar pageTitle={\"Annotating project: \" + this.state.data.projectName} username={this.state.data.username} />  \n          <div id=\"tagging-interface\" className={(this.state.loading.querying ? \"loading\" : \"\") + (taggingCompletePage ? \" tagging-complete-page\" : \"\")}>\n\n            <div id=\"tagging-container\">\n              { taggingCompletePage && <TaggingCompletePage/>}\n              <div id=\"sentence-tagging\">\n\n                { this.state.loading.firstLoad && \n                  <div className=\"loading-message\">\n                    <i className=\"fa fa-cog fa-spin\"></i>Loading...\n                  </div>\n                }\n\n                <ControlBar\n                  showingProgressBar = {this.state.showingProgressBar}\n                  pageNumber = {this.state.pageNumber}\n                  totalPages = {this.state.data.docGroupsPerUser}\n                  totalPagesAvailable = {this.state.totalPagesAvailable}\n                  lastModified={this.state.docGroupLastModified}\n                  recentlySaved={this.state.recentlySaved}\n                  changesMade={this.state.changesMade}\n                  querying={this.state.loading.querying}\n                  saving={this.state.loading.saving}\n\n                  submitAnnotations={this.submitAnnotations.bind(this)}\n                  loadPreviousPage={this.loadPreviousPage.bind(this)}\n                  loadNextPage={this.loadNextPage.bind(this)}\n                  goToPage={this.goToPage.bind(this)}\n                />\n\n                <DocumentContainerHeader/>\n                    \n                { this.state.data.documentGroup.map((doc, i) => \n                  <DocumentContainer\n                    key={i}\n                    index={ i }\n                    displayIndex={( (this.state.pageNumber - 1) * 10 ) + i + 1  }\n                    words={doc}              \n                    annotations={this.state.annotations[i]}  \n                    confidence={this.state.confidences[i]}\n                    selections={this.state.selections[i]}\n                    updateSelections={this.updateSelections.bind(this)}\n                    updateConfidence={this.updateConfidence.bind(this)}\n                    entityColourMap={this.state.entityColourMap}\n                    deleteTag={this.deleteTag.bind(this)}\n                  />\n                  )}\n\n              </div>\n            </div>\n            <div id=\"tagging-menu\">\n              <WikipediaSummary tokens={this.state.mostRecentSelectionText}/>\n              <HotkeyInfo \n                chain={this.state.hotkeyChain}\n                entityClass={this.state.reverseHotkeyMap[this.state.hotkeyChain.join('')]}\n              />            \n              \n              <CategoryHierarchy\n                items={this.state.data.categoryHierarchy.children}\n                hotkeyMap={this.state.hotkeyMap}\n                hotkeyChain={this.state.hotkeyChain.join('')}\n                initHotkeyMap={this.initHotkeyMap.bind(this)}\n                applyTag={this.applyTag.bind(this)}              \n              />\n            </div>      \n          </div>\n        </div>\n       \n    )\n  }\n}\n\n// The humble save button that appears at the top of the page.\nclass SaveButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n\n    var buttonClass = \" disabled\";\n    if(this.props.changesMade) buttonClass = \"\";\n    if(this.props.recentlySaved) buttonClass = \" recently-saved\";\n    if(this.props.saving) buttonClass = \" saving\";\n\n    var iconClass = \"fa-save\";\n    if(this.props.recentlySaved) iconClass = \"fa-check\";\n    if(this.props.saving) iconClass = \"fa-cog fa-spin\"\n\n    var text = \"Save\";\n    if(this.props.recentlySaved) text = \"Saved\";\n    if(this.props.saving) text = \"Saving\";\n\n    return (\n      <button className={\"save-button\" + buttonClass} onClick={this.props.submitAnnotations}>\n        <i className={\"fa \" + iconClass}></i>\n        { text }\n      </button>\n    )\n  }\n}\n\n\n// The progress bar that appears when the user saves a new doc group.\nclass ProgressBar extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-progress-bar\" className={(this.props.show ? \"show\" : \"hide\")}>\n        <span className=\"progress-bar\">\n          <span className=\"inner\" style={{\"width\": (this.props.totalPagesAvailable - 1) / this.props.totalPages * 100 + \"%\"}}></span>\n        </span>\n      </div>\n    )\n  }\n}\n\n// The 'control bar', which appears at the top of the interface (with page numbers, group number etc).\nclass ControlBar extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state =  {\n      pageNumber: null, // The desired page number of the user (not necessarily the one they are currently on).\n      pageNumberError: false,\n    }\n    this.pageInputRef = React.createRef();\n  }\n\n  // clearPageNumberError() {\n  //   this.setState({\n  //     pageNumber: this.props.pageNumber,\n  //     pageNumberError: false,\n  //   })\n  // }\n\n  clearPageNumberInput() {\n    var ele = $(this.pageInputRef.current);\n    ele.val('');\n    ele.blur();\n  }\n\n  goToPage(e) {\n\n    this.clearPageNumberInput();\n    if(this.state.pageNumber === '') {\n      this.setState({ pageNumber: this.props.pageNumber })\n      e.preventDefault();\n      return null;\n    }\n\n    if(this.state.pageNumber < 1) {\n      this.setState({\n        pageNumber: 1,\n      }, () => { this.props.goToPage(this.state.pageNumber)});\n    } else if (this.state.pageNumber > this.props.totalPagesAvailable) {\n      this.setState({\n        pageNumber: this.props.totalPagesAvailable,\n      }, () => { this.props.goToPage(this.state.pageNumber)});\n    } else {\n      this.props.goToPage(this.state.pageNumber);\n    }\n \n\n    e.preventDefault();\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if(this.props.pageNumber !== prevProps.pageNumber) {\n      this.setState({\n        pageNumber: this.props.pageNumber\n      })\n    }\n  }\n\n\n  changePageNumber(e) {\n    this.setState({\n      pageNumber: e.target.value,\n    });\n  }\n\n  render() {\n\n    var groupName = (\n      <span className={\"group-name\" + (this.props.showingProgressBar ? \" progress-bar-underneath\" : \"\")}>\n        <span>Group <b>\n          <form onSubmit={this.goToPage.bind(this)}>\n          <input \n                 id=\"page-input\"\n                 className={\"page-input\" + (this.state.pageNumberError ? \" error\" : \"\")}\n                 placeholder={this.state.pageNumber}\n                 name=\"page-input\"\n                 onChange={(e) => this.changePageNumber(e)}\n                 ref={this.pageInputRef}\n                 />\n          </form>\n          \n        </b> of <b>{this.props.totalPages}</b></span>\n      </span>\n    );\n\n    var latestGroup = (this.props.totalPagesAvailable) === this.props.pageNumber // Whether the user is looking at the latest group, that they have not yet annotated\n\n    var lastModified = this.props.changesMade ? (this.props.saving ? \"\" : \"Changes not saved\") : (this.props.lastModified ? \"Saved on \" + dateFormat(this.props.lastModified, 'dd mmm') + ' at ' + dateFormat(this.props.lastModified, 'h:MM tt') : \"\");\n\n    return (\n      <div id=\"pagination\">\n        <div className=\"page-button-container previous-page\">\n          <button className={(this.props.pageNumber === 1 ? \" disabled\" : \"\")} onClick={this.props.loadPreviousPage}><i className=\"fa fa-chevron-left\"></i>Prev\n          </button>\n        </div>\n        <div className=\"filler-left\"></div>\n        <div className=\"current-page-container\">\n          { groupName }\n          <ProgressBar \n            show={this.props.showingProgressBar}\n            totalPagesAvailable={this.props.totalPagesAvailable}\n            totalPages={this.props.totalPages}\n          />\n        </div>\n        <div className=\"group-last-modified\">{lastModified }</div>\n        <div className=\"page-button-container \"><SaveButton changesMade={this.props.changesMade} recentlySaved={this.props.recentlySaved} saving={this.props.saving} submitAnnotations={this.props.submitAnnotations}  /></div>\n        <div className=\"page-button-container next-page\">\n          <button className={(latestGroup ? \" disabled\" : \"\")}  onClick={this.props.loadNextPage}>Next<i className=\"fa fa-chevron-right\"></i></button>\n        </div>              \n      </div>\n    )\n  }\n}\n\nclass TaggingCompletePage extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-complete-message\">\n        <span class=\"tagging-complete-text\">\n          <h2>Annotation complete!</h2>\n          <p>Thank you for your participation in this project.</p>\n\n        </span>\n\n\n      </div>\n    )\n\n  }\n}\n\nclass TestComponent extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div>Hello I'm a test one</div>\n    )\n  }\n}\n\nclass Homepage extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <Navbar pageTitle={this.props.title} username={this.props.username} />  \n        <p>Hello I am a homepage</p>\n        <p><Link to=\"/projects/-krXeW3R2/tagging\">open project</Link></p>\n\n\n      </div>\n\n    )\n  }\n}\n\n\n// The app, which renders the navbar and the tagging interface inside a container.\nfunction App() {\n\n\n\n\n\n\n  return (    \n\n    <div id=\"app\"> \n      <BrowserRouter>\n        <Switch>\n          <Route path=\"/projects\" component={TaggingInterface} />\n          <Route path=\"/test\" component={TestComponent} />\n          <Route exact path=\"/\" render={() =>  <Homepage username=\"who knows\" title=\"Homepage\"/>} />\n        </Switch>\n      </BrowserRouter>\n    </div>\n\n    \n  );\n}\n\n\n\nexport default App;\n\n// Old code\n/* \n<div className=\"submit-annotations-container\">\n  <button className=\"submit-annotations-button\" onClick={this.submitAnnotations.bind(this)}>Submit annotations <i className=\"fa fa-chevron-right\"></i></button>\n</div>\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}