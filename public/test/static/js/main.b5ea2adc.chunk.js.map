{"version":3,"sources":["favicon.png","redcoat-1-threshold.png","App.js","serviceWorker.js","index.js"],"names":["module","exports","dateFormat","require","clearWindowSelection","window","getSelection","empty","removeAllRanges","document","selection","Navbar","id","className","href","src","logo","this","props","pageTitle","username","Component","Category","item","index","children","childItems","open","map","key","openedItems","has","full_name","onClick","hotkeyMap","hotkeyChain","isTopLevelCategory","applyTag","hasHotkey","hasOwnProperty","hotkeyStr","join","content","data-hotkey-id","name","toString","draggableId","provided","snapshot","ref","innerRef","draggableProps","isDragging","colorId","dragHandleProps","CategoryHierarchy","state","itemOrder","orderedItems","Set","onDragEnd","bind","prevProps","prevState","t","Array","items","length","i","setupItemOrder","_","isEqual","setState","delete","add","result","destination","list","startIndex","endIndex","from","splice","removed","reorder","source","order","getOrderedItems","initHotkeyMap","droppableId","droppableProps","isDraggingOver","toggleCategory","placeholder","getColourIdx","entityClass","entityColourMap","split","slice","Label","truncatedLabel","colourIdx","e","deleteTag","Word","selected","wordInnerRef","React","createRef","entityClasses","ele","current","$","css","width","offsetWidth","newWidth","Math","ceil","hasLabel","tagClass","bioTag","isLastInSpan","labels","wordColourClass","onMouseUp","updateSelections","onMouseDown","text","ConfidenceButton","docIdx","value","checked","updateConfidence","title","ConfidenceButtons","confidence","DocumentContainerHeader","DocumentContainer","displayIndex","words","annotations","selections","Sentence","wordIndex","action","node","domtoimage","toBlob","filter","classList","contains","bgcolor","then","blob","saveAs","isWordSelected","wordEndIndex","wordStartIndex","word","saveToPng","nextNode","hasChildNodes","firstChild","nextSibling","parentNode","HotkeyInfo","ec","undefined","chain","Annotation","token","tokenIndex","spanText","spanStartIdx","spanEndIdx","alreadyHasLabel","indexOf","push","otherAnnotation","console","log","WikipediaSummary","visible","querying","wikipediaSummary","wikipediaReadMoreUrl","tokens","next","snippet","wurl","wikipediaTitle","toLowerCase","ajax","url","data","srsearch","format","dataType","success","query","search","replace","err","getResult","queryWikipedia","summary","style","target","toggleVisibility","TaggingInterface","project_id","documentGroup","categoryHierarchy","pageNumber","annotatedDocGroups","documentGroupAnnotationId","confidences","getEmptySelectionsArray","currentSelection","getEmptyCurrentSelection","mostRecentSelectionText","reverseHotkeyMap","terminalHotkeys","hotkeyBindingFn","hotkeyTimeoutFn","holdingCtrl","holdingShift","docGroupLastModified","totalPagesAvailable","changesMade","recentlySaved","selectionChangeFn","windowMouseUpFn","loading","saving","firstLoad","showingProgressBar","taggingCompletePage","sel","rangeCount","r","range","startContainer","endNode","endContainer","rangeNodes","commonAncestorContainer","unshift","getRangeSelectedNodes","getRangeAt","removeClass","find","addClass","sentenceIndex","removeEventListener","selectionChange","windowMouseUp","addEventListener","preventDefault","moveSelectionHorizontally","moveSelectionVertically","hotkeyChainStr","clearTimeout","keyCode","is","prototype","concat","hotkeyTimeout","setTimeout","bindHotkeys","d","traverseChild","child","hotkeys","firstPass","min","buildReverseHotkeyMap","setupHotkeyKeybinds","documents","automaticAnnotations","doc_idx","token_idx","parseInt","mention_idx","mention","start","end","label_idx","label","k","addLabel","ec_idx","each","nextPageNumber","queryAPI","fetchConfig","method","headers","route","fetch","response","JSON","parse","alert","tagging_complete","projectName","initEntityColourMap","initConfidencesArray","initAnnotationsArray","lastModified","initKeybinds","initMouseEvents","clearWordJustification","justifyWords","selectFirstWord","scrollTo","annotationsJSON","docLabels","ann","csrfToken","cookieValue","cookie","cookies","trim","substring","decodeURIComponent","getCookie","annotationsToJSON","body","stringify","documentGroupId","newTotalPagesAvailable","Date","now","pathname","location","direction","j","max","numDocs","clearSelections","s","sel_idx","annotationSpanStart","annotationSpanEnd","notAllEqual","annotation","removeAllLabels","x","setSpanEndIdx","setSpanStartIdx","changeBioTag","ann_idx","labelWasModified","captureEvent","spanStart","spanEnd","removeLabel","eventAction","totalPages","docGroupsPerUser","submitAnnotations","loadPreviousPage","loadNextPage","goToPage","doc","SaveButton","buttonClass","iconClass","ProgressBar","show","ControlBar","pageNumberError","pageInputRef","val","blur","clearPageNumberInput","groupName","onSubmit","onChange","changePageNumber","latestGroup","TaggingCompletePage","class","App","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b5ea2adc.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/redcoat-1-threshold.78b878cf.png\";","import React from 'react';\nimport logo from './favicon.png'\nimport redcoatMan from './redcoat-1-threshold.png';\nimport './stylesheets/stylesheet.scss';\nimport {Component} from 'react';\nimport $ from 'jquery';\nimport { findDOMNode } from 'react-dom';\n\n//const ReactDragListView = require('react-drag-listview');\nimport { DragDropContext, Droppable, Draggable } from \"react-beautiful-dnd\";\nimport styled from 'styled-components';\nimport _ from 'underscore';\n\nimport html2canvas from 'html2canvas';\nimport { saveAs } from 'file-saver';\nimport domtoimage from 'dom-to-image';\nconst dateFormat = require('dateformat');\n\nconst BASE_URL = \"/\"\n\n\n\n// https://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\nfunction clearWindowSelection() {\n  if (window.getSelection) {\n    if (window.getSelection().empty) {  // Chrome\n      window.getSelection().empty();\n    } else if (window.getSelection().removeAllRanges) {  // Firefox\n      window.getSelection().removeAllRanges();\n    }\n  } else if (document.selection) {  // IE?\n    document.selection.empty();\n  }\n}\n\n// Function for getting value from a cookie\nfunction getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\n\n// The navbar, which appears at the top of the page.\nclass Navbar extends Component {\n  render() {\n    return (\n      <nav id=\"navbar\">\n        <div className=\"navbar-left\">\n          <div id=\"logo\">\n            <a href={BASE_URL}>\n              <span className=\"inner\">\n                <span className=\"img\">\n                  <img src={logo}/>\n                </span>\n                <span>Redcoat</span>\n              </span>\n            </a>\n          </div>         \n        </div>\n        <div className=\"navbar-centre\">{this.props.pageTitle}</div>\n        <div className=\"navbar-right\">\n          <div className=\"dropdown-menu\">\n            <button>Projects</button>\n            <ul className=\"dropdown-menu-items\">\n              <li><a href={\"\" + BASE_URL + \"projects\"}>Projects list</a></li>\n              <li><a href={\"\" + BASE_URL + \"setup-project\"}>Setup project</a></li>\n            </ul>\n          </div>\n\n          <div className=\"dropdown-menu\">\n            <button>Logged in as {this.props.username}</button>\n            <ul className=\"dropdown-menu-items\">\n              <li><a href={\"\" + BASE_URL + \"profile\"}>Profile</a></li>\n              <li><a href={\"\" + BASE_URL + \"logout\"}>Logout</a></li>\n            </ul>\n          </div>\n          <div className=\"dropdown-menu short\">\n            <a href={\"\" + BASE_URL + \"features\"}>v1.0</a>\n          </div>\n        </div>\n      </nav>\n    )\n  }\n}\n\n// A single category in the category hierarchy tree.\nclass Category extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    var item = this.props.item;\n    var index = this.props.index;\n    var children = this.props.item.children;\n\n    // If this component has any children, render each of them.\n    if(children) {\n      var childItems = (\n        <ul className={this.props.open ? \"\" : \"hidden\"}>\n          { children.map((item, index) => (\n            <Category key={index}\n                      item={item}\n                      open={this.props.openedItems.has(item.full_name)}\n                      openedItems={this.props.openedItems}\n                      onClick={this.props.onClick}\n                      hotkeyMap={this.props.hotkeyMap}\n                      hotkeyChain={this.props.hotkeyChain}\n                      isTopLevelCategory={false}\n                      applyTag={this.props.applyTag}\n            />)) }\n        </ul>\n      );\n    } else {\n      var childItems = '';\n    }\n\n    // Determine whether this category has a hotkey (by checking hotkeyMap).\n    // Also determine hotkeyStr (for example '12' for 'item/pump').\n    var hasHotkey = this.props.hotkeyMap.hasOwnProperty(this.props.item.full_name)\n    var hotkeyStr = hasHotkey ? this.props.hotkeyMap[this.props.item.full_name].join('') : '';\n\n    var content = (\n      <span className=\"inner-container\">\n        \n         {children && <span className=\"open-button\" onClick={() => this.props.onClick(item.full_name)}><i className={\"fa fa-chevron-\" + (this.props.open ? \"up\" : \"down\")}></i></span>}\n       \n        <span className={\"category-name\" + (hasHotkey ? \" has-hotkey\" :\"\") + (this.props.hotkeyChain === hotkeyStr ? \" hotkey-active\" : \"\")}\n              data-hotkey-id={hotkeyStr} onClick={() => this.props.applyTag(this.props.item.full_name)}>             \n\n          {item.name}\n        </span>\n      </span>      \n    )\n\n\n    // This component will render differently depending on whether it is a top-level category or not.\n    // Top level categories have the drag handle, which requires a different configuration on the wrapper and li.\n    if(this.props.isTopLevelCategory) {\n      return (\n        <Draggable key={item.id.toString()} draggableId={item.id.toString()} index={index}>\n          {(provided, snapshot) => (\n            <li ref={provided.innerRef} {...provided.draggableProps} className={\"draggable \" + (snapshot.isDragging ? \"dragging\": \"not-dragging\") + \" color-\" + (item.colorId + 1)}>\n              <div {...provided.dragHandleProps} className=\"drag-handle-container\"><span className=\"drag-handle\"></span></div>\n              \n              { content }\n              { childItems }\n              \n            </li>\n          )}\n        </Draggable>\n      )\n    } else {\n      return (\n        <li>\n          { content }\n          { childItems }\n        </li>\n      )\n    }\n  }\n}\n\n\n\n// https://codesandbox.io/s/k260nyxq9v?file=/index.js:154-2795\n// a little function to help us with reordering the result\nconst reorder = (list, startIndex, endIndex) => {\n  const result = Array.from(list);\n  const [removed] = result.splice(startIndex, 1);\n  result.splice(endIndex, 0, removed);\n\n  return result;\n};\n\n// Retrieve a list of ordered items based on an order array.\nfunction getOrderedItems(items, order) {\n  var orderedItems = new Array(items.length);\n  for(var i = 0; i < order.length; i++) {\n    orderedItems[i] = items[order[i]];\n  }\n  return orderedItems;\n}\n\n// The category hierarchy (on the left).\nclass CategoryHierarchy extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      itemOrder: [],      // An array that maintains the ordering of the top-level categories.\n                          // e.g. [0, 1, 3, 2]\n      orderedItems: [],\n      openedItems: new Set(),    // An set keep track of the items that have been open (indexed by name).\n    }\n    this.onDragEnd = this.onDragEnd.bind(this);\n  }\n\n  // When this component's items changes (should be when a new docGroup has been requested), setup a new itemOrder state.\n  // (which defaults to ascending order e.g. 0, 1, 2, 3, 4 ...)\n  componentDidUpdate(prevProps, prevState) {\n    var t = this;\n    function setupItemOrder() {\n      var itemOrder = new Array(t.props.items.length);\n      for(var i = 0; i < itemOrder.length; i++) {\n        itemOrder[i] = i;\n      }\n      return itemOrder;\n    }\n    \n    var itemOrder = setupItemOrder();\n    if(!_.isEqual(prevProps.items, this.props.items)) {\n      this.setState({\n        openedItems: new Set(),\n        orderedItems: this.props.items,\n        itemOrder: itemOrder,\n      });\n    }\n  }\n\n  // Open or close a category.\n  // It's pretty awkward that this function is necessary. It would be ideal to store 'open' as a state variable inside the Category and Subcategory\n  // components, but that results in the wrong categories being open when the top-level categories are moved around.\n  // Storing them in the openedItems array in this component's state allows for the opened categories to be maintained when the user\n  // drags a category from one place to another.\n  // full_name should be the full name of the category, e.g. item/pump/centrifugal_pump, which are unique.\n  toggleCategory(full_name) {\n    var openedItems = this.state.openedItems;    \n\n    if(openedItems.has(full_name)) {\n      openedItems.delete(full_name);\n    } else {\n      openedItems.add(full_name);\n    }\n\n    this.setState({\n      openedItems: openedItems\n    })\n  }\n\n  // When the user has finished dragging a category, determine the new item order and save this order to the state.\n  onDragEnd(result) {\n    // dropped outside the list\n    if (!result.destination) {\n      return;\n    }\n\n    const itemOrder = reorder(\n      this.state.itemOrder,\n      result.source.index,\n      result.destination.index\n    );\n\n    var orderedItems = getOrderedItems(this.props.items, itemOrder)\n\n    this.props.initHotkeyMap(orderedItems, () =>\n      this.setState({\n        itemOrder: itemOrder,\n        orderedItems: orderedItems,\n      })\n    );\n  }\n\n  \n  render() {\n\n    var items       = this.state.orderedItems;\n    var openedItems = this.state.openedItems;\n\n    return (\n      <div id=\"category-hierarchy-tree\">\n        <DragDropContext onDragEnd={this.onDragEnd}>\n          <Droppable droppableId=\"droppable\">\n            {(provided, snapshot) => (\n              <ul\n                {...provided.droppableProps}\n                className={\"draggable-list\" + (snapshot.isDraggingOver ? \" dragging\" : \"\")}\n                ref={provided.innerRef}\n\n              >\n                {items.map((item, index) => (\n                  <Category \n                            key={index}\n                            item={item}\n                            index={index}\n                            onClick={this.toggleCategory.bind(this)}\n                            open={openedItems.has(item.name)} \n                            openedItems={this.state.openedItems} \n                            hotkeyMap={this.props.hotkeyMap}\n                            hotkeyChain={this.props.hotkeyChain}\n                            isTopLevelCategory={true}\n                            applyTag={this.props.applyTag}\n                  />\n                ))}\n                {provided.placeholder}\n              </ul>\n            )}\n          </Droppable>\n        </DragDropContext>\n      </div>\n    );\n  }\n}\n\n\n// Returns the colour id of the given entityClass according to the entityColourMap, e.g.\n// 'item/pump': 1 (because \"item\" is the top level category)\nfunction getColourIdx(entityClass, entityColourMap) {\n  var baseClass = entityClass.split(\"/\").slice(0, 1)[0];\n  return entityColourMap[baseClass];\n}\n\n// A label, drawn underneath a word.\nclass Label extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var split = this.props.entityClass.split('/');\n    var truncatedLabel = split.length > 1 ? \"/\" : \"\"\n    truncatedLabel = truncatedLabel + split[split.length - 1];\n\n    return (\n      <span className={\"label tag-\" + this.props.colourIdx} onClick={(e) => {this.props.deleteTag(this.props.entityClass);  }}><span className=\"label-name\">{truncatedLabel}</span></span>\n    )\n  }\n}\n\n// A single word (or token) in the tagging interface.\nclass Word extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: false,\n    }\n    this.wordInnerRef = React.createRef();\n  }\n\n  // Calls this.props.deleteTag with the index of this word as a parameter.\n  deleteTag(entityClass) {\n    this.props.deleteTag(this.props.index, entityClass);\n  }\n\n  // Clear the word justification of this word if it is does not have a label.\n  componentDidUpdate(prevProps, prevState) {\n    if(this.props.entityClasses.length === 0) {\n\n      var ele =  this.wordInnerRef.current;\n      $(ele).css(\"min-width\", \"auto\");\n\n      var width = ele.offsetWidth;\n      var newWidth = Math.ceil(width / 25) * 25;\n      $(ele).css('min-width', newWidth + 'px');        \n\n    }\n  }\n\n  render() {\n\n    var hasLabel = this.props.entityClasses.length > 0;\n\n    var tagClass = hasLabel ? (\" tag \" + ((this.props.bioTag === \"B\") ? \"tag-begin\" : \"\") + (this.props.isLastInSpan ? \" tag-end\" : \"\")) : \"\";\n\n    if(hasLabel) {\n      var labels = this.props.entityClasses.map((entityClass, i) => \n                  <Label deleteTag={this.deleteTag.bind(this)} key={i} bioTag={this.props.bioTag} entityClass={entityClass} colourIdx={getColourIdx(entityClass, this.props.entityColourMap)} />\n                  )\n      \n    } else {\n      var labels = '';\n    }\n\n    var wordColourClass = (hasLabel ? (\" tag-\" + getColourIdx(this.props.entityClasses[0], this.props.entityColourMap)) : \"\")\n\n    return (\n      <span className={\"word\" + (this.props.selected ? \" selected\" : \"\") + tagClass}>\n\n        <span className={\"word-inner\" + wordColourClass} ref={this.wordInnerRef}\n              onMouseUp=  {() => this.props.updateSelections(this.props.index, 'up')}\n              onMouseDown={() => this.props.updateSelections(this.props.index, 'down')}>\n          {this.props.text}\n        </span>\n        {labels}\n        \n      </span>\n    );\n  }\n}\n\n\n// A single confidence button, which may have the value 'low' 'medium' or 'high'.\nclass ConfidenceButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    var docIdx = this.props.docIdx;\n    var value = this.props.value;\n    return (\n      <span className={\"confidence-button conf-\" + value + (this.props.checked ? \" checked\" : \"\")}\n            onClick={() => this.props.updateConfidence(docIdx, value)} title={\"Assign a \" + value + \" confidence to this document.\"} ></span>\n    )\n  }\n}\n\n\nclass ConfidenceButtons extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div className={\"confidence-buttons\"}>\n        <ConfidenceButton value=\"low\"    checked={this.props.confidence === \"low\"} { ...this.props }/>\n        <ConfidenceButton value=\"medium\" checked={this.props.confidence === \"medium\"} { ...this.props }/>\n        <ConfidenceButton value=\"high\"   checked={this.props.confidence === \"high\"} { ...this.props }/>        \n      </div>\n    )\n  }\n}\n\n\n// The document container header, which appears at the top of the sentence tagging page.\nclass DocumentContainerHeader extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div className=\"document-container header\">\n        <div className=\"document header\">\n          <div className=\"sentence-index\"></div>\n          <div className=\"sentence\">Document</div>\n          <div className=\"confidence-buttons\">Confidence</div>\n        </div>\n      </div>\n    )\n  }\n}\n\n// A document container, which contains the sentence index (on the left), the sentence, and the confidence buttons.\nclass DocumentContainer extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    return (\n      <div className={\"document-container\" + (this.props.confidence ? \" conf conf-\" + this.props.confidence : \"\")}>\n        <div className=\"document\">\n          <div className=\"sentence-index\"><span className=\"inner\">{this.props.displayIndex}</span></div>\n          <Sentence \n            index={this.props.index}\n            words={this.props.words}              \n            annotations={this.props.annotations}  \n            selections={this.props.selections}\n            updateSelections={this.props.updateSelections}\n            entityColourMap={this.props.entityColourMap}\n            deleteTag={this.props.deleteTag}\n          />\n          <ConfidenceButtons docIdx={this.props.index} confidence={this.props.confidence} updateConfidence={this.props.updateConfidence}/>\n        </div>\n      </div>\n    )\n  }\n\n}\n\n\n\n// A sentence in the tagging interface.\nclass Sentence extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  // Call the updateSelections function of the parent of this component (i.e. TaggingInterface), with this sentence's index included.\n  updateSelections(wordIndex, action) {\n    this.props.updateSelections(this.props.index, wordIndex, action)\n  }\n\n  deleteTag(wordIndex, entityClass) {\n    this.props.deleteTag(this.props.index, wordIndex, entityClass);\n  }\n\n  // Saves this sentence to a PNG file. wow!\n  saveToPng() {\n    var t = this;\n    var node = $(\"#sentence-tagging .sentence\")[this.props.index + 1];\n\n    function filter(node) {\n      if(node.classList) {\n        return !node.classList.contains('save-to-png');\n      }\n      return node;\n    }\n\n    domtoimage.toBlob(node, {filter: filter, bgcolor: '#fefefe'})\n    .then(function(blob) {\n      saveAs(blob, \"document-\" + t.props.index + \".png\"); \n    });\n\n  }\n\n  render() {\n\n    var selections = this.props.selections;\n\n    // Check props.selections to determine whether the word with a given index in this sentence is selected.\n    // This is passed to the word as a prop so that it can be highlighted accordingly.\n    function isWordSelected(wordIndex) {      \n      if(selections.length === 0) return false;     \n      for(var i = 0; i < selections.length; i++) {\n        var selection = selections[i];\n        if(selection.wordEndIndex < 0) continue;\n        if(selection.wordEndIndex >= wordIndex && wordIndex >= selection.wordStartIndex ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return (\n      <div className=\"sentence\">\n        { this.props.words.map((word, i) => \n          <Word key={i}\n                index={i}\n                text={word}\n                selected={isWordSelected(i)}\n                entityClasses={this.props.annotations[i].entityClasses || []}\n                isLastInSpan={this.props.annotations[i].isLastInSpan()}\n                bioTag={this.props.annotations[i].bioTag}\n                updateSelections={this.updateSelections.bind(this)}\n                entityColourMap={this.props.entityColourMap}\n                deleteTag={this.deleteTag.bind(this)}\n\n\n          />)\n        }   \n        <div className=\"save-to-png\" onClick={this.saveToPng.bind(this)} title=\"Click to download a .png file of this document\"><i className=\"fa fa-download\"></i></div>     \n      </div>\n    );\n  }\n\n}\n\n\n// A simple function for traversing a list of nodes. Goes with the function below.\n// Both functions found on StackOverflow: https://stackoverflow.com/questions/7781963/js-get-array-of-all-selected-nodes-in-contenteditable-div\nfunction nextNode(node) {\n    if (node.hasChildNodes()) {\n        return node.firstChild;\n    } else {\n      while (node && !node.nextSibling) {\n          node = node.parentNode;\n      }\n      if (!node) {\n          return null;\n      }\n      return node.nextSibling;\n    }\n}\n\n// A function for traversing the nodes present in the range object, which allows us to determine all html nodes\n// corresponding to selected items (items in which part of them are highlighted).\n// Note that you can't see the highlighted text on the screen because it has been hidden by css.\nfunction getRangeSelectedNodes(range) {\n    var node = range.startContainer;\n    var endNode = range.endContainer;\n\n    // Special case for a range that is contained within a single node\n    if (node == endNode) {\n        return [node.parentNode];\n    }\n\n    // Iterate nodes until we hit the end container\n    var rangeNodes = [];\n    while (node && node != endNode) {\n        rangeNodes.push( node = nextNode(node) );\n    }\n\n    // Add partially selected nodes at the start of the range\n    node = range.startContainer;\n    while (node && node != range.commonAncestorContainer) {\n        rangeNodes.unshift(node);\n        node = node.parentNode;\n    }\n\n    return rangeNodes;\n}\n\n\n// A simple class for displaying information related to the hotkeys the user is currently pressing.\nclass HotkeyInfo extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var ec = this.props.entityClass;\n    if(ec === undefined) {\n      ec = '(not a valid class)';\n    }\n\n    return (\n      <div className={\"hotkey-info\" + (this.props.chain.length === 0 ? \" hidden\": \"\")}>\n        <span className=\"chain\">{this.props.chain}</span>: <span>{ec}</span>\n      </div>\n    )\n\n  }\n}\n\n\n// A class to store an annotation for a single token.\n// Seemed more logical to put all the annotation logic in one class rather than sticking it in the TaggingInterface component.\n// Each sentence will have one Annotation object per token.\n// Properties:\n/* \n   token: the token e.g. 'centrifugal'\n   tokenIndex: the index of the token in the sentence\n   bioTag: the BIO tag ('B', 'I' or 'O')\n   entityClasses: the array of entity classes AKA labels (e.g. ['Item', 'Item/Pump'])   \n   spanText: the text of the span that this annotation is within (e.g. 'centrifugal pump')\n   spanStartIdx: the start index of the span this annotation is in, e.g. 0 if it starts at the first word of the sentence\n   spanEndIdx: the end index as above, e.g. 1,\n*/\nclass Annotation {\n  constructor(token, tokenIndex) {\n    this.token = token;\n    this.tokenIndex = tokenIndex;\n    this.bioTag = \"O\";    \n  }\n\n  // Adds the specified entityClass to this annotation.\n  // bioTag: The bioTag, e.g. \"B\" or \"I\",\n  // entityClass: The entity class, e.g. \"Item/Pump\"\n  // text: The text of the span that this annotation is inside, e.g. \"centrifugal pump\".\n  // spanStartIdx, spanEndIdx: self explanatory (as above)\n  // nextAnnotation: The Annotation object for the next token in the sentence.\n  //                 When called during the dictionary annotation tagging, nextAnnotation is not necessary.\n  // Returns whether the label of this annotation was modified at all.\n  addLabel(bioTag, entityClass, spanText, spanStartIdx, spanEndIdx) {\n    \n    if(this.entityClasses === undefined) this.entityClasses = new Array();\n\n    var alreadyHasLabel = this.entityClasses.indexOf(entityClass) !== -1;\n    if(this.bioTag === bioTag && this.spanText === spanText && this.spanStartIdx === spanStartIdx && this.spanEndIdx === spanEndIdx && alreadyHasLabel) {\n      return false;\n    }\n\n    // Adjust the span.\n    this.bioTag = bioTag;\n    this.spanText = spanText;\n    this.spanStartIdx = spanStartIdx;\n    this.spanEndIdx = spanEndIdx;\n\n    // Add the entityClass to the entityClasses array for this Annotation.\n    // If it is already there, don't add it again.\n    if(!alreadyHasLabel) {\n      this.entityClasses.push(entityClass);\n    }\n    return true;\n  \n    // If the nextAnnotation is from the same mention (AKA span) as this one, and does not have exactly the same labels after\n    // the new class has been appended to this annotation's entityClasses, change its BIO tag to B.\n    // This is the part that ensures mentions are split up when the user changes the label of token(s) inside that mention.\n    // if(nextAnnotation) {\n    //   if(this.sameMention(nextAnnotation) && !this.sameEntityClasses(nextAnnotation) && nextAnnotation.hasLabel()) {\n    //     console.log(\"Changing bio tag to B\")\n    //     nextAnnotation.changeBioTag(\"B\");\n    //     nextAnnotation.setSpanStartIdx(spanEndIdx + 1)          \n    //   }\n    // }\n\n    // If the previous annotation is from the same mention as this one, and now no longer has the same labels,\n    // adjust the spanEndIdx to be the start of this new span -1.\n    // This ensures the tags are rendered correctly in the browser.\n    // Note that this seems to get called multiple times when applying tags because they are applied in reverse order,\n    // but the spanEndIdx will be set as below for the next annotation anyway so that shouldn't be an issue.\n    // if(prevAnnotation) {\n    //   if(this.sameMention(prevAnnotation) && !this.sameEntityClasses(prevAnnotation) && prevAnnotation.hasLabel()) {  \n    //     prevAnnotation.setSpanEndIdx(spanStartIdx - 1);\n    //   }\n    // }\n  }\n\n  // Removes all the labels from this annotation and resets the bioTag to \"O\".\n  removeAllLabels() {\n    delete this.entityClasses;\n    delete this.spanText;\n    delete this.spanStartIdx;\n    delete this.spanEndIdx;\n    this.bioTag = \"O\";\n  }\n\n  // Simple function to determine whether this annotation is in the same mention as another annotation.\n  sameMention(otherAnnotation) {\n    return otherAnnotation.spanStartIdx === this.spanStartIdx && otherAnnotation.spanEndIdx === this.spanEndIdx;\n  }\n\n  // Determine whether this annotation has the same labels as another annotation.\n  sameEntityClasses(otherAnnotation) {\n    return _.isEqual(this.entityClasses, otherAnnotation.entityClasses);\n  }\n\n  // Removes a specific label from this annotation.\n  // If it was the last label, reset this annotation's bioTag to \"O\" and delete the entityClasses and other properties.\n  removeLabel(entityClass) {\n    var index = this.entityClasses.indexOf(entityClass);\n    if(index === -1) {\n      console.log(\"Warning: tried to remove an entity class from an annotation that did not exist.\")\n      return;\n    }\n    this.entityClasses.splice(index, 1);\n    if(this.entityClasses.length === 0) {\n      this.bioTag = \"O\";\n      delete this.entityClasses;\n      delete this.spanText;\n      delete this.spanStartIdx;\n      delete this.spanEndIdx;\n    }\n  }\n\n  // Change the bio tag of this annotation to another bio tag.\n  changeBioTag(bioTag) {\n    this.bioTag = bioTag;\n  }\n\n  // Returns whether this annotations has a label.\n  hasLabel() {\n    return this.bioTag !== \"O\";\n  }\n\n  // Determines whether this annotation is the last of its type in the given span.\n  isLastInSpan() {\n    return this.spanEndIdx === this.tokenIndex;\n  }\n\n  setSpanStartIdx(spanStartIdx) {\n    this.spanStartIdx = spanStartIdx;\n  }\n\n  setSpanEndIdx(spanEndIdx) {\n    this.spanEndIdx = spanEndIdx;\n  }\n\n  // Prints this annotation nicely to the console (for debugging).\n  prettyPrint() {\n    console.log(\"Token:    \", this.token);\n    console.log(\"BIO Tag:  \", this.bioTag)\n    console.log(\"Span:     \", this.spanText)\n    console.log(\"StartIdx: \", this.spanStartIdx)\n    console.log(\"EndIdx: \", this.spanEndIdx)\n    console.log(\"Classes:  \\n\", this.entityClasses);\n    console.log('\\n');\n  }\n}\n\n// A debug printing function for printing out a list of annotations for a document.\nfunction prettyPrintAnnotations(documentAnnotations) {\n  console.log(\"Annotations:\\n\")\n  console.log(\"=====================\")  \n  for(var token_idx in documentAnnotations) {\n    documentAnnotations[token_idx].prettyPrint();\n  }\n}\n\n// The Wikipedia summary container, at the top-left.\nclass WikipediaSummary extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      visible: true,\n      querying: false, // Currently in the middle of a query\n      wikipediaSummary: null,\n      wikipediaReadMoreUrl: null,\n    }\n  }\n\n\n  queryWikipedia() {\n    if(this.state.querying) return; // Don't query multiple things at once\n\n    var tokens = this.props.tokens;\n\n    // Query Wikipedia for the currently selected tokens.\n    function runQuery(next) {\n\n      // Processes the result of a Wikipedia query.\n      function getResult(data, next) {\n        function stripTags(str) {\n          return str.replace(/<\\/?[^>]+(>|$)/g, \"\");\n        }\n        try {\n          var title = data.query.search[0].title;\n          var snippet = stripTags(data.query.search[0].snippet);\n          var wurl = \"https://en.wikipedia.org/wiki/\" + data.query.search[0].title.replace(/ /g, '_');\n          return next(title, snippet, wurl);\n        } catch(err) {\n          next();\n        }\n      }\n      $.ajax({\n        url: 'https://en.wikipedia.org/w/api.php',\n        data: { action: 'query', list: 'search', srsearch: tokens, format: 'json' },\n        dataType: 'jsonp',\n        success: function(data) {\n          getResult(data, next);\n        }\n      });\n    } \n\n    this.setState({\n      querying: true\n    }, () => {\n      var wikipediaSummary, wikipediaReadMoreUrl;\n      var t = this;\n\n      runQuery(function(title, snippet, wurl) {\n        var wikipediaTitle = tokens;\n        if(snippet) {        \n          if(title.toLowerCase() !== tokens.toLowerCase()) {\n            wikipediaTitle = title;\n          }\n          wikipediaSummary = snippet + \"...\";\n          wikipediaReadMoreUrl = wurl;\n        } else {\n          wikipediaReadMoreUrl = null;\n          wikipediaSummary = null;  \n        }      \n\n        t.setState({\n          wikipediaTitle: wikipediaTitle,\n          wikipediaSummary: wikipediaSummary,\n          wikipediaReadMoreUrl: wikipediaReadMoreUrl,\n          querying: false,\n        })  \n      });\n\n    });\n  }\n\n  toggleVisibility() {\n    this.setState({\n      visible: !this.state.visible\n    })\n  }\n\n\n  componentDidUpdate(prevProps, prevState) {\n    if(prevProps.tokens !== this.props.tokens) {\n      this.queryWikipedia();\n    }\n  }\n\n  render() {    \n\n    if(!this.state.querying && this.state.wikipediaTitle && this.state.wikipediaTitle !== this.props.tokens) {\n      var title = <span className=\"different\">[{this.state.wikipediaTitle}] </span>\n    } else {\n      title = '';\n    }\n\n    var summary = this.state.wikipediaSummary ? this.state.wikipediaSummary : \"(no Wikipedia entry)\";\n    if(!this.props.tokens) {\n      summary = \"Select one or more words to automatically look them up on Wikipedia.\";\n    }\n    if(this.state.querying) {\n      summary = <span><i className=\"fa fa-spin fa-cog\"></i>&nbsp;&nbsp;Loading...</span>\n    }\n\n    // Rendering is a bit awkward, this could be tidied up\n    return (\n      <div className=\"tokens-info\">\n        <div id=\"wikipedia-summary-container\" className={this.state.visible ? \"show\" : \"hidden\"}>\n          <p className=\"tokens\">{this.props.tokens || 'Wikipedia lookup'}</p>\n          <p className=\"summary\">{ title }{ summary }</p>\n          <span className=\"more show\">\n            {(this.state.querying || !this.props.tokens) && <span className=\"left\" style={{\"color\": \"rgba(0, 0, 0, 0)\"}}>.</span>}\n            {!this.state.querying && this.props.tokens && <span className=\"left\">Results from Wikipedia</span>}\n            <span className=\"right\">\n              { !this.state.querying && this.props.tokens && <a id=\"ec-read-more\" href={this.state.wikipediaReadMoreUrl} target=\"_blank\">Read more <i className=\"fa fa-sm fa-external-link\"></i></a> } \n            </span>\n          </span>\n        </div>\n        <button id=\"wikipedia-hide-show\" className={this.state.visible ? \"up\" : \"down\"} onClick={this.toggleVisibility.bind(this)}>Show</button>\n      </div>\n    )\n  }\n}\n\n// The TaggingInterface class. Contains the vast majority of the logic for the interface.\nclass TaggingInterface extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      project_id: 'RtJp98vxk', // debug\n\n      // Data (from the server)\n      // The data in this object is only changed by calling the queryAPI method.\n      data: {\n        documentGroup: [],\n        categoryHierarchy: {'children': []},\n        pageNumber: -1,\n        annotatedDocGroups: -1,\n        username: \"\",\n      },\n\n      documentGroupAnnotationId: null, // The ID of the document group annotation object related to the document group the user is currently\n                                       // looking at. Will be null if the doc group has not been annotated by the user yet.\n                                       // Will be set when querying the API (for a previously annotated document group) or when\n                                       // submitting the annotations of a document group via submitAnnotations().\n\n      // Annotations array\n      annotations: [],  // Stores the user's annotations.\n      confidences: [],  // Stores the user's confidences.\n\n      // Selections\n      selections: this.getEmptySelectionsArray(10),       // The selections is an array containing a sub-array for each document,\n                                                          // which in turn hold all of the current selections made by the user for that\n                                                          // document.\n      currentSelection: this.getEmptyCurrentSelection(),  // The current selection is for when the user clicks a word and is in the process\n                                                          // of selecting an end word. \n      mostRecentSelectionText: null, // Keeps track of the tokens that the user most recently selected (for Wikipedia querying)\n      // Hotkeys\n      hotkeyMap: {},  // Stores a mapping of hotkey to number, e.g. 'item/pump': '11'.\n      reverseHotkeyMap: {}, // Stores the reverse of the above (number to hotkey), e.g. '11': 'item/pump'.\n      terminalHotkeys: new Set(),  // Stores the hotkeys of classes that are terminal, e.g. '1', '2' because Item and Activity do not have subclasses\n\n      hotkeyChain: [], // Stores the current hotkey chain, e.g. [1, 2, 3] = the user has pressed 1, then 2, then 3 in quick succession\n      hotkeyBindingFn: null,  // Stores the function that gets called via an eventlistener when a hotkey is pressed. Must be stored as a state\n                              // variable so that it can be detached when the hotkeys change.\n      hotkeyTimeoutFn: null,   // Stores the current hotkey timeout function.\n\n      // Key events\n      holdingCtrl: false, // Whether the user is currently holding the ctrl key.\n      holdingShift: false, // Whether the user is currently holding the shift key.\n\n      entityColourMap: {}, // A mapping of the top-level entity classes to a colour\n\n      docGroupLastModified: null, // Stores when the current document group was last saved.\n\n      pageNumber: -1, // The current page number the user is looking at.\n      totalPagesAvailable: -1, // The total number of pages available to the user, e.g. if they have annotated 1 group so far, then it's 2.\n\n      changesMade: false, // Stores whether the user has made any changes to the current document group.\n      recentlySaved: false, // Whether the doc group has been recently saved\n\n      selectionChangeFn: null,\n      windowMouseUpFn: null,\n\n      loading: {  // Stores whether this interface is currently requesting a docgroup from the server, or saving one\n        querying: true,\n        saving: false,\n        firstLoad: true,\n      },\n      showingProgressBar: false, // Whether the progress bar is currently visible\n\n      taggingCompletePage: false, // Set to true when the user is on the 'tagging complete' page.\n\n    }    \n  }\n\n\n\n  // When the user highlights text anywhere on the page, this function captures the event.\n  // If the user never selected a word to begin with, nothing happens.\n  // All it does is apply the 'highlighted' class onto any words that were caught in the highlighting.\n  // This function is purely stylistic, i.e. it doesn't affect any other components etc.\n  selectionChange(e, words) {\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      return;\n    }\n    var sel = window.getSelection && window.getSelection();\n\n    if (sel && sel.rangeCount > 0) {\n      var r =  getRangeSelectedNodes(sel.getRangeAt(0));  \n      words.removeClass('highlighted');\n      $(r).find('.word-inner').addClass('highlighted');  \n    }\n  }\n\n  // When the user releases the mouse, remove all highlighting from words (i.e. the words in the selection).\n  // If the user never selected a word to begin with (i.e. wordStartIndex < 0), clear all selections.\n  windowMouseUp(e, words) {\n    if(e.target.classList.contains('page-input')) return;\n\n    words.removeClass('highlighted');\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      clearWindowSelection();\n      return;\n    }\n    if(!e.target.classList.contains('word-inner')) { // Ensure that the user is not hovering over a word            \n      var sentenceIndex = this.state.currentSelection.sentenceIndex;\n      this.updateSelections(sentenceIndex, this.state.data.documentGroup[sentenceIndex].length - 1, 'up');\n    } \n  }\n\n  /* Mouse and keyboard events */\n\n  // Set up some mouse events - one for when text is selected (highlighted) in the browser.\n  // Note that in order to see the default browser highlighting the CSS file needs to be modified (it makes it invisible).\n  // Another for when the user releases the mouse anywhere on the page.\n  // Note that the majority of the mouse events are not in this function but are passed down to the Word elements via updateSelections.\n  // The event listeners need to be removed and reapplied to prevent duplication.\n  initMouseEvents() {\n\n    var words = $('.word-inner');\n\n    var selectionChangeFn = (e) => this.selectionChange(e, words);\n    var windowMouseUpFn = (e) => this.windowMouseUp(e, words);\n    \n    // Remove the old event listeners.\n    document.removeEventListener(\"selectionchange\", this.state.selectionChangeFn);   \n    window.removeEventListener('mouseup', this.state.windowMouseUpFn);\n\n    this.setState({\n      selectionChangeFn: selectionChangeFn,\n      windowMouseUpFn: windowMouseUpFn\n    }, () => {\n      // Add the new event listeners.\n      document.addEventListener(\"selectionchange\", this.state.selectionChangeFn);\n      window.addEventListener('mouseup', this.state.windowMouseUpFn);\n    });    \n  }\n\n  // Set up the key binds (ctrl, shift, left right up down etc).\n  // This function does not set up the hotkeys (that is done via setupHotkeyKeybinds)\n  initKeybinds() {\n\n    document.addEventListener('keydown', (e) => {\n      switch(e.key) {\n        case 'Shift':       if(!this.state.holdingShift) this.setState({ holdingShift: true }); break;\n        case 'Control':     if(!this.state.holdingCtrl) this.setState({ holdingCtrl: true }); break;\n\n        // For the arrows, call e.preventDefault() to prevent the window from scrolling\n        case 'ArrowLeft':   e.preventDefault(); this.moveSelectionHorizontally('left'); break; \n        case 'ArrowUp':     e.preventDefault(); this.moveSelectionVertically('up'); break;\n        case 'ArrowRight':  e.preventDefault(); this.moveSelectionHorizontally('right'); break;\n        case 'ArrowDown':   e.preventDefault(); this.moveSelectionVertically('down'); break;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      switch(e.key) {\n        case 'Shift':   if(this.state.holdingShift) this.setState({ holdingShift: false }); break;\n        case 'Control': if(this.state.holdingCtrl) this.setState({ holdingCtrl: false }); break;\n      }      \n    });\n  }\n\n\n\n  /* Hotkey functions */\n\n  // When the user has pressed a hotkey that is not quickly followed up with another hotkey, this function is called.\n  // Apply the corresponding entity class and reset the hotkey chain.\n  hotkeyTimeout() {\n    var hotkeyChainStr = this.state.hotkeyChain.join('');\n\n    var entityClass = this.state.reverseHotkeyMap[hotkeyChainStr];\n    if(entityClass !== undefined) this.applyTag(entityClass);\n\n    // Clear the existing hotkey timeout fn.\n    window.clearTimeout(this.state.hotkeyTimeoutFn);\n    this.setState({\n      hotkeyTimeoutFn: null,      \n      hotkeyChain: [],\n    })\n  }\n\n  // This function is called when a hotkey is pressed.\n  // If a hotkey was pressed previously within 333ms, the chain will grow until the point the user no longer presses a hotkey\n  // for 333ms.\n  bindHotkeys(e, hotkeyMap) {\n    if(e.keyCode < 49 || e.keyCode > 57) return; // Hotkeys are in the range 1-9, which are keyCode 49-57.\n    var key = e.keyCode - 48;\n\n    // If user is currently focused on the page input, do nothing.\n    if($(\"#page-input\").is(\":focus\")) return;\n\n    // Update the hotkey chain to include the key that was pressed\n    var hotkeyChain = Array.prototype.concat(this.state.hotkeyChain, key);\n    this.setState({\n      hotkeyChain: hotkeyChain\n    }, () => {\n\n      // Remove the previous timeout and set up a new one\n      window.clearTimeout(this.state.hotkeyTimeoutFn);\n\n\n\n      // Check if hotkey was terminal, i.e. at the leaf of the tree\n      if(this.state.terminalHotkeys.has(hotkeyChain.join(''))) {\n        this.hotkeyTimeout();\n      } else {\n        var hotkeyTimeoutFn = window.setTimeout(() => this.hotkeyTimeout(), 333);\n        this.setState({\n          hotkeyTimeoutFn: hotkeyTimeoutFn\n        });\n      }\n\n            \n      \n    });\n  }\n\n  // Assign keybinds to each of the hotkeys in the hotkey map.\n  setupHotkeyKeybinds() {\n    \n    console.log(\"Setting up hotkey keybinds...\")\n\n    console.log(this.state.reverseHotkeyMap);\n\n    // Clear the current hotkey binding function and set up a new one.\n    document.removeEventListener('keydown', this.state.hotkeyBindingFn);\n    var hotkeyBindingFn = (e) => this.bindHotkeys(e, this.state.hotkeyMap);\n\n    document.addEventListener('keydown', hotkeyBindingFn);\n\n    // Store the binding function in this.state so that it can be removed in subsequent calls of this function.\n    this.setState({\n      hotkeyBindingFn: hotkeyBindingFn,\n    });\n  }\n\n  // Builds the hotkey map according to the ordered category hierarchy, and saves it to this component's state.\n  // The hotkey map will change whenever the user changes the order of them items via drag and drop.\n  initHotkeyMap(orderedItems, next) {\n\n    console.log(\"Setting up hotkey map...\")\n    // Annoying that the following is a recursive function but I think it's the only way to do it.\n    // The result is a hotkeyMap as follows:\n    /*  {\n          'item': [1],\n          'item/pump': [1, 1],\n          'item/pump/centrifugal_pump': [1, 1, 1],\n          'item/pump/big_pump': [1, 1, 2],\n          'item/compressor': [1, 2],\n          'activity': [2]\n        }\n    */\n    function traverseChild(child, index, hotkeyMap, hotkeys, terminalHotkeys, firstPass) {\n      if(!firstPass) {\n        hotkeyMap[child.full_name] = hotkeys;\n      }\n      if(child.children) {\n        for(var i = 0; i < Math.min(9, child.children.length); i++) { // Don't go past index 9 so that the hotkeys make sense\n          traverseChild(child.children[i], i + 1, hotkeyMap, Array.prototype.concat(hotkeys, i + 1), terminalHotkeys);\n        }\n      } else {\n        terminalHotkeys.add(hotkeys.join(''));\n      }\n      return {hotkeyMap: hotkeyMap, terminalHotkeys: terminalHotkeys};          \n    }    \n\n    // Build the reverse of the hotkeyMap, i.e. swap the keys with the values.\n    // This assists with the hotkey bindings function.\n    function buildReverseHotkeyMap(hotkeyMap) {\n      var reverseHotkeyMap = {};\n      for(var key in hotkeyMap){\n        var val = hotkeyMap[key].join('');\n        reverseHotkeyMap[val] = key;\n      }\n      return reverseHotkeyMap;    \n    }\n\n\n    var d = traverseChild({children: orderedItems}, 1, [], [], new Set(), true);\n    var hotkeyMap = d.hotkeyMap;\n    var terminalHotkeys = d.terminalHotkeys;\n    var reverseHotkeyMap = buildReverseHotkeyMap(hotkeyMap);\n\n    // Once the hotkeyMap (and reverseHotkeyMap) has been created, set up the hotkey keybinds and call the callback fn.\n    this.setState({\n      hotkeyMap: hotkeyMap,\n      reverseHotkeyMap: reverseHotkeyMap,\n      terminalHotkeys: terminalHotkeys,\n    }, () => { this.setupHotkeyKeybinds(); if(next) next(); });\n  }\n\n\n  // Sets up an array to store the annotations with the same length as docGroup.\n  // Prepopulate the annotations array with the automaticAnnotations if available (after converting them to BIO).\n  // This could be either the dictionary-based annotations or the annotations that the user has previously entered.\n  initAnnotationsArray(documents, automaticAnnotations) {\n\n    var annotations = new Array(documents.length);\n    for(var doc_idx in documents) {\n      annotations[doc_idx] = new Array(documents[doc_idx].length);\n      for(var token_idx in documents[doc_idx]) {\n        annotations[doc_idx][token_idx] = new Annotation(documents[doc_idx][token_idx], parseInt(token_idx));\n      }\n    }\n\n    if(!automaticAnnotations) return annotations;\n\n    // Load annotations from the automaticAnnotations array if present.\n    for(var doc_idx in automaticAnnotations) {\n      for(var mention_idx in automaticAnnotations[doc_idx]['mentions']) {\n\n        var mention = automaticAnnotations[doc_idx]['mentions'][mention_idx];\n        var start = mention['start'];\n        var end = mention['end'];\n\n        for(var label_idx in mention['labels']) {\n          var label = mention['labels'][label_idx];\n\n          for(var k = start; k < end; k++) {\n            var bioTag = k === start ? 'B' : \"I\";\n            annotations[doc_idx][k].addLabel(bioTag, label, documents[doc_idx].slice(start, end).join(' '), start, end - 1)\n          }\n        }\n      }        \n    }\n    return annotations;\n  }\n\n  // Initialise the confidences array.\n  initConfidencesArray(documents) {\n    var confidences = new Array(documents.length);\n    return confidences;\n  }\n\n  // Initialise the entity colour map, which maps entity_class: colour_index, e.g. \"Item\": 1. Passed to the Word components to colour\n  // their labels accordingly.\n  initEntityColourMap(categoryHierarchy) {\n    var entityColourMap = {}\n    for(var ec_idx in categoryHierarchy) {\n      var entityClass = categoryHierarchy[ec_idx];\n      entityColourMap[entityClass.name] = entityClass.colorId + 1;\n    }\n    return entityColourMap;\n  }\n\n\n  /* Miscellaneous */\n\n  // Justify the words to the nearest 25px (i.e. round their width up to the nearest 25px).\n  // Not really necessary but makes the diagonal stripey lines line up properly when multiple tokens are selected.\n  // I spent about 2 hours trying to figure out how to get the stripey lines to line up properly, this is the result :D\n  justifyWords() {\n    $('.word-inner').each((i, ele) => {\n      var width = ele.offsetWidth;\n      var newWidth = Math.ceil(width / 25) * 25;\n      $(ele).css('min-width', newWidth + 'px');\n    });\n  }\n\n  // Remove min-width from words that do not have a tag\n  // (necessary to call between pages)\n  clearWordJustification() {\n    $('.word:not(.tag) .word-inner').each((i, ele) => {\n       $(ele).css('min-width', 'auto');\n    })\n  }\n\n  // Load the next page by calling the API.\n  // Query without a page number (i.e. request the latest group)\n  // if the user is looking at the group before the latest group.\n  //\n  // TODO: Make it so that when the user has made a change to the group they're looking at,\n  // pop up a confirmation window to confirm their changes before loading the next page?\n  loadNextPage() {\n    var nextPageNumber = this.state.pageNumber + 1;\n    if(nextPageNumber === (this.state.totalPagesAvailable)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, nextPageNumber);\n    }\n  }\n\n  goToPage(pageNumber) {\n    if(pageNumber === (this.state.totalPagesAvailable)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, pageNumber);\n    }\n  }\n\n  // Load the previous page by calling the API.\n  loadPreviousPage() {\n    this.queryAPI(false, this.state.pageNumber - 1);\n  }\n\n  /* API calls */\n\n  queryAPI(firstLoad, pageNumber) {\n    const fetchConfig = {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }\n    };\n    var route = 'getDocumentGroup';\n\n    // If this function was called with a pageNumber, load a specific documentGroupAnnotation.\n    if(pageNumber) {\n      route = 'getPreviouslyAnnotatedDocumentGroup?pageNumber=' + pageNumber;\n    }\n\n    this.setState({\n      loading: {\n        querying: true,\n        saving: false,\n        firstLoad: firstLoad,\n      }\n    }, function() {\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/' + route, fetchConfig) // TODO: move localhost out\n        .then(response => response.text())\n        .then((data) => {\n          try { \n            var d = JSON.parse(data);\n          } catch(err) {\n            alert(err);\n            return;\n          }\n\n\n          if(d.tagging_complete) {\n            console.log(d);\n            this.setState({\n              taggingCompletePage: true,\n              totalPagesAvailable: d.annotatedDocGroups + 1,\n              pageNumber: d.annotatedDocGroups + 1,\n              changesMade: false,\n              recentlySaved: false,\n\n              loading: {\n                querying: false,\n                saving: false,\n              },\n              data: {\n                username: d.username,\n                projectName: d.projectName,\n                documentGroup: [],\n                categoryHierarchy: {'children': []},\n                pageNumber: -1,\n                annotatedDocGroups: -1,\n              },\n            })\n            return;\n          } \n\n          \n          this.setState(\n            {\n              data: d,\n              entityColourMap: this.initEntityColourMap(d.categoryHierarchy.children),\n              confidences: this.initConfidencesArray(d.documentGroup),\n              annotations: this.initAnnotationsArray(d.documentGroup, d.automaticAnnotations),\n              selections: this.getEmptySelectionsArray(d.documentGroup.length),\n              mostRecentSelectionText: null,\n              pageNumber: d.pageNumber,\n              totalPagesAvailable: d.annotatedDocGroups + 1,\n              docGroupLastModified: d.lastModified,\n              documentGroupAnnotationId: d.documentGroupAnnotationId, // Will be null if this doc group has not yet been annotated\n              changesMade: false,\n              recentlySaved: false,\n              loading: {\n                querying: false,\n                saving: false\n              },     \n              taggingCompletePage: false,         \n            }, () => { \n              console.log(\"Data:\", this.state.data);\n\n              // Initialise keybinds and mouse events only on the first API call.\n              if(firstLoad) {\n                this.initKeybinds();              \n                this.initHotkeyMap(this.state.data.categoryHierarchy.children);   \n              }\n\n              this.initMouseEvents();\n              this.clearWordJustification();    \n              this.justifyWords();    \n              this.selectFirstWord();\n\n              window.scrollTo(0, 0);\n            })\n        });\n        \n\n    }.bind(this));\n  }\n\n  // Convert the annotations array into JSON.\n  annotationsToJSON() {\n    var annotations = this.state.annotations;\n    var annotationsJSON = [];\n    for(var doc_idx in annotations) {\n        \n      var docLabels = [];\n      for(var token_idx in annotations[doc_idx]) {\n        var ann = annotations[doc_idx][token_idx];\n        if(ann.entityClasses) {\n          docLabels.push([ann.bioTag + \"-\", ann.entityClasses]);\n        } else {\n          docLabels.push([\"\"])\n        }\n      }\n      annotationsJSON.push(docLabels);\n    }\n    return annotationsJSON;\n  }\n\n\n  // Submit the annotations of the document group that the user is currently looking at.\n  // TODO: Maybe make it so that you can't save the annoations until the user has put all their confidences in?\n  // Or perhaps do a check and pop a confirmation window up if they click save without doing anything to >= 1 document\n  submitAnnotations() {\n    if(this.state.recentlySaved) { return; } // If the user clicks on the green save button, provide them with the illusion that it is doing\n                                             // something when in fact nothing actually happens. Prevents people from spam clicking the save and\n                                             // calling the API 5000 times...\n                                             // It's kind of like how google sheets allows you to press Ctrl + S despite it saving every action\n                                             // automatically.\n\n    const csrfToken = getCookie('csrf-token');\n\n    var annotationsJSON = this.annotationsToJSON();\n\n    const fetchConfig = {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'csrf-token': csrfToken,\n      },\n      dataType: \"json\",\n      body: JSON.stringify({\n        documentGroupId: this.state.data.documentGroupId,\n        documentGroupAnnotationId: this.state.documentGroupAnnotationId,\n        labels: annotationsJSON\n      }),  \n    };\n\n    this.setState({\n      loading: {\n        querying: false,\n        saving: true,\n      }\n    }, () => {\n\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/submitAnnotations', fetchConfig) // TODO: move localhost out\n      .then(response => response.text())\n      .then((data) => {\n        try { \n          var d = JSON.parse(data);\n\n          console.log(d);\n\n          var documentGroupAnnotationId = d.documentGroupAnnotationId;\n          console.log(\"Submitted annotations OK\");\n\n          // If the user is on the last page (i.e. the 'current group'), add one to the totalPages array so that the user can\n          // click 'Next' to go to the latest doc group.\n          if(this.state.pageNumber === this.state.totalPagesAvailable) {\n            var newTotalPagesAvailable = this.state.totalPagesAvailable + 1;\n            this.setState({\n              showingProgressBar: true,\n            }, () => {\n              window.setTimeout(() => this.setState({\n                showingProgressBar: false,\n              }), 3000);\n            })\n\n          } else {\n            var newTotalPagesAvailable = this.state.totalPagesAvailable;\n          }\n\n          this.setState({\n             docGroupLastModified: Date.now(),\n             totalPagesAvailable: newTotalPagesAvailable,\n             changesMade: false,\n             recentlySaved: true,\n             documentGroupAnnotationId: documentGroupAnnotationId,\n             loading: {\n              querying: false,\n              saving: false\n             }\n          });\n        } catch(err) {\n          console.log(\"ERROR:\", err);\n          alert(data);\n        }\n        \n        //this.queryAPI(this.state.data.pageNumber + 1);\n      });\n    });\n  }\n\n  /* Mounting function */\n\n  // When this component is mounted, call the API.\n  // Set up the keybinds and mouseup event when done.\n  componentWillMount() {\n\n    var pathname = window.location.pathname;\n    var project_id = pathname.split('/')[2];\n    if(pathname === \"/\") {\n      //var project_id = 'RtJp98vxk'; // React development (completed project)\n      var project_id = '-krXeW3R2'; // React development (big one)\n    }\n    if(!project_id || project_id.length < 8) {\n      alert(\"invalid project\");\n      return;\n    }\n\n\n\n    this.setState({\n      project_id: project_id\n    }, () => { this.queryAPI(true) });\n  }  \n\n  /* Selection functions */\n\n  // Get an empty current selection.\n  // Called when we need to clear the current selection.\n  getEmptyCurrentSelection() {\n    return {\n      wordStartIndex: -1,\n      wordEndIndex: -1,\n      sentenceIndex: -1\n    }\n  }\n\n  // Move the selection up or down.\n  // This function should be called when one of those keys is pressed.\n  moveSelectionVertically(direction) {\n    console.log(\"Moving\", direction) // TODO: Make this move up and down\n  }\n\n  // Move the selection in the specified direction ('left', 'right').\n  // This function should be called when one of those keys is pressed.\n  moveSelectionHorizontally(direction) {\n    console.log(\"Moving\", direction)\n\n    var selections = this.state.selections;\n    var mostRecentSelectionText;\n\n    // Move all selections left or right\n    for(var i = 0; i < selections.length; i++) {\n      for(var j = 0; j < selections[i].length; j++) {\n        var selection = selections[i][j];\n\n        // Behaviour depends on whether shift is currently being held down.\n        if(direction === \"left\") {\n          if(!this.state.holdingShift) {\n            selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            selection.wordEndIndex = selection.wordStartIndex;\n          } else { // If shift is being held down, move the wordEndIndex backwards or move the wordStartIndex backwards depending on the current selection.\n            if(selection.wordEndIndex > selection.wordStartIndex) {\n              selection.wordEndIndex--;\n            } else {\n              selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            }\n          }\n        } else if (direction === \"right\") {\n          if(!this.state.holdingShift) { // If shift *is* being held down, this won't happen (the wordStartIndex won't change).\n            selection.wordStartIndex = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n          }\n          selection.wordEndIndex   = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n        }\n\n        mostRecentSelectionText = this.state.data.documentGroup[i].slice(selection.wordStartIndex, selection.wordEndIndex + 1).join(' ');\n      }\n    }\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText\n    });\n  }\n\n  // Get an empty selections array whose length is the number of docs in the current documentGroup.\n  getEmptySelectionsArray(numDocs) {\n    if(!numDocs) {\n      var numDocs = this.state.data.documentGroup.length;\n    }\n    var selections = new Array(numDocs);\n    for(var i = 0; i < selections.length; i++) {\n      selections[i] = new Array();\n    }    \n    return selections;\n  }  \n\n  // Select the first word in the first sentence.\n  // (called when a new group is loaded).\n  selectFirstWord() {\n    var selections = this.state.selections;\n    selections[0].push({\n      wordStartIndex: 0,\n      wordEndIndex: 0\n    });\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: this.state.data.documentGroup[0][0],\n    });\n  }\n\n  // Clear all active selections by resetting the selections array.\n  clearSelections() {\n    this.setState( {\n      currentSelection: this.getEmptyCurrentSelection(),\n      selections: this.getEmptySelectionsArray()\n    });\n  }\n\n  // Update this component's selections state.\n  // This function is called via the mouse, and has no relation to the keyboard (keyboard selections are handled above).\n  // sentenceIndex: The index of the sentence in which the selection was made.\n  // wordIndex: the index of the word that was clicked on, or hovered over and the mouse released.\n  // action: Whether the mouse was pressed down ('down') or released ('up').\n  updateSelections(sentenceIndex, wordIndex, action) {\n    var wordStartIndex, wordEndIndex;\n\n    var selections = this.state.selections;\n    var currentSelection = this.state.currentSelection;\n\n    if (action === \"down\") { // Mouse down, i.e. a word was clicked.\n\n      if(!this.state.holdingCtrl) {\n        selections = this.getEmptySelectionsArray(); // Reset all selections upon clicking a word, unless Ctrl is being held.\n      }\n      wordStartIndex = wordIndex;\n      wordEndIndex = -1;\n\n      // A new selection is made, capturing the index of the sentence that the user clicked on and the index of the word that they clicked.\n      currentSelection = {\n        sentenceIndex: sentenceIndex,\n        wordStartIndex: wordStartIndex\n      }      \n\n    } else if(action === \"up\") { // Mouse up, i.e. mouse was released when hovering over a word.\n\n      // Only allow selections where the user has clicked on a starting word.\n      if(currentSelection.wordStartIndex === -1) {\n        this.clearSelections();\n        return;\n      }\n\n      wordStartIndex = currentSelection.wordStartIndex;\n\n      // If the first word selected was in a different sentence, the wordStartIndex becomes the start of the sentence where the mouse was released.\n      if(currentSelection.sentenceIndex !== sentenceIndex) {  // TODO: Make this consider mouseX relative to the X of the initial token?\n        wordStartIndex = 0;\n      };\n\n      wordEndIndex = wordIndex;\n\n      // If the second word selected was before the first, swapperino them around (so that backwards selections work as expected).\n      if(wordIndex < wordStartIndex) {\n        var s = wordStartIndex;\n        wordStartIndex = wordIndex;\n        wordEndIndex = s;\n      }     \n\n      // Create a new selections json object and push it to the selections array for this sentence.\n      currentSelection = this.getEmptyCurrentSelection();\n      selections[sentenceIndex].push({\n        wordStartIndex: wordStartIndex,\n        wordEndIndex: wordEndIndex\n      });\n      var mostRecentSelectionText = this.state.data.documentGroup[sentenceIndex].slice(wordStartIndex, wordEndIndex + 1).join(' ');\n\n      clearWindowSelection(); // Remove the default browser selection highlighty thing.\n    }    \n\n    this.setState({\n      currentSelection: currentSelection,\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText ? mostRecentSelectionText : this.state.mostRecentSelectionText,\n    });\n  }\n\n\n\n\n  /* Tag application function */\n\n  // Apply a specific tag to all current selections.\n  // entityClass: The full name of the entity class, e.g. 'item/pump/centrifugal_pump'.\n  // This function will either be called via clicking on an entity class in the tree, or by using hotkeys.\n  applyTag(entityClass) {    \n    //console.log(\"Applying tag:\", entityClass);\n    var selections = this.state.selections;\n    var documents = this.state.data.documentGroup;\n    var annotations = this.state.annotations;\n\n    for(var doc_idx in selections) {\n      for(var sel_idx in selections[doc_idx]) {\n        var sel = selections[doc_idx][sel_idx];\n        var start = sel.wordStartIndex;\n        var end = sel.wordEndIndex;\n\n\n        /* 1. Disjoint spans */\n        // Check all labels across this selected span of tokens are the same before proceeding.\n        // If they are not, they must be cleared before adding a label.\n        var annotationSpanStart = annotations[doc_idx][start].spanStartIdx;\n        var annotationSpanEnd   = annotations[doc_idx][start].spanEndIdx;\n        var notAllEqual = false;          \n        for(var k = start + 1; k <= end; k++) {\n          var otherAnnotation = annotations[doc_idx][k]; \n          if(annotationSpanStart !== otherAnnotation.spanStartIdx || annotationSpanEnd !== otherAnnotation.spanEndIdx) {\n            notAllEqual = true;\n            break;\n          }          \n        }        \n\n        // If the labels across all tokens in the selected span are not the same, remove all labels for the entire span.\n        // Then modify the spanEndIdx of any annotations in this document whose spanEndIdx was overlapping the\n        // span that the user selected, setting them to be start index - 1 (before the span).\n        // This ensures the ends of the spans are drawn properly.\n        if(notAllEqual) {\n          for(var k = start; k <= end; k++) {\n            var annotation = annotations[doc_idx][k];\n            annotation.removeAllLabels();\n          }          \n          // Adjust the span end index of all prev labels to be start index - 1\n          // A shame that we have to iterate across all annotations in this document - this could probably be optimised\n          // but it probably barely impacts performance even on large docs (I think)\n          for(var x in annotations[doc_idx]) {\n            var annotation = annotations[doc_idx][x];\n\n\n            // If this new span overlaps the *end* of an existing span, change that span's end index to the start of this new\n            // span, -1\n\n            if(annotation.spanEndIdx >= start && annotation.spanStartIdx <= start) {              \n              annotation.setSpanEndIdx(start - 1);\n\n            }\n\n            // If this new span overlaps the *start* of an existing span, change that span's start index to be the end of this new span -1\n            // and change the BIO tag to \"B\".\n            if(annotation.spanStartIdx <= end) {\n              annotation.setSpanStartIdx(end + 1);              \n              if(annotation.tokenIndex === (end + 1)) {\n                annotation.changeBioTag(\"B\") // I am realising now that this BIO tag is unnecessary - it could be inferred\n              }\n            }\n          }\n        }\n\n        /* 2. Overlapping spans */\n        // Check for any spans that this new span will cut into.\n        // First, check to the left and adjust the spanEndIdx of all Annotation objects\n        // to the left of this span if they overlap.\n        for(var ann_idx in annotations[doc_idx].slice(0, start)) {\n          var annotation = annotations[doc_idx][ann_idx];          \n          if(annotation.spanStartIdx < start && annotation.spanEndIdx >= end) {            \n            annotation.setSpanEndIdx(start - 1);\n          }\n        }\n\n        // Do the same for any Annotation objects on the right hand side of this span, which are part of the same\n        // mention.\n        for(var ann_idx in annotations[doc_idx].slice(end + 1, annotations[doc_idx].length)) {\n          var annotation = annotations[doc_idx][parseInt(ann_idx) + end + 1];\n          if(annotation.spanStartIdx <= start && annotation.spanEndIdx >= end) {\n            annotation.setSpanStartIdx(end + 1);\n            if(ann_idx === '0') {\n              annotation.changeBioTag(\"B\");\n            }\n          }\n        }\n\n        /* 3. Applying the labels */\n        // Now, apply the tags to every token in the selected span.\n        var labelWasModified = false;\n        for(var k = start; k <= end; k++) {\n          var bioTag = k === start ? \"B\" : \"I\";\n          var spanText = documents[doc_idx].slice(start, end + 1).join(' ');\n\n          //var prevAnnotation = k > 0 ? annotations[doc_idx][k - 1] : null;\n          //var nextAnnotation = k < (documents[doc_idx].length - 1) ? annotations[doc_idx][k + 1] : null;          \n\n          labelWasModified = annotations[doc_idx][k].addLabel(bioTag, entityClass, spanText, start, end);\n\n        }\n\n        if(labelWasModified) this.captureEvent('Applied label', parseInt(doc_idx), start, end, entityClass);\n      }\n    }\n    this.setState({\n      annotations: annotations,\n    }, () => {\n      this.justifyWords(); // Justify the words again to ensure the stripey lines line up correctly\n\n      // Debug:\n      //prettyPrintAnnotations(this.state.annotations[0]);\n      //console.log(\"Updated annotations[0]:\", this.state.annotations[0]);\n    })\n\n  }\n\n  // Deletes the specified tag.\n  // Unlike applyTag, this is applied to a specified sentenceIndex and wordIndex rather than to all current selections.\n  deleteTag(sentenceIndex, wordIndex, entityClass) {\n    \n    var annotations = this.state.annotations;\n    var annotation = annotations[sentenceIndex][wordIndex];\n\n    // Retrieve the span start idx and span end idx of the annotation corresponding to (sentence_index, word_index)\n    var spanStart = annotation.spanStartIdx;\n    var spanEnd = annotation.spanEndIdx;\n\n    this.captureEvent('Deleted label', sentenceIndex, spanStart, spanEnd, entityClass);\n\n    // Find all annotations in this document in the same mention span and remove the label from all of them.\n    // (this will also remove the label from the annotation object at (sentence_index, word_index)).\n    for(var ann_idx in annotations[sentenceIndex]) {\n      var otherAnnotation = annotations[sentenceIndex][ann_idx];       \n      if(otherAnnotation.spanStartIdx === spanStart && otherAnnotation.spanEndIdx === spanEnd) {\n        otherAnnotation.removeLabel(entityClass);\n      }\n    }\n\n    this.setState({\n      annotations: annotations\n    });\n\n  }\n\n  /* Confidence */\n\n  // Updates the confidences array for the given doc.\n  // If the user clicks on the button they already clicked, then the confidence is reset to undefined.\n  updateConfidence(sentenceIndex, confidence) {\n    var confidences = this.state.confidences;\n    if(confidences[sentenceIndex] === confidence) {\n      confidences[sentenceIndex] = undefined;\n    } else {\n      confidences[sentenceIndex] = confidence;\n    }\n    this.setState({\n      confidences: confidences\n    });\n  }\n\n  /* Events */\n\n  // Capture an event\n  // TODO: Make it do something\n  captureEvent(eventAction, sentenceIndex, spanStart, spanEnd, entityClass) {\n\n    var tokenString = this.state.data.documentGroup[sentenceIndex].slice(spanStart, spanEnd + 1).join(' ')\n\n    var event = {\n      \"action\": eventAction,\n      \"sentenceIndex\": sentenceIndex,\n      \"wordIndex\": {\n        \"start\": spanStart,\n        \"end\": spanEnd,\n      },\n      \"entityClass\": entityClass,\n      \"tokenString\": tokenString\n    }\n\n    if(eventAction === \"Applied label\" || eventAction === \"Deleted label\") {\n      this.setState({\n        changesMade: true,\n        recentlySaved: false,\n      })\n    }\n\n  }\n\n  /* Rendering function */\n\n\n  render() {\n\n\n    var taggingCompletePage = this.state.taggingCompletePage;\n\n    return (\n      <div id=\"app\">      \n        <Navbar pageTitle={\"Annotating project: \" + this.state.data.projectName} username={this.state.data.username} />  \n        <div id=\"tagging-interface\" className={(this.state.loading.querying ? \"loading\" : \"\") + (taggingCompletePage ? \" tagging-complete-page\" : \"\")}>\n\n          <div id=\"tagging-container\">\n            { taggingCompletePage && <TaggingCompletePage/>}\n            <div id=\"sentence-tagging\">\n\n              { this.state.loading.firstLoad && \n                <div className=\"loading-message\">\n                  <i className=\"fa fa-cog fa-spin\"></i>Loading...\n                </div>\n              }\n\n              <ControlBar\n                showingProgressBar = {this.state.showingProgressBar}\n                pageNumber = {this.state.pageNumber}\n                totalPages = {this.state.data.docGroupsPerUser}\n                totalPagesAvailable = {this.state.totalPagesAvailable}\n                lastModified={this.state.docGroupLastModified}\n                recentlySaved={this.state.recentlySaved}\n                changesMade={this.state.changesMade}\n                querying={this.state.loading.querying}\n                saving={this.state.loading.saving}\n\n                submitAnnotations={this.submitAnnotations.bind(this)}\n                loadPreviousPage={this.loadPreviousPage.bind(this)}\n                loadNextPage={this.loadNextPage.bind(this)}\n                goToPage={this.goToPage.bind(this)}\n              />\n\n              <DocumentContainerHeader/>\n                  \n              { this.state.data.documentGroup.map((doc, i) => \n                <DocumentContainer\n                  key={i}\n                  index={ i }\n                  displayIndex={( (this.state.pageNumber - 1) * 10 ) + i + 1  }\n                  words={doc}              \n                  annotations={this.state.annotations[i]}  \n                  confidence={this.state.confidences[i]}\n                  selections={this.state.selections[i]}\n                  updateSelections={this.updateSelections.bind(this)}\n                  updateConfidence={this.updateConfidence.bind(this)}\n                  entityColourMap={this.state.entityColourMap}\n                  deleteTag={this.deleteTag.bind(this)}\n                />\n                )}\n\n            </div>\n          </div>\n          <div id=\"tagging-menu\">\n            <WikipediaSummary tokens={this.state.mostRecentSelectionText}/>\n            <HotkeyInfo \n              chain={this.state.hotkeyChain}\n              entityClass={this.state.reverseHotkeyMap[this.state.hotkeyChain.join('')]}\n            />            \n            \n            <CategoryHierarchy\n              items={this.state.data.categoryHierarchy.children}\n              hotkeyMap={this.state.hotkeyMap}\n              hotkeyChain={this.state.hotkeyChain.join('')}\n              initHotkeyMap={this.initHotkeyMap.bind(this)}\n              applyTag={this.applyTag.bind(this)}              \n            />\n          </div>      \n        </div>\n      </div>\n    )\n  }\n}\n\n// The humble save button that appears at the top of the page.\nclass SaveButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n\n    var buttonClass = \" disabled\";\n    if(this.props.changesMade) buttonClass = \"\";\n    if(this.props.recentlySaved) buttonClass = \" recently-saved\";\n    if(this.props.saving) buttonClass = \" saving\";\n\n    var iconClass = \"fa-save\";\n    if(this.props.recentlySaved) iconClass = \"fa-check\";\n    if(this.props.saving) iconClass = \"fa-cog fa-spin\"\n\n    var text = \"Save\";\n    if(this.props.recentlySaved) text = \"Saved\";\n    if(this.props.saving) text = \"Saving\";\n\n    return (\n      <button className={\"save-button\" + buttonClass} onClick={this.props.submitAnnotations}>\n        <i className={\"fa \" + iconClass}></i>\n        { text }\n      </button>\n    )\n  }\n}\n\n\n// The progress bar that appears when the user saves a new doc group.\nclass ProgressBar extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-progress-bar\" className={(this.props.show ? \"show\" : \"hide\")}>\n        <span className=\"progress-bar\">\n          <span className=\"inner\" style={{\"width\": (this.props.totalPagesAvailable - 1) / this.props.totalPages * 100 + \"%\"}}></span>\n        </span>\n      </div>\n    )\n  }\n}\n\n// The 'control bar', which appears at the top of the interface (with page numbers, group number etc).\nclass ControlBar extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state =  {\n      pageNumber: null, // The desired page number of the user (not necessarily the one they are currently on).\n      pageNumberError: false,\n    }\n    this.pageInputRef = React.createRef();\n  }\n\n  // clearPageNumberError() {\n  //   this.setState({\n  //     pageNumber: this.props.pageNumber,\n  //     pageNumberError: false,\n  //   })\n  // }\n\n  clearPageNumberInput() {\n    var ele = $(this.pageInputRef.current);\n    ele.val('');\n    ele.blur();\n  }\n\n  goToPage(e) {\n\n    this.clearPageNumberInput();\n    if(this.state.pageNumber === '') {\n      this.setState({ pageNumber: this.props.pageNumber })\n      e.preventDefault();\n      return null;\n    }\n\n    if(this.state.pageNumber < 1) {\n      this.setState({\n        pageNumber: 1,\n      }, () => { this.props.goToPage(this.state.pageNumber)});\n    } else if (this.state.pageNumber > this.props.totalPagesAvailable) {\n      this.setState({\n        pageNumber: this.props.totalPagesAvailable,\n      }, () => { this.props.goToPage(this.state.pageNumber)});\n    } else {\n      this.props.goToPage(this.state.pageNumber);\n    }\n \n\n    e.preventDefault();\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if(this.props.pageNumber !== prevProps.pageNumber) {\n      this.setState({\n        pageNumber: this.props.pageNumber\n      })\n    }\n  }\n\n\n  changePageNumber(e) {\n    this.setState({\n      pageNumber: e.target.value,\n    });\n  }\n\n  render() {\n\n    var groupName = (\n      <span className={\"group-name\" + (this.props.showingProgressBar ? \" progress-bar-underneath\" : \"\")}>\n        <span>Group <b>\n          <form onSubmit={this.goToPage.bind(this)}>\n          <input \n                 id=\"page-input\"\n                 className={\"page-input\" + (this.state.pageNumberError ? \" error\" : \"\")}\n                 placeholder={this.state.pageNumber}\n                 name=\"page-input\"\n                 onChange={(e) => this.changePageNumber(e)}\n                 ref={this.pageInputRef}\n                 />\n          </form>\n          \n        </b> of <b>{this.props.totalPages}</b></span>\n      </span>\n    );\n\n    var latestGroup = (this.props.totalPagesAvailable) === this.props.pageNumber // Whether the user is looking at the latest group, that they have not yet annotated\n\n    var lastModified = this.props.changesMade ? (this.props.saving ? \"\" : \"Changes not saved\") : (this.props.lastModified ? \"Saved on \" + dateFormat(this.props.lastModified, 'dd mmm') + ' at ' + dateFormat(this.props.lastModified, 'h:MM tt') : \"\");\n\n    return (\n      <div id=\"pagination\">\n        <div className=\"page-button-container previous-page\">\n          <button className={(this.props.pageNumber === 1 ? \" disabled\" : \"\")} onClick={this.props.loadPreviousPage}><i className=\"fa fa-chevron-left\"></i>Prev\n          </button>\n        </div>\n        <div className=\"filler-left\"></div>\n        <div className=\"current-page-container\">\n          { groupName }\n          <ProgressBar \n            show={this.props.showingProgressBar}\n            totalPagesAvailable={this.props.totalPagesAvailable}\n            totalPages={this.props.totalPages}\n          />\n        </div>\n        <div className=\"group-last-modified\">{lastModified }</div>\n        <div className=\"page-button-container \"><SaveButton changesMade={this.props.changesMade} recentlySaved={this.props.recentlySaved} saving={this.props.saving} submitAnnotations={this.props.submitAnnotations}  /></div>\n        <div className=\"page-button-container next-page\">\n          <button className={(latestGroup ? \" disabled\" : \"\")}  onClick={this.props.loadNextPage}>Next<i className=\"fa fa-chevron-right\"></i></button>\n        </div>              \n      </div>\n    )\n  }\n}\n\nclass TaggingCompletePage extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-complete-message\">\n        <span class=\"tagging-complete-text\">\n          <h2>Annotation complete!</h2>\n          <p>Thank you for your participation in this project.</p>\n\n        </span>\n\n\n      </div>\n    )\n\n  }\n}\n\n// The app, which renders the navbar and the tagging interface inside a container.\nfunction App() {\n  return (    \n    <TaggingInterface/>   \n  );\n}\n\n\n\nexport default App;\n\n// Old code\n/* \n<div className=\"submit-annotations-container\">\n  <button className=\"submit-annotations-button\" onClick={this.submitAnnotations.bind(this)}>Submit annotations <i className=\"fa fa-chevron-right\"></i></button>\n</div>\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}