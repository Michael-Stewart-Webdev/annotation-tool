{"version":3,"sources":["favicon.png","App.js","serviceWorker.js","index.js"],"names":["module","exports","dateFormat","require","clearWindowSelection","window","getSelection","empty","removeAllRanges","document","selection","Navbar","id","className","href","src","logo","this","props","pageTitle","Component","Category","item","index","children","childItems","open","map","key","openedItems","has","full_name","onClick","hotkeyMap","hotkeyChain","isTopLevelCategory","applyTag","hasHotkey","hasOwnProperty","hotkeyStr","join","content","data-hotkey-id","name","toString","draggableId","provided","snapshot","ref","innerRef","draggableProps","isDragging","colorId","dragHandleProps","CategoryHierarchy","state","itemOrder","orderedItems","Set","onDragEnd","bind","prevProps","prevState","t","Array","items","length","i","setupItemOrder","_","isEqual","setState","delete","add","result","destination","list","startIndex","endIndex","from","splice","removed","reorder","source","order","getOrderedItems","initHotkeyMap","droppableId","droppableProps","isDraggingOver","toggleCategory","placeholder","getColourIdx","entityClass","entityColourMap","split","slice","Label","colourIdx","e","deleteTag","Word","selected","hasLabel","annotation","tagClass","bioTag","isLastInSpan","labels","entityClasses","onMouseUp","updateSelections","onMouseDown","text","ConfidenceButton","docIdx","value","checked","updateConfidence","title","ConfidenceButtons","confidence","DocumentContainer","displayIndex","words","annotations","selections","Sentence","wordIndex","action","node","$","domtoimage","toBlob","filter","classList","contains","bgcolor","then","blob","saveAs","isWordSelected","wordEndIndex","wordStartIndex","word","saveToPng","nextNode","hasChildNodes","firstChild","nextSibling","parentNode","HotkeyInfo","ec","undefined","chain","Annotation","token","tokenIndex","spanText","spanStartIdx","spanEndIdx","alreadyHasLabel","indexOf","push","otherAnnotation","console","log","WikipediaSummary","visible","querying","wikipediaSummary","wikipediaReadMoreUrl","tokens","next","snippet","wurl","wikipediaTitle","toLowerCase","ajax","url","data","srsearch","format","dataType","success","query","search","replace","err","getResult","queryWikipedia","summary","style","target","toggleVisibility","TaggingInterface","project_id","documentGroup","categoryHierarchy","pageNumber","annotatedDocGroups","documentGroupAnnotationId","confidences","getEmptySelectionsArray","currentSelection","getEmptyCurrentSelection","mostRecentSelectionText","reverseHotkeyMap","hotkeyBindingFn","hotkeyTimeoutFn","holdingCtrl","holdingShift","docGroupLastModified","totalPages","changesMade","recentlySaved","selectionChangeFn","windowMouseUpFn","loading","saving","firstLoad","showingProgressBar","sel","rangeCount","r","range","startContainer","endNode","endContainer","rangeNodes","commonAncestorContainer","unshift","getRangeSelectedNodes","getRangeAt","removeClass","find","addClass","sentenceIndex","removeEventListener","selectionChange","windowMouseUp","addEventListener","preventDefault","moveSelectionHorizontally","moveSelectionVertically","hotkeyChainStr","clearTimeout","keyCode","prototype","concat","setTimeout","hotkeyTimeout","bindHotkeys","traverseChild","child","hotkeys","firstPass","Math","min","buildReverseHotkeyMap","setupHotkeyKeybinds","documents","automaticAnnotations","doc_idx","token_idx","parseInt","mention_idx","mention","start","end","label_idx","label","k","addLabel","ec_idx","each","ele","width","offsetWidth","newWidth","ceil","css","nextPageNumber","queryAPI","fetchConfig","method","headers","route","fetch","response","d","JSON","parse","alert","initEntityColourMap","initConfidencesArray","initAnnotationsArray","lastModified","initKeybinds","initMouseEvents","clearWordJustification","justifyWords","selectFirstWord","scrollTo","annotationsJSON","docLabels","ann","csrfToken","cookieValue","cookie","cookies","trim","substring","decodeURIComponent","getCookie","annotationsToJSON","body","stringify","documentGroupId","newTotalPages","Date","now","pathname","location","direction","j","max","numDocs","clearSelections","s","sel_idx","annotationSpanStart","annotationSpanEnd","notAllEqual","removeAllLabels","x","setSpanEndIdx","setSpanStartIdx","changeBioTag","ann_idx","labelWasModified","captureEvent","spanStart","spanEnd","removeLabel","eventAction","event","groupName","docGroupsPerUser","latestGroup","saveButton","submitAnnotations","progressBar","projectName","class","loadPreviousPage","loadNextPage","doc","App","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3c1e29e2.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","import React from 'react';\nimport logo from './favicon.png'\nimport './stylesheets/stylesheet.scss';\nimport {Component} from 'react';\nimport $ from 'jquery';\n//const ReactDragListView = require('react-drag-listview');\nimport { DragDropContext, Droppable, Draggable } from \"react-beautiful-dnd\";\nimport styled from 'styled-components';\nimport _ from 'underscore';\n\nimport html2canvas from 'html2canvas';\nimport { saveAs } from 'file-saver';\nimport domtoimage from 'dom-to-image';\nvar dateFormat = require('dateformat');\n\n// https://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\nfunction clearWindowSelection() {\n  if (window.getSelection) {\n    if (window.getSelection().empty) {  // Chrome\n      window.getSelection().empty();\n    } else if (window.getSelection().removeAllRanges) {  // Firefox\n      window.getSelection().removeAllRanges();\n    }\n  } else if (document.selection) {  // IE?\n    document.selection.empty();\n  }\n}\n\n\n// Function for getting value from a cookie\nfunction getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\n\n\n\n\n// The navbar, which appears at the top of the page.\nclass Navbar extends Component {\n  render() {\n    return (\n      <nav id=\"navbar\">\n        <div className=\"navbar-left\">\n          <div id=\"logo\">\n            <a href=\"/redcoat\">\n              <span className=\"inner\">\n                <span className=\"img\">\n                  <img src={logo}/>\n                </span>\n                <span>Redcoat</span>\n              </span>\n            </a>\n          </div>\n        </div>\n        <div className=\"navbar-centre\">{this.props.pageTitle}</div>\n        <div className=\"navbar-right\">\n          <div className=\"dropdown-menu short\">\n            <a href=\"features\">v1.0</a>\n          </div>\n        </div>\n      </nav>\n    )\n  }\n}\n\n// A single category in the category hierarchy tree.\nclass Category extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    var item = this.props.item;\n    var index = this.props.index;\n    var children = this.props.item.children;\n\n    // If this component has any children, render each of them.\n    if(children) {\n      var childItems = (\n        <ul className={this.props.open ? \"\" : \"hidden\"}>\n          { children.map((item, index) => (\n            <Category key={index}\n                      item={item}\n                      open={this.props.openedItems.has(item.full_name)}\n                      openedItems={this.props.openedItems}\n                      onClick={this.props.onClick}\n                      hotkeyMap={this.props.hotkeyMap}\n                      hotkeyChain={this.props.hotkeyChain}\n                      isTopLevelCategory={false}\n                      applyTag={this.props.applyTag}\n            />)) }\n        </ul>\n      );\n    } else {\n      var childItems = '';\n    }\n\n    // Determine whether this category has a hotkey (by checking hotkeyMap).\n    // Also determine hotkeyStr (for example '12' for 'item/pump').\n    var hasHotkey = this.props.hotkeyMap.hasOwnProperty(this.props.item.full_name)\n    var hotkeyStr = hasHotkey ? this.props.hotkeyMap[this.props.item.full_name].join('') : '';\n\n    var content = (\n      <span className=\"inner-container\">\n        \n         {children && <span className=\"open-button\" onClick={() => this.props.onClick(item.full_name)}><i className={\"fa fa-chevron-\" + (this.props.open ? \"up\" : \"down\")}></i></span>}\n       \n        <span className={\"category-name\" + (hasHotkey ? \" has-hotkey\" :\"\") + (this.props.hotkeyChain === hotkeyStr ? \" hotkey-active\" : \"\")}\n              data-hotkey-id={hotkeyStr} onClick={() => this.props.applyTag(this.props.item.full_name)}>             \n\n          {item.name}\n        </span>\n      </span>      \n    )\n\n\n    // This component will render differently depending on whether it is a top-level category or not.\n    // Top level categories have the drag handle, which requires a different configuration on the wrapper and li.\n    if(this.props.isTopLevelCategory) {\n      return (\n        <Draggable key={item.id.toString()} draggableId={item.id.toString()} index={index}>\n          {(provided, snapshot) => (\n            <li ref={provided.innerRef} {...provided.draggableProps} className={\"draggable \" + (snapshot.isDragging ? \"dragging\": \"not-dragging\") + \" color-\" + (item.colorId + 1)}>\n              <div {...provided.dragHandleProps} className=\"drag-handle-container\"><span className=\"drag-handle\"></span></div>\n              \n              { content }\n              { childItems }\n              \n            </li>\n          )}\n        </Draggable>\n      )\n    } else {\n      return (\n        <li>\n          { content }\n          { childItems }\n        </li>\n      )\n    }\n  }\n}\n\n\n\n// https://codesandbox.io/s/k260nyxq9v?file=/index.js:154-2795\n// a little function to help us with reordering the result\nconst reorder = (list, startIndex, endIndex) => {\n  const result = Array.from(list);\n  const [removed] = result.splice(startIndex, 1);\n  result.splice(endIndex, 0, removed);\n\n  return result;\n};\n\n\n\n// Retrieve a list of ordered items based on an order array.\nfunction getOrderedItems(items, order) {\n  var orderedItems = new Array(items.length);\n  for(var i = 0; i < order.length; i++) {\n    orderedItems[i] = items[order[i]];\n  }\n  return orderedItems;\n}\n\n// The category hierarchy (on the left).\nclass CategoryHierarchy extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      itemOrder: [],      // An array that maintains the ordering of the top-level categories.\n                          // e.g. [0, 1, 3, 2]\n      orderedItems: [],\n      openedItems: new Set(),    // An set keep track of the items that have been open (indexed by name).\n    }\n    this.onDragEnd = this.onDragEnd.bind(this);\n  }\n\n  // When this component's items changes (should be when a new docGroup has been requested), setup a new itemOrder state.\n  // (which defaults to ascending order e.g. 0, 1, 2, 3, 4 ...)\n  componentDidUpdate(prevProps, prevState) {\n    var t = this;\n    function setupItemOrder() {\n      var itemOrder = new Array(t.props.items.length);\n      for(var i = 0; i < itemOrder.length; i++) {\n        itemOrder[i] = i;\n      }\n      return itemOrder;\n    }\n    \n    var itemOrder = setupItemOrder();\n    if(!_.isEqual(prevProps.items, this.props.items)) {\n      this.setState({\n        openedItems: new Set(),\n        orderedItems: this.props.items,\n        itemOrder: itemOrder,\n      });\n    }\n  }\n\n  // Open or close a category.\n  // It's pretty awkward that this function is necessary. It would be ideal to store 'open' as a state variable inside the Category and Subcategory\n  // components, but that results in the wrong categories being open when the top-level categories are moved around.\n  // Storing them in the openedItems array in this component's state allows for the opened categories to be maintained when the user\n  // drags a category from one place to another.\n  // full_name should be the full name of the category, e.g. item/pump/centrifugal_pump, which are unique.\n  toggleCategory(full_name) {\n    var openedItems = this.state.openedItems;    \n\n    if(openedItems.has(full_name)) {\n      openedItems.delete(full_name);\n    } else {\n      openedItems.add(full_name);\n    }\n\n    this.setState({\n      openedItems: openedItems\n    })\n  }\n\n  // When the user has finished dragging a category, determine the new item order and save this order to the state.\n  onDragEnd(result) {\n    // dropped outside the list\n    if (!result.destination) {\n      return;\n    }\n\n    const itemOrder = reorder(\n      this.state.itemOrder,\n      result.source.index,\n      result.destination.index\n    );\n\n    var orderedItems = getOrderedItems(this.props.items, itemOrder)\n\n    this.props.initHotkeyMap(orderedItems, () =>\n      this.setState({\n        itemOrder: itemOrder,\n        orderedItems: orderedItems,\n      })\n    );\n  }\n\n  \n  render() {\n\n    var items       = this.state.orderedItems;\n    var openedItems = this.state.openedItems;\n\n    return (\n      <div id=\"category-hierarchy-tree\">\n        <DragDropContext onDragEnd={this.onDragEnd}>\n          <Droppable droppableId=\"droppable\">\n            {(provided, snapshot) => (\n              <ul\n                {...provided.droppableProps}\n                className={\"draggable-list\" + (snapshot.isDraggingOver ? \" dragging\" : \"\")}\n                ref={provided.innerRef}\n\n              >\n                {items.map((item, index) => (\n                  <Category \n                            key={index}\n                            item={item}\n                            index={index}\n                            onClick={this.toggleCategory.bind(this)}\n                            open={openedItems.has(item.name)} \n                            openedItems={this.state.openedItems} \n                            hotkeyMap={this.props.hotkeyMap}\n                            hotkeyChain={this.props.hotkeyChain}\n                            isTopLevelCategory={true}\n                            applyTag={this.props.applyTag}\n                  />\n                ))}\n                {provided.placeholder}\n              </ul>\n            )}\n          </Droppable>\n        </DragDropContext>\n      </div>\n    );\n  }\n}\n\n\n// Returns the colour id of the given entityClass according to the entityColourMap, e.g.\n// 'item/pump': 1 (because \"item\" is the top level category)\nfunction getColourIdx(entityClass, entityColourMap) {\n  var baseClass = entityClass.split(\"/\").slice(0, 1)[0];\n  return entityColourMap[baseClass];\n}\n\n// A label, drawn underneath a word.\nclass Label extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <span className={\"label tag-\" + this.props.colourIdx} onClick={(e) => {this.props.deleteTag(this.props.entityClass);  }}><span className=\"label-name\">{this.props.entityClass}</span></span>\n    )\n  }\n}\n\n// A single word (or token) in the tagging interface.\nclass Word extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: false,\n    }\n  }\n\n  // Calls this.props.deleteTag with the index of this word as a parameter.\n  deleteTag(entityClass) {\n    this.props.deleteTag(this.props.index, entityClass);\n  }\n\n  render() {\n\n    var hasLabel = this.props.annotation.hasLabel();\n\n    var tagClass = hasLabel ? (\" tag \" + ((this.props.annotation.bioTag === \"B\") ? \"tag-begin\" : \"\") + (this.props.annotation.isLastInSpan() ? \" tag-end\" : \"\")) : \"\";\n\n    if(hasLabel) {\n      var labels = this.props.annotation.entityClasses.map((entityClass, i) => \n                  <Label deleteTag={this.deleteTag.bind(this)} key={i} bioTag={this.props.annotation.bioTag} entityClass={entityClass} colourIdx={getColourIdx(entityClass, this.props.entityColourMap)} />\n                  )\n      \n    } else {\n      var labels = '';\n    }\n\n    return (\n      <span className={\"word\" + (this.props.selected ? \" selected\" : \"\") + tagClass}\n        \n        >\n        <span className=\"word-inner\"\n              onMouseUp=  {() => this.props.updateSelections(this.props.index, 'up')}\n              onMouseDown={() => this.props.updateSelections(this.props.index, 'down')}>\n          {this.props.text}\n        </span>\n        { labels }\n      </span>\n    );\n  }\n}\n\n\n// A single confidence button, which may have the value 'low' 'medium' or 'high'.\nclass ConfidenceButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    var docIdx = this.props.docIdx;\n    var value = this.props.value;\n    return (\n      <span className={\"confidence-button conf-\" + value + (this.props.checked ? \" checked\" : \"\")}\n            onClick={() => this.props.updateConfidence(docIdx, value)} title={\"Assign a \" + value + \" confidence to this document.\"} ></span>\n    )\n  }\n}\n\n\nclass ConfidenceButtons extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div className={\"confidence-buttons\"}>\n        <ConfidenceButton value=\"low\"    checked={this.props.confidence === \"low\"} { ...this.props }/>\n        <ConfidenceButton value=\"medium\" checked={this.props.confidence === \"medium\"} { ...this.props }/>\n        <ConfidenceButton value=\"high\"   checked={this.props.confidence === \"high\"} { ...this.props }/>        \n      </div>\n    )\n  }\n}\n\n// A document container, which contains the sentence index (on the left), the sentence, and the confidence buttons.\nclass DocumentContainer extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    return (\n      <div className={\"document-container\" + (this.props.confidence ? \" conf conf-\" + this.props.confidence : \"\")}>\n        <div className=\"document\">\n          <div className=\"sentence-index\"><span className=\"inner\">{this.props.displayIndex}</span></div>\n          <Sentence \n            index={this.props.index}\n            words={this.props.words}              \n            annotations={this.props.annotations}  \n            selections={this.props.selections}\n            updateSelections={this.props.updateSelections}\n            entityColourMap={this.props.entityColourMap}\n            deleteTag={this.props.deleteTag}\n          />\n          <ConfidenceButtons docIdx={this.props.index} confidence={this.props.confidence} updateConfidence={this.props.updateConfidence}/>\n        </div>\n      </div>\n    )\n  }\n\n}\n\n\n\n// A sentence in the tagging interface.\nclass Sentence extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  // Call the updateSelections function of the parent of this component (i.e. TaggingInterface), with this sentence's index included.\n  updateSelections(wordIndex, action) {\n    this.props.updateSelections(this.props.index, wordIndex, action)\n  }\n\n  deleteTag(wordIndex, entityClass) {\n    this.props.deleteTag(this.props.index, wordIndex, entityClass);\n  }\n\n  // Saves this sentence to a PNG file. wow!\n  saveToPng() {\n    var t = this;\n    var node = $(\"#sentence-tagging .sentence\")[this.props.index + 1];\n\n    function filter(node) {\n      if(node.classList) {\n        return !node.classList.contains('save-to-png');\n      }\n      return node;\n    }\n\n    domtoimage.toBlob(node, {filter: filter, bgcolor: '#fefefe'})\n    .then(function(blob) {\n      saveAs(blob, \"document-\" + t.props.index + \".png\"); \n    });\n\n  }\n\n  render() {\n\n    var selections = this.props.selections;\n\n    // Check props.selections to determine whether the word with a given index in this sentence is selected.\n    // This is passed to the word as a prop so that it can be highlighted accordingly.\n    function isWordSelected(wordIndex) {      \n      if(selections.length === 0) return false;     \n      for(var i = 0; i < selections.length; i++) {\n        var selection = selections[i];\n        if(selection.wordEndIndex < 0) continue;\n        if(selection.wordEndIndex >= wordIndex && wordIndex >= selection.wordStartIndex ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return (\n      <div className=\"sentence\">\n        { this.props.words.map((word, i) => \n          <Word key={i}\n                index={i}\n                text={word}\n                selected={isWordSelected(i)}\n                annotation={this.props.annotations[i]}\n                updateSelections={this.updateSelections.bind(this)}\n                entityColourMap={this.props.entityColourMap}\n                deleteTag={this.deleteTag.bind(this)}\n          />)\n        }   \n        <div className=\"save-to-png\" onClick={this.saveToPng.bind(this)} title=\"Click to download a .png file of this document\"><i className=\"fa fa-download\"></i></div>     \n      </div>\n    );\n  }\n\n}\n\n\n// A simple function for traversing a list of nodes. Goes with the function below.\n// Both functions found on StackOverflow: https://stackoverflow.com/questions/7781963/js-get-array-of-all-selected-nodes-in-contenteditable-div\nfunction nextNode(node) {\n    if (node.hasChildNodes()) {\n        return node.firstChild;\n    } else {\n        while (node && !node.nextSibling) {\n            node = node.parentNode;\n        }\n        if (!node) {\n            return null;\n        }\n        return node.nextSibling;\n    }\n}\n\n// A function for traversing the nodes present in the range object, which allows us to determine all html nodes\n// corresponding to selected items (items in which part of them are highlighted).\n// Note that you can't see the highlighted text on the screen because it has been hidden by css.\nfunction getRangeSelectedNodes(range) {\n    var node = range.startContainer;\n    var endNode = range.endContainer;\n\n    // Special case for a range that is contained within a single node\n    if (node == endNode) {\n        return [node.parentNode];\n    }\n\n\n    // Iterate nodes until we hit the end container\n    var rangeNodes = [];\n    while (node && node != endNode) {\n        rangeNodes.push( node = nextNode(node) );\n    }\n\n    // Add partially selected nodes at the start of the range\n    node = range.startContainer;\n    while (node && node != range.commonAncestorContainer) {\n        rangeNodes.unshift(node);\n        node = node.parentNode;\n    }\n\n    return rangeNodes;\n}\n\n\n\n// A simple class for displaying information related to the hotkeys the user is currently pressing.\nclass HotkeyInfo extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var ec = this.props.entityClass;\n    if(ec === undefined) {\n      ec = '(not a valid class)';\n    }\n\n    return (\n      <div className={\"hotkey-info\" + (this.props.chain.length === 0 ? \" hidden\": \"\")}>\n        <span className=\"chain\">{this.props.chain}</span>: <span>{ec}</span>\n      </div>\n    )\n\n  }\n}\n\n\n// A class to store an annotation for a single token.\n// Seemed more logical to put all the annotation logic in one class rather than sticking it in the TaggingInterface component.\n// Each sentence will have one Annotation object per token.\n// Properties:\n/* \n   token: the token e.g. 'centrifugal'\n   tokenIndex: the index of the token in the sentence\n   bioTag: the BIO tag ('B', 'I' or 'O')\n   entityClasses: the array of entity classes AKA labels (e.g. ['Item', 'Item/Pump'])   \n   spanText: the text of the span that this annotation is within (e.g. 'centrifugal pump')\n   spanStartIdx: the start index of the span this annotation is in, e.g. 0 if it starts at the first word of the sentence\n   spanEndIdx: the end index as above, e.g. 1,\n*/\nclass Annotation {\n  constructor(token, tokenIndex) {\n    this.token = token;\n    this.tokenIndex = tokenIndex;\n    this.bioTag = \"O\";    \n  }\n\n  // Adds the specified entityClass to this annotation.\n  // bioTag: The bioTag, e.g. \"B\" or \"I\",\n  // entityClass: The entity class, e.g. \"Item/Pump\"\n  // text: The text of the span that this annotation is inside, e.g. \"centrifugal pump\".\n  // spanStartIdx, spanEndIdx: self explanatory (as above)\n  // nextAnnotation: The Annotation object for the next token in the sentence.\n  //                 When called during the dictionary annotation tagging, nextAnnotation is not necessary.\n  // Returns whether the label of this annotation was modified at all.\n  addLabel(bioTag, entityClass, spanText, spanStartIdx, spanEndIdx) {\n    \n    if(this.entityClasses === undefined) this.entityClasses = new Array();\n\n    var alreadyHasLabel = this.entityClasses.indexOf(entityClass) !== -1;\n    if(this.bioTag === bioTag && this.spanText === spanText && this.spanStartIdx === spanStartIdx && this.spanEndIdx === spanEndIdx && alreadyHasLabel) {\n      return false;\n    }\n\n    // Adjust the span.\n    this.bioTag = bioTag;\n    this.spanText = spanText;\n    this.spanStartIdx = spanStartIdx;\n    this.spanEndIdx = spanEndIdx;\n\n    // Add the entityClass to the entityClasses array for this Annotation.\n    // If it is already there, don't add it again.\n    if(!alreadyHasLabel) {\n      this.entityClasses.push(entityClass);\n    }\n    return true;\n  \n    // If the nextAnnotation is from the same mention (AKA span) as this one, and does not have exactly the same labels after\n    // the new class has been appended to this annotation's entityClasses, change its BIO tag to B.\n    // This is the part that ensures mentions are split up when the user changes the label of token(s) inside that mention.\n    // if(nextAnnotation) {\n    //   if(this.sameMention(nextAnnotation) && !this.sameEntityClasses(nextAnnotation) && nextAnnotation.hasLabel()) {\n    //     console.log(\"Changing bio tag to B\")\n    //     nextAnnotation.changeBioTag(\"B\");\n    //     nextAnnotation.setSpanStartIdx(spanEndIdx + 1)          \n    //   }\n    // }\n\n    // If the previous annotation is from the same mention as this one, and now no longer has the same labels,\n    // adjust the spanEndIdx to be the start of this new span -1.\n    // This ensures the tags are rendered correctly in the browser.\n    // Note that this seems to get called multiple times when applying tags because they are applied in reverse order,\n    // but the spanEndIdx will be set as below for the next annotation anyway so that shouldn't be an issue.\n    // if(prevAnnotation) {\n    //   if(this.sameMention(prevAnnotation) && !this.sameEntityClasses(prevAnnotation) && prevAnnotation.hasLabel()) {  \n    //     prevAnnotation.setSpanEndIdx(spanStartIdx - 1);\n    //   }\n    // }\n  }\n\n  removeAllLabels() {\n    delete this.entityClasses;\n    delete this.spanText;\n    delete this.spanStartIdx;\n    delete this.spanEndIdx;\n    this.bioTag = \"O\";\n  }\n\n  // Simple function to determine whether this annotation is in the same mention as another annotation.\n  sameMention(otherAnnotation) {\n    return otherAnnotation.spanStartIdx === this.spanStartIdx && otherAnnotation.spanEndIdx === this.spanEndIdx;\n  }\n\n  // Determine whether this annotation has the same labels as another annotation.\n  sameEntityClasses(otherAnnotation) {\n    return _.isEqual(this.entityClasses, otherAnnotation.entityClasses);\n  }\n\n  // Removes a label from this annotation.\n  // If it was the last label, reset this annotation's bioTag to \"O\" and delete the entityClasses and text properties.\n  removeLabel(entityClass) {\n    var index = this.entityClasses.indexOf(entityClass);\n    if(index === -1) {\n      console.log(\"Warning: tried to remove an entity class from an annotation that did not exist.\")\n      return;\n    }\n    this.entityClasses.splice(index, 1);\n    if(this.entityClasses.length === 0) {\n      this.bioTag = \"O\";\n      delete this.entityClasses;\n      delete this.spanText;\n      delete this.spanStartIdx;\n      delete this.spanEndIdx;\n    }\n  }\n\n  // Change the bio tag of this annotation to another bio tag.\n  changeBioTag(bioTag) {\n    this.bioTag = bioTag;\n  }\n\n  // Returns whether this annotations has a label.\n  hasLabel() {\n    return this.bioTag !== \"O\";\n  }\n\n  // Determines whether this annotation is the last of its type in the given span.\n  isLastInSpan() {\n    return this.spanEndIdx === this.tokenIndex;\n  }\n\n  setSpanStartIdx(spanStartIdx) {\n    this.spanStartIdx = spanStartIdx;\n  }\n\n  setSpanEndIdx(spanEndIdx) {\n    this.spanEndIdx = spanEndIdx;\n  }\n\n  // Prints this annotation nicely to the console (for debugging).\n  prettyPrint() {\n    console.log(\"Token:    \", this.token);\n    console.log(\"BIO Tag:  \", this.bioTag)\n    console.log(\"Span:     \", this.spanText)\n    console.log(\"StartIdx: \", this.spanStartIdx)\n    console.log(\"EndIdx: \", this.spanEndIdx)\n    console.log(\"Classes:  \\n\", this.entityClasses);\n    console.log('\\n');\n  }\n}\n\n// A debug printing function for printing out a list of annotations for a document.\nfunction prettyPrintAnnotations(documentAnnotations) {\n  console.log(\"Annotations:\\n\")\n  console.log(\"=====================\")  \n  for(var token_idx in documentAnnotations) {\n    documentAnnotations[token_idx].prettyPrint();\n  }\n}\n\nclass WikipediaSummary extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      visible: true,\n      querying: false, // Currently in the middle of a query\n      wikipediaSummary: null,\n      wikipediaReadMoreUrl: null,\n    }\n  }\n\n  queryWikipedia() {\n\n    var tokens = this.props.tokens;\n\n    // Query Wikipedia for the currently selected tokens.\n    function runQuery(next) {\n\n      // Processes the result of a Wikipedia query.\n      function getResult(data, next) {\n        function stripTags(str) {\n          return str.replace(/<\\/?[^>]+(>|$)/g, \"\");\n        }\n        try {\n          var title = data.query.search[0].title;\n          var snippet = stripTags(data.query.search[0].snippet);\n          var wurl = \"https://en.wikipedia.org/wiki/\" + data.query.search[0].title.replace(/ /g, '_');\n          return next(title, snippet, wurl);\n        } catch(err) {\n          // console.log(\"No article found.\");\n          next();\n        }\n      }\n      $.ajax({\n        url: 'https://en.wikipedia.org/w/api.php',\n        data: { action: 'query', list: 'search', srsearch: tokens, format: 'json' },\n        dataType: 'jsonp',\n        success: function(data) {\n          getResult(data, next);\n        }\n      });\n    } \n\n    this.setState({\n      querying: true\n    }, () => {\n      var wikipediaSummary, wikipediaReadMoreUrl;\n      var t = this;\n\n      runQuery(function(title, snippet, wurl) {\n        var wikipediaTitle = tokens;\n        if(snippet) {        \n          if(title.toLowerCase() !== tokens.toLowerCase()) {\n            wikipediaTitle = title;\n          }\n          wikipediaSummary = snippet + \"...\";\n          wikipediaReadMoreUrl = wurl;\n        } else {\n          wikipediaReadMoreUrl = null;\n          wikipediaSummary = null;  \n        }      \n\n        t.setState({\n          wikipediaTitle: wikipediaTitle,\n          wikipediaSummary: wikipediaSummary,\n          wikipediaReadMoreUrl: wikipediaReadMoreUrl,\n          querying: false,\n        })  \n      });\n\n    });\n  }\n\n  toggleVisibility() {\n    this.setState({\n      visible: !this.state.visible\n    })\n  }\n\n\n  componentDidUpdate(prevProps, prevState) {\n    if(prevProps.tokens !== this.props.tokens) {\n      this.queryWikipedia();\n    }\n  }\n\n  render() {    \n\n    if(!this.state.querying && this.state.wikipediaTitle && this.state.wikipediaTitle !== this.props.tokens) {\n      var title = <span className=\"different\">[{this.state.wikipediaTitle}] </span>\n    } else {\n      title = '';\n    }\n\n    var summary = this.state.wikipediaSummary ? this.state.wikipediaSummary : \"(no Wikipedia entry)\";\n    if(!this.props.tokens) {\n      summary = \"Select one or more words to automatically look them up on Wikipedia.\";\n    }\n    if(this.state.querying) {\n      summary = <span><i className=\"fa fa-spin fa-cog\"></i>&nbsp;&nbsp;Loading...</span>\n    }\n\n    // Rendering is a bit awkward, this could be tidied up\n    return (\n      <div className=\"tokens-info\">\n        <div id=\"wikipedia-summary-container\" className={this.state.visible ? \"show\" : \"hidden\"}>\n          <p className=\"tokens\">{this.props.tokens || 'Wikipedia lookup'}</p>\n          <p className=\"summary\">{ title }{ summary }</p>\n          <span className=\"more show\">\n            {(this.state.querying || !this.props.tokens) && <span className=\"left\" style={{\"color\": \"rgba(0, 0, 0, 0)\"}}>.</span>}\n            {!this.state.querying && this.props.tokens && <span className=\"left\">Results from Wikipedia</span>}\n            <span className=\"right\">\n              { !this.state.querying && this.props.tokens && <a id=\"ec-read-more\" href={this.state.wikipediaReadMoreUrl} target=\"_blank\">Read more <i className=\"fa fa-sm fa-external-link\"></i></a> } \n            </span>\n          </span>\n        </div>\n        <button id=\"wikipedia-hide-show\" className={this.state.visible ? \"up\" : \"down\"} onClick={this.toggleVisibility.bind(this)}>Show</button>\n      </div>\n    )\n  }\n}\n\n// The TaggingInterface class. Contains the vast majority of the logic for the interface.\nclass TaggingInterface extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      project_id: 'RtJp98vxk', // debug\n\n      // Data (from the server)\n      // The data in this object is only changed by calling the queryAPI method.\n      data: {\n        documentGroup: [],\n        categoryHierarchy: {'children': []},\n        pageNumber: -1,\n        annotatedDocGroups: -1,\n      },\n\n      documentGroupAnnotationId: null, // The ID of the document group annotation object related to the document group the user is currently\n                                       // looking at. Will be null if the doc group has not been annotated by the user yet.\n                                       // Will be set when querying the API (for a previously annotated document group) or when\n                                       // submitting the annotations of a document group via submitAnnotations().\n\n      // Annotations array\n      annotations: [],  // Stores the user's annotations.\n      confidences: [],  // Stores the user's confidences.\n\n      // Selections\n      selections: this.getEmptySelectionsArray(10),       // The selections is an array containing a sub-array for each document,\n                                                          // which in turn hold all of the current selections made by the user for that\n                                                          // document.\n      currentSelection: this.getEmptyCurrentSelection(),  // The current selection is for when the user clicks a word and is in the process\n                                                          // of selecting an end word. \n      mostRecentSelectionText: null, // Keeps track of the tokens that the user most recently selected (for Wikipedia querying)\n      // Hotkeys\n      hotkeyMap: {},  // Stores a mapping of hotkey to number, e.g. 'item/pump': '11'.\n      reverseHotkeyMap: {}, // Stores the reverse of the above (number to hotkey), e.g. '11': 'item/pump'.\n      hotkeyChain: [], // Stores the current hotkey chain, e.g. [1, 2, 3] = the user has pressed 1, then 2, then 3 in quick succession\n      hotkeyBindingFn: null,  // Stores the function that gets called via an eventlistener when a hotkey is pressed. Must be stored as a state\n                              // variable so that it can be detached when the hotkeys change.\n      hotkeyTimeoutFn: null,   // Stores the current hotkey timeout function.\n\n      // Key events\n      holdingCtrl: false, // Whether the user is currently holding the ctrl key.\n      holdingShift: false, // Whether the user is currently holding the shift key.\n\n      entityColourMap: {}, // A mapping of the top-level entity classes to a colour\n\n      docGroupLastModified: null, // Stores when the current document group was last saved.\n\n      pageNumber: -1,\n      totalPages: -1,\n\n      changesMade: false, // Stores whether the user has made any changes to the current document group.\n      recentlySaved: false, // Whether the doc group has been recently saved\n\n      selectionChangeFn: null,\n      windowMouseUpFn: null,\n\n      loading: {  // Stores whether this interface is currently requesting a docgroup from the server, or saving one\n        querying: true,\n        saving: false,\n        firstLoad: true,\n      },\n      showingProgressBar: false, // Whether the progress bar is currently visible\n\n    }    \n  }\n\n\n\n  // When the user highlights text anywhere on the page, this function captures the event.\n  // If the user never selected a word to begin with, nothing happens.\n  // All it does is apply the 'highlighted' class onto any words that were caught in the highlighting.\n  // This function is purely stylistic, i.e. it doesn't affect any other components etc.\n  selectionChange(e, words) {\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      return;\n    }\n    var sel = window.getSelection && window.getSelection();\n\n    if (sel && sel.rangeCount > 0) {\n      var r =  getRangeSelectedNodes(sel.getRangeAt(0));  \n      words.removeClass('highlighted');\n      $(r).find('.word-inner').addClass('highlighted');  \n    }\n  }\n\n  // When the user releases the mouse, remove all highlighting from words (i.e. the words in the selection).\n  // If the user never selected a word to begin with (i.e. wordStartIndex < 0), clear all selections.\n  windowMouseUp(e, words) {\n    words.removeClass('highlighted');\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      clearWindowSelection();\n      return;\n    }\n    if(!e.target.classList.contains('word-inner')) { // Ensure that the user is not hovering over a word            \n      var sentenceIndex = this.state.currentSelection.sentenceIndex;\n      this.updateSelections(sentenceIndex, this.state.data.documentGroup[sentenceIndex].length - 1, 'up');\n    } \n  }\n\n  /* Mouse and keyboard events */\n\n  // Set up some mouse events - one for when text is selected (highlighted) in the browser.\n  // Note that in order to see the default browser highlighting the CSS file needs to be modified (it makes it invisible).\n  // Another for when the user releases the mouse anywhere on the page.\n  // Note that the majority of the mouse events are not in this function but are passed down to the Word elements via updateSelections.\n  // The event listeners need to be removed and reapplied to prevent duplication.\n  initMouseEvents() {\n\n    var words = $('.word-inner');\n\n    var selectionChangeFn = (e) => this.selectionChange(e, words);\n    var windowMouseUpFn = (e) => this.windowMouseUp(e, words);\n    \n    // Remove the old event listeners.\n    document.removeEventListener(\"selectionchange\", this.state.selectionChangeFn);   \n    window.removeEventListener('mouseup', this.state.windowMouseUpFn);\n\n    this.setState({\n      selectionChangeFn: selectionChangeFn,\n      windowMouseUpFn: windowMouseUpFn\n    }, () => {\n      // Add the new event listeners.\n      document.addEventListener(\"selectionchange\", this.state.selectionChangeFn);\n      window.addEventListener('mouseup', this.state.windowMouseUpFn);\n    });    \n  }\n\n  // Set up the key binds (ctrl, shift, left right up down etc).\n  // This function does not set up the hotkeys (that is done via setupHotkeyKeybinds)\n  initKeybinds() {\n\n    document.addEventListener('keydown', (e) => {\n      switch(e.key) {\n        case 'Shift':       if(!this.state.holdingShift) this.setState({ holdingShift: true }); break;\n        case 'Control':     if(!this.state.holdingCtrl) this.setState({ holdingCtrl: true }); break;\n\n        // For the arrows, call e.preventDefault() to prevent the window from scrolling\n        case 'ArrowLeft':   e.preventDefault(); this.moveSelectionHorizontally('left'); break; \n        case 'ArrowUp':     e.preventDefault(); this.moveSelectionVertically('up'); break;\n        case 'ArrowRight':  e.preventDefault(); this.moveSelectionHorizontally('right'); break;\n        case 'ArrowDown':   e.preventDefault(); this.moveSelectionVertically('down'); break;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      switch(e.key) {\n        case 'Shift':   if(this.state.holdingShift) this.setState({ holdingShift: false }); break;\n        case 'Control': if(this.state.holdingCtrl) this.setState({ holdingCtrl: false }); break;\n      }      \n    });\n  }\n\n\n\n  /* Hotkey functions */\n\n  // When the user has pressed a hotkey that is not quickly followed up with another hotkey, this function is called.\n  // Apply the corresponding entity class and reset the hotkey chain.\n  hotkeyTimeout() {\n    var hotkeyChainStr = this.state.hotkeyChain.join('');\n    var entityClass = this.state.reverseHotkeyMap[hotkeyChainStr];\n    if(entityClass !== undefined) this.applyTag(entityClass);\n\n    // Clear the existing hotkey timeout fn.\n    window.clearTimeout(this.state.hotkeyTimeoutFn);\n    this.setState({\n      hotkeyTimeoutFn: null,      \n      hotkeyChain: [],\n    })\n  }\n\n  // This function is called when a hotkey is pressed.\n  // If a hotkey was pressed previously within 333ms, the chain will grow until the point the user no longer presses a hotkey\n  // for 333ms.\n  bindHotkeys(e, hotkeyMap) {\n    if(e.keyCode < 49 || e.keyCode > 57) return; // Hotkeys are in the range 1-9, which are keyCode 49-57.\n    var key = e.keyCode - 48;\n\n    // Update the hotkey chain to include the key that was pressed\n    var hotkeyChain = Array.prototype.concat(this.state.hotkeyChain, key);\n    this.setState({\n      hotkeyChain: hotkeyChain\n    }, () => {\n      // Remove the previous timeout and set up a new one\n      window.clearTimeout(this.state.hotkeyTimeoutFn);      \n      var hotkeyTimeoutFn = window.setTimeout(() => this.hotkeyTimeout(), 333);\n\n      this.setState({\n        hotkeyTimeoutFn: hotkeyTimeoutFn\n      });\n    });\n  }\n\n  // Assign keybinds to each of the hotkeys in the hotkey map.\n  setupHotkeyKeybinds() {\n    \n    console.log(\"Setting up hotkey keybinds...\")\n\n    // Clear the current hotkey binding function and set up a new one.\n    document.removeEventListener('keydown', this.state.hotkeyBindingFn);\n    var hotkeyBindingFn = (e) => this.bindHotkeys(e, this.state.hotkeyMap);\n\n    document.addEventListener('keydown', hotkeyBindingFn);\n\n    // Store the binding function in this.state so that it can be removed in subsequent calls of this function.\n    this.setState({\n      hotkeyBindingFn: hotkeyBindingFn,\n    });\n  }\n\n  // Builds the hotkey map according to the ordered category hierarchy, and saves it to this component's state.\n  // The hotkey map will change whenever the user changes the order of them items via drag and drop.\n  initHotkeyMap(orderedItems, next) {\n\n    console.log(\"Setting up hotkey map...\")\n    // Annoying that the following is a recursive function but I think it's the only way to do it.\n    // The result is a hotkeyMap as follows:\n    /*  {\n          'item': [1],\n          'item/pump': [1, 1],\n          'item/pump/centrifugal_pump': [1, 1, 1],\n          'item/pump/big_pump': [1, 1, 2],\n          'item/compressor': [1, 2],\n          'activity': [2]\n        }\n    */\n    function traverseChild(child, index, hotkeyMap, hotkeys, firstPass) {\n      if(!firstPass) {\n        hotkeyMap[child.full_name] = hotkeys;\n      }\n      if(child.children) {\n        for(var i = 0; i < Math.min(9, child.children.length); i++) { // Don't go past index 9 so that the hotkeys make sense\n          traverseChild(child.children[i], i + 1, hotkeyMap, Array.prototype.concat(hotkeys, i + 1));\n        }\n      }\n      return hotkeyMap;          \n    }    \n\n    // Build the reverse of the hotkeyMap, i.e. swap the keys with the values.\n    // This assists with the hotkey bindings function.\n    function buildReverseHotkeyMap(hotkeyMap) {\n      var reverseHotkeyMap = {};\n      for(var key in hotkeyMap){\n        var val = hotkeyMap[key].join('');\n        reverseHotkeyMap[val] = key;\n      }\n      return reverseHotkeyMap;    \n    }\n\n\n    var hotkeyMap = traverseChild({children: orderedItems}, 1, [], [], true);\n    var reverseHotkeyMap = buildReverseHotkeyMap(hotkeyMap);\n\n    // Once the hotkeyMap (and reverseHotkeyMap) has been created, set up the hotkey keybinds and call the callback fn.\n    this.setState({\n      hotkeyMap: hotkeyMap,\n      reverseHotkeyMap: reverseHotkeyMap\n    }, () => { this.setupHotkeyKeybinds(); if(next) next(); });\n  }\n\n\n  // Sets up an array to store the annotations with the same length as docGroup.\n  // Prepopulate the annotations array with the automaticAnnotations if available (after converting them to BIO).\n  // This could be either the dictionary-based annotations or the annotations that the user has previously entered.\n  initAnnotationsArray(documents, automaticAnnotations) {\n\n    var annotations = new Array(documents.length);\n    for(var doc_idx in documents) {\n      annotations[doc_idx] = new Array(documents[doc_idx].length);\n      for(var token_idx in documents[doc_idx]) {\n        annotations[doc_idx][token_idx] = new Annotation(documents[doc_idx][token_idx], parseInt(token_idx));\n      }\n    }\n\n    if(!automaticAnnotations) return annotations;\n\n    // Load annotations from the automaticAnnotations array if present.\n    for(var doc_idx in automaticAnnotations) {\n      for(var mention_idx in automaticAnnotations[doc_idx]['mentions']) {\n\n        var mention = automaticAnnotations[doc_idx]['mentions'][mention_idx];\n        var start = mention['start'];\n        var end = mention['end'];\n\n        for(var label_idx in mention['labels']) {\n          var label = mention['labels'][label_idx];\n\n          for(var k = start; k < end; k++) {\n            var bioTag = k === start ? 'B' : \"I\";\n            annotations[doc_idx][k].addLabel(bioTag, label, documents[doc_idx].slice(start, end).join(' '), start, end - 1)\n          }          \n        }\n      }        \n    }\n    return annotations;\n  }\n\n  // Initialise the confidences array.\n  initConfidencesArray(documents) {\n    var confidences = new Array(documents.length);\n    return confidences;\n  }\n\n  // Initialise the entity colour map, which maps entity_class: colour_index, e.g. \"Item\": 1. Passed to the Word components to colour\n  // their labels accordingly.\n  initEntityColourMap(categoryHierarchy) {\n    var entityColourMap = {}\n    for(var ec_idx in categoryHierarchy) {\n      var entityClass = categoryHierarchy[ec_idx];\n      entityColourMap[entityClass.name] = entityClass.colorId + 1;\n    }\n    return entityColourMap;\n  }\n\n\n  /* Miscellaneous */\n\n  // Justify the words to the nearest 25px (i.e. round their width up to the nearest 25px).\n  // Not really necessary but makes the diagonal stripey lines line up properly when multiple tokens are selected.\n  // I spent about 2 hours trying to figure out how to get the stripey lines to line up properly, this is the result :D\n  justifyWords() {\n    $('.word-inner').each((i, ele) => {\n      var width = ele.offsetWidth;\n      var newWidth = Math.ceil(width / 25) * 25;\n      $(ele).css('min-width', newWidth + 'px');\n    });\n  }\n\n  // Remove min-width from words that do not have a tag\n  // (necessary to call between pages)\n  clearWordJustification() {\n    $('.word:not(.tag) .word-inner').each((i, ele) => {\n       $(ele).css('min-width', 'auto');\n    })\n  }\n\n  // Load the next page by calling the API.\n  // Query without a page number (i.e. request the latest group)\n  // if the user is looking at the group before the latest group.\n  //\n  // TODO: Make it so that when the user has made a change to the group they're looking at,\n  // pop up a confirmation window to confirm their changes before loading the next page?\n  loadNextPage() {\n    var nextPageNumber = this.state.pageNumber + 1;\n    if(nextPageNumber === (this.state.totalPages)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, nextPageNumber);\n    }\n  }\n\n  // Load the previous page by calling the API.\n  loadPreviousPage() {\n    this.queryAPI(false, this.state.pageNumber - 1);\n  }\n\n  /* API calls */\n\n  queryAPI(firstLoad, pageNumber) {\n    const fetchConfig = {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }\n    };\n    var route = 'getDocumentGroup';\n\n    // If this function was called with a pageNumber, load a specific documentGroupAnnotation.\n    if(pageNumber) {\n      route = 'getPreviouslyAnnotatedDocumentGroup?pageNumber=' + pageNumber;\n    }\n\n    this.setState({\n      loading: {\n        querying: true,\n        saving: false,\n        firstLoad: firstLoad,\n      }\n    }, function() {\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/' + route, fetchConfig) // TODO: move localhost out\n        .then(response => response.text())\n        .then((data) => {         \n          try { \n            var d = JSON.parse(data);\n          } catch(err) {\n            alert(data);\n          }\n          this.setState(\n            {\n              data: d,\n              entityColourMap: this.initEntityColourMap(d.categoryHierarchy.children),\n              confidences: this.initConfidencesArray(d.documentGroup),\n              annotations: this.initAnnotationsArray(d.documentGroup, d.automaticAnnotations),\n              selections: this.getEmptySelectionsArray(d.documentGroup.length),\n              mostRecentSelectionText: null,\n              pageNumber: d.pageNumber,\n              totalPages: d.annotatedDocGroups + 1,\n              docGroupLastModified: d.lastModified,\n              documentGroupAnnotationId: d.documentGroupAnnotationId, // Will be null if this doc group has not yet been annotated\n              changesMade: false,\n              recentlySaved: false,\n              loading: {\n                querying: false,\n                saving: false\n              },              \n            }, () => { \n              console.log(\"Data:\", this.state.data);\n\n              // Initialise keybinds and mouse events only on the first API call.\n              if(firstLoad) {\n                this.initKeybinds();              \n                this.initHotkeyMap(this.state.data.categoryHierarchy.children);   \n              }\n\n              this.initMouseEvents();\n              this.clearWordJustification();    \n              this.justifyWords();    \n              this.selectFirstWord();\n\n              window.scrollTo(0, 0);\n\n\n\n            })\n        });\n        \n\n    }.bind(this));\n  }\n\n  // Convert the annotations array into JSON.\n  annotationsToJSON() {\n    var annotations = this.state.annotations;\n    var annotationsJSON = [];\n    for(var doc_idx in annotations) {\n        \n      var docLabels = [];\n      for(var token_idx in annotations[doc_idx]) {\n        var ann = annotations[doc_idx][token_idx];\n        if(ann.entityClasses) {\n          docLabels.push([ann.bioTag + \"-\", ann.entityClasses]);\n        } else {\n          docLabels.push([\"\"])\n        }\n      }\n      annotationsJSON.push(docLabels);\n    }\n    return annotationsJSON;\n  }\n\n\n  // Submit the annotations of the document group that the user is currently looking at.\n  // TODO: Maybe make it so that you can't save the annoations until the user has put all their confidences in?\n  // Or perhaps do a check and pop a confirmation window up if they click save without doing anything to >= 1 document\n  submitAnnotations() {\n    if(this.state.recentlySaved) { return; } // If the user clicks on the green save button, provide them with the illusion that it is doing\n                                             // something when in fact nothing actually happens. Prevents people from spam clicking the save and\n                                             // calling the API 5000 times...\n                                             // It's kind of like how google sheets allows you to press Ctrl + S despite it saving every action\n                                             // automatically.\n\n    const csrfToken = getCookie('csrf-token');\n\n    var annotationsJSON = this.annotationsToJSON();\n\n    const fetchConfig = {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'csrf-token': csrfToken,\n      },\n      dataType: \"json\",\n      body: JSON.stringify({\n        documentGroupId: this.state.data.documentGroupId,\n        documentGroupAnnotationId: this.state.documentGroupAnnotationId,\n        labels: annotationsJSON\n      }),  \n    };\n\n    fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/submitAnnotations', fetchConfig) // TODO: move localhost out\n    .then(response => response.text())\n    .then((data) => {\n      try { \n        var d = JSON.parse(data);\n\n        console.log(d);\n\n        var documentGroupAnnotationId = d.documentGroupAnnotationId;\n        console.log(\"Submitted annotations OK\");\n\n        // If the user is on the last page (i.e. the 'current group'), add one to the totalPages array so that the user can\n        // click 'Next' to go to the latest doc group.\n        if(this.state.pageNumber === this.state.totalPages) {\n          var newTotalPages = this.state.totalPages + 1;\n          this.setState({\n            showingProgressBar: true,\n          }, () => {\n            window.setTimeout(() => this.setState({\n              showingProgressBar: false,\n            }), 3000);\n          })\n\n        } else {\n          var newTotalPages = this.state.totalPages;\n        }\n\n        this.setState({\n           docGroupLastModified: Date.now(),\n           totalPages: newTotalPages,\n           changesMade: false,\n           recentlySaved: true,\n           documentGroupAnnotationId: documentGroupAnnotationId,\n        });\n      } catch(err) {\n        console.log(err);\n        alert(data);\n      }\n      \n      //this.queryAPI(this.state.data.pageNumber + 1);\n    });\n  }\n\n  /* Mounting function */\n\n  // When this component is mounted, call the API.\n  // Set up the keybinds and mouseup event when done.\n  componentWillMount() {\n\n    var pathname = window.location.pathname;\n    var project_id = pathname.split('/')[2];\n    if(pathname === \"/\") {\n      var project_id = '-krXeW3R2'; // React development\n    }\n    if(!project_id || project_id.length !== 9) {\n      alert(\"invalid project\");\n      return;\n    }\n\n\n\n    this.setState({\n      project_id: project_id\n    }, () => { this.queryAPI(true) });\n  }  \n\n  /* Selection functions */\n\n  // Get an empty current selection.\n  // Called when we need to clear the current selection.\n  getEmptyCurrentSelection() {\n    return {\n      wordStartIndex: -1,\n      wordEndIndex: -1,\n      sentenceIndex: -1\n    }\n  }\n\n  // Move the selection up or down.\n  // This function should be called when one of those keys is pressed.\n  moveSelectionVertically(direction) {\n    console.log(\"Moving\", direction) // TODO: Make this move up and down\n  }\n\n  // Move the selection in the specified direction ('left', 'right').\n  // This function should be called when one of those keys is pressed.\n  moveSelectionHorizontally(direction) {\n    console.log(\"Moving\", direction)\n\n    var selections = this.state.selections;\n    var mostRecentSelectionText;\n\n    // Move all selections left or right\n    for(var i = 0; i < selections.length; i++) {\n      for(var j = 0; j < selections[i].length; j++) {\n        var selection = selections[i][j];\n\n        // Behaviour depends on whether shift is currently being held down.\n        if(direction === \"left\") {\n          if(!this.state.holdingShift) {\n            selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            selection.wordEndIndex = selection.wordStartIndex;\n          } else { // If shift is being held down, move the wordEndIndex backwards or move the wordStartIndex backwards depending on the current selection.\n            if(selection.wordEndIndex > selection.wordStartIndex) {\n              selection.wordEndIndex--;\n            } else {\n              selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            }\n          }\n        } else if (direction === \"right\") {\n          if(!this.state.holdingShift) { // If shift *is* being held down, this won't happen (the wordStartIndex won't change).\n            selection.wordStartIndex = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n          }\n          selection.wordEndIndex   = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n        }\n\n        mostRecentSelectionText = this.state.data.documentGroup[i].slice(selection.wordStartIndex, selection.wordEndIndex + 1).join(' ');\n      }\n    }\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText\n    });\n  }\n\n  // Get an empty selections array whose length is the number of docs in the current documentGroup.\n  getEmptySelectionsArray(numDocs) {\n    if(!numDocs) {\n      var numDocs = this.state.data.documentGroup.length;\n    }\n    var selections = new Array(numDocs);\n    for(var i = 0; i < selections.length; i++) {\n      selections[i] = new Array();\n    }    \n    return selections;\n  }  \n\n  // Select the first word in the first sentence.\n  // (called when a new group is loaded).\n  selectFirstWord() {\n    var selections = this.state.selections;\n    selections[0].push({\n      wordStartIndex: 0,\n      wordEndIndex: 0\n    });\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: this.state.data.documentGroup[0][0],\n    });\n  }\n\n  // Clear all active selections by resetting the selections array.\n  clearSelections() {\n    this.setState( {\n      currentSelection: this.getEmptyCurrentSelection(),\n      selections: this.getEmptySelectionsArray()\n    });\n  }\n\n  // Update this component's selections state.\n  // This function is called via the mouse, and has no relation to the keyboard (keyboard selections are handled above).\n  // sentenceIndex: The index of the sentence in which the selection was made.\n  // wordIndex: the index of the word that was clicked on, or hovered over and the mouse released.\n  // action: Whether the mouse was pressed down ('down') or released ('up').\n  updateSelections(sentenceIndex, wordIndex, action) {\n    var wordStartIndex, wordEndIndex;\n\n    var selections = this.state.selections;\n    var currentSelection = this.state.currentSelection;\n\n    if (action === \"down\") { // Mouse down, i.e. a word was clicked.\n\n      if(!this.state.holdingCtrl) {\n        selections = this.getEmptySelectionsArray(); // Reset all selections upon clicking a word, unless Ctrl is being held.\n      }\n      wordStartIndex = wordIndex;\n      wordEndIndex = -1;\n\n      // A new selection is made, capturing the index of the sentence that the user clicked on and the index of the word that they clicked.\n      currentSelection = {\n        sentenceIndex: sentenceIndex,\n        wordStartIndex: wordStartIndex\n      }      \n\n    } else if(action === \"up\") { // Mouse up, i.e. mouse was released when hovering over a word.\n\n      // Only allow selections where the user has clicked on a starting word.\n      if(currentSelection.wordStartIndex === -1) {\n        this.clearSelections();\n        return;\n      }\n\n      wordStartIndex = currentSelection.wordStartIndex;\n\n      // If the first word selected was in a different sentence, the wordStartIndex becomes the start of the sentence where the mouse was released.\n      if(currentSelection.sentenceIndex !== sentenceIndex) {  // TODO: Make this consider mouseX relative to the X of the initial token?\n        wordStartIndex = 0;\n      };\n\n      wordEndIndex = wordIndex;\n\n      // If the second word selected was before the first, swapperino them around (so that backwards selections work as expected).\n      if(wordIndex < wordStartIndex) {\n        var s = wordStartIndex;\n        wordStartIndex = wordIndex;\n        wordEndIndex = s;\n      }     \n\n      // Create a new selections json object and push it to the selections array for this sentence.\n      currentSelection = this.getEmptyCurrentSelection();\n      selections[sentenceIndex].push({\n        wordStartIndex: wordStartIndex,\n        wordEndIndex: wordEndIndex\n      });\n      var mostRecentSelectionText = this.state.data.documentGroup[sentenceIndex].slice(wordStartIndex, wordEndIndex + 1).join(' ');\n\n      clearWindowSelection(); // Remove the default browser selection highlighty thing.\n    }    \n\n    this.setState({\n      currentSelection: currentSelection,\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText ? mostRecentSelectionText : this.state.mostRecentSelectionText,\n    });\n  }\n\n\n\n\n  /* Tag application function */\n\n  // Apply a specific tag to all current selections.\n  // entityClass: The full name of the entity class, e.g. 'item/pump/centrifugal_pump'.\n  // This function will either be called via clicking on an entity class in the tree, or by using hotkeys.\n  applyTag(entityClass) {    \n    //console.log(\"Applying tag:\", entityClass);\n    var selections = this.state.selections;\n    var documents = this.state.data.documentGroup;\n    var annotations = this.state.annotations;\n\n    for(var doc_idx in selections) {\n      for(var sel_idx in selections[doc_idx]) {\n        var sel = selections[doc_idx][sel_idx];\n        var start = sel.wordStartIndex;\n        var end = sel.wordEndIndex;\n\n\n        /* 1. Disjoint spans */\n        // Check all labels across this selected span of tokens are the same before proceeding.\n        // If they are not, they must be cleared before adding a label.\n        var annotationSpanStart = annotations[doc_idx][start].spanStartIdx;\n        var annotationSpanEnd   = annotations[doc_idx][start].spanEndIdx;\n        var notAllEqual = false;          \n        for(var k = start + 1; k <= end; k++) {\n          var otherAnnotation = annotations[doc_idx][k]; \n          if(annotationSpanStart !== otherAnnotation.spanStartIdx || annotationSpanEnd !== otherAnnotation.spanEndIdx) {\n            notAllEqual = true;\n            break;\n          }          \n        }        \n\n        // If the labels across all tokens in the selected span are not the same, remove all labels for the entire span.\n        // Then modify the spanEndIdx of any annotations in this document whose spanEndIdx was overlapping the\n        // span that the user selected, setting them to be start index - 1 (before the span).\n        // This ensures the ends of the spans are drawn properly.\n        if(notAllEqual) {\n          for(var k = start; k <= end; k++) {\n            var annotation = annotations[doc_idx][k];\n            annotation.removeAllLabels();\n          }          \n          // Adjust the span end index of all prev labels to be start index - 1\n          // A shame that we have to iterate across all annotations in this document - this could probably be optimised\n          // but it probably barely impacts performance even on large docs (I think)\n          for(var x in annotations[doc_idx]) {\n            var annotation = annotations[doc_idx][x];\n\n\n            // If this new span overlaps the *end* of an existing span, change that span's end index to the start of this new\n            // span, -1\n\n            if(annotation.spanEndIdx >= start && annotation.spanStartIdx <= start) {              \n              annotation.setSpanEndIdx(start - 1);\n\n            }\n\n            // If this new span overlaps the *start* of an existing span, change that span's start index to be the end of this new span -1\n            // and change the BIO tag to \"B\".\n            if(annotation.spanStartIdx <= end) {\n              annotation.setSpanStartIdx(end + 1);              \n              if(annotation.tokenIndex === (end + 1)) {\n                annotation.changeBioTag(\"B\") // I am realising now that this BIO tag is unnecessary - it could be inferred\n              }\n            }\n          }\n        }\n\n        /* 2. Overlapping spans */\n        // Check for any spans that this new span will cut into.\n        // First, check to the left and adjust the spanEndIdx of all Annotation objects\n        // to the left of this span if they overlap.\n        for(var ann_idx in annotations[doc_idx].slice(0, start)) {\n          var annotation = annotations[doc_idx][ann_idx];          \n          if(annotation.spanStartIdx < start && annotation.spanEndIdx >= end) {            \n            annotation.setSpanEndIdx(start - 1);\n          }\n        }\n\n        // Do the same for any Annotation objects on the right hand side of this span, which are part of the same\n        // mention.\n        for(var ann_idx in annotations[doc_idx].slice(end + 1, annotations[doc_idx].length)) {\n          var annotation = annotations[doc_idx][parseInt(ann_idx) + end + 1];\n          if(annotation.spanStartIdx <= start && annotation.spanEndIdx >= end) {\n            annotation.setSpanStartIdx(end + 1);\n            if(ann_idx === '0') {\n              annotation.changeBioTag(\"B\");\n            }\n          }\n        }\n\n        /* 3. Applying the labels */\n        // Now, apply the tags to every token in the selected span.\n        var labelWasModified = false;\n        for(var k = start; k <= end; k++) {\n          var bioTag = k === start ? \"B\" : \"I\";\n          var spanText = documents[doc_idx].slice(start, end + 1).join(' ');\n\n          //var prevAnnotation = k > 0 ? annotations[doc_idx][k - 1] : null;\n          //var nextAnnotation = k < (documents[doc_idx].length - 1) ? annotations[doc_idx][k + 1] : null;          \n\n          labelWasModified = annotations[doc_idx][k].addLabel(bioTag, entityClass, spanText, start, end);\n\n        }\n\n        if(labelWasModified) this.captureEvent('Applied label', parseInt(doc_idx), start, end, entityClass);\n      }\n    }\n    this.setState({\n      annotations: annotations,\n    }, () => {\n      this.justifyWords(); // Justify the words again to ensure the stripey lines line up correctly\n\n      // Debug:\n      //prettyPrintAnnotations(this.state.annotations[0]);\n      //console.log(\"Updated annotations[0]:\", this.state.annotations[0]);\n    })\n\n  }\n\n  // Deletes the specified tag.\n  deleteTag(sentenceIndex, wordIndex, entityClass) {\n    \n    var annotations = this.state.annotations;\n    var annotation = annotations[sentenceIndex][wordIndex];\n\n    // Retrieve the span start idx and span end idx of the annotation corresponding to (sentence_index, word_index)\n    var spanStart = annotation.spanStartIdx;\n    var spanEnd = annotation.spanEndIdx;\n\n    this.captureEvent('Deleted label', sentenceIndex, spanStart, spanEnd, entityClass);\n\n    // Find all annotations in this document in the same mention span and remove the label from all of them.\n    // (this will also remove the label from the annotation object at (sentence_index, word_index)).\n    for(var ann_idx in annotations[sentenceIndex]) {\n      var otherAnnotation = annotations[sentenceIndex][ann_idx];       \n      if(otherAnnotation.spanStartIdx === spanStart && otherAnnotation.spanEndIdx === spanEnd) {\n        otherAnnotation.removeLabel(entityClass);\n      }\n    }\n\n    this.setState({\n      annotations: annotations\n    })\n\n  }\n\n  /* Confidence */\n\n  // Updates the confidences array for the given doc.\n  // If the user clicks on the button they already clicked, then the confidence is reset to undefined.\n  updateConfidence(sentenceIndex, confidence) {\n    var confidences = this.state.confidences;\n    if(confidences[sentenceIndex] === confidence) {\n      confidences[sentenceIndex] = undefined;\n    } else {\n      confidences[sentenceIndex] = confidence;\n    }\n    this.setState({\n      confidences: confidences\n    });\n  }\n\n  /* Events */\n\n  // Capture an event\n  // TODO: Make it do something\n  captureEvent(eventAction, sentenceIndex, spanStart, spanEnd, entityClass) {\n\n    var tokenString = this.state.data.documentGroup[sentenceIndex].slice(spanStart, spanEnd + 1).join(' ')\n\n    var event = {\n      \"action\": eventAction,\n      \"sentenceIndex\": sentenceIndex,\n      \"wordIndex\": {\n        \"start\": spanStart,\n        \"end\": spanEnd,\n      },\n      \"entityClass\": entityClass,\n      \"tokenString\": tokenString\n    }\n\n    console.log(event);\n    if(eventAction === \"Applied label\" || eventAction === \"Deleted label\") {\n      this.setState({\n        changesMade: true,\n        recentlySaved: false,\n      })\n    }\n\n  }\n\n  /* Rendering function */\n\n\n  render() {\n\n    // TODO: Move all these to separate components\n\n    var groupName = <span className={\"group-name\" + (this.state.showingProgressBar ? \" progress-bar-underneath\" : \"\")}><span>Group <b>{this.state.pageNumber}</b> of <b>{this.state.data.docGroupsPerUser}</b></span></span>\n    var latestGroup = (this.state.totalPages) === this.state.pageNumber\n\n    var lastModified = this.state.docGroupLastModified ? \"Saved on \" + dateFormat(this.state.docGroupLastModified, 'dd mmm') + ' at ' + dateFormat(this.state.docGroupLastModified, 'h:MM tt') : (this.state.changesMade ? \"Changes not saved\" : \"\");\n\n    var saveButton = <button className={\"save-button\" + (this.state.changesMade ? \"\" : (this.state.recentlySaved ? \" recently-saved\" : \" disabled\"))} onClick={this.submitAnnotations.bind(this)}><i className={\"fa fa-\" + (this.state.recentlySaved ? \"check\" : \"save\")}></i>{ this.state.recentlySaved ? \"Saved\" : \"Save\"}</button>\n\n    var progressBar = <div id=\"tagging-progress-bar\" className={(this.state.showingProgressBar ? \"show\" : \"hide\")}><span className=\"progress-bar\"><span className=\"inner\" style={{\"width\": this.state.totalPages / this.state.data.docGroupsPerUser * 100 + \"%\"}}></span></span></div>\n\n    return (\n      <div id=\"app\">      \n        <Navbar pageTitle={\"Annotating project: \" + this.state.data.projectName}/>  \n        <div id=\"tagging-interface\" className={this.state.loading.querying ? \"loading\" : \"\"}>\n\n\n\n          <div id=\"tagging-container\">\n            <div id=\"sentence-tagging\">\n\n              { this.state.loading.firstLoad && \n              <div class=\"loading-message\">\n                <i class=\"fa fa-cog fa-spin\"></i>Loading...\n              </div>\n              }\n\n\n              <div id=\"pagination\">\n                <div className=\"page-button-container previous-page\"><button className={(this.state.pageNumber === 1 ? \" disabled\" : \"\")} onClick={this.loadPreviousPage.bind(this)}><i className=\"fa fa-chevron-left\"></i>Prev</button></div>\n                <div className=\"filler-left\"></div>\n                <div className=\"current-page-container\">{ groupName }{ progressBar }</div>\n\n                <div className=\"group-last-modified\">{ lastModified }</div>\n                <div className=\"page-button-container \">{ saveButton }</div>\n\n                <div className=\"page-button-container next-page\"><button className={(latestGroup ? \" disabled\" : \"\")}  onClick={this.loadNextPage.bind(this)}>Next<i className=\"fa fa-chevron-right\"></i></button></div>\n              </div>\n\n\n              <div className=\"document-container header\">\n                <div className=\"document header\">\n                  <div className=\"sentence-index\"></div>\n                  <div className=\"sentence\">Document</div>\n                  <div className=\"confidence-buttons\">Confidence</div>\n                </div>\n              </div>\n\n\n            \n              { this.state.data.documentGroup.map((doc, i) => \n\n                <DocumentContainer\n                  key={i}\n                  index={ i }\n                  displayIndex={( (this.state.pageNumber - 1) * 10 ) + i + 1  }\n                  words={doc}              \n                  annotations={this.state.annotations[i]}  \n                  confidence={this.state.confidences[i]}\n                  selections={this.state.selections[i]}\n                  updateSelections={this.updateSelections.bind(this)}\n                  updateConfidence={this.updateConfidence.bind(this)}\n                  entityColourMap={this.state.entityColourMap}\n                  deleteTag={this.deleteTag.bind(this)}\n                />\n                )}\n\n\n            </div>\n          </div>\n          <div id=\"tagging-menu\">\n            <WikipediaSummary tokens={this.state.mostRecentSelectionText}/>\n            <HotkeyInfo \n              chain={this.state.hotkeyChain}\n              entityClass={this.state.reverseHotkeyMap[this.state.hotkeyChain.join('')]}\n            />            \n            \n            <CategoryHierarchy\n              items={this.state.data.categoryHierarchy.children}\n              hotkeyMap={this.state.hotkeyMap}\n              hotkeyChain={this.state.hotkeyChain.join('')}\n              initHotkeyMap={this.initHotkeyMap.bind(this)}\n              applyTag={this.applyTag.bind(this)}              \n            />\n          </div>      \n        </div>\n      </div>\n    )\n  }\n}\n\n\n// The app, which renders the navbar and the tagging interface inside a container.\nfunction App() {\n  return (    \n    <TaggingInterface/>   \n  );\n}\n\n\n\nexport default App;\n\n// Old code\n/* \n<div className=\"submit-annotations-container\">\n  <button className=\"submit-annotations-button\" onClick={this.submitAnnotations.bind(this)}>Submit annotations <i className=\"fa fa-chevron-right\"></i></button>\n</div>\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}